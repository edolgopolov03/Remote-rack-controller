
ADC_Ctrlr_120.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007258  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000070  20000000  00007258  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020070  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020070  2**0
                  CONTENTS
  4 .bss          0000ea94  20000080  000072e0  00020080  2**5
                  ALLOC
  5 .stack        00010004  2000eb14  00015d74  00020080  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020070  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  0002009e  2**0
                  CONTENTS, READONLY
  8 .debug_info   0005bd87  00000000  00000000  000200f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00007a09  00000000  00000000  0007be7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0002303c  00000000  00000000  00083887  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001a98  00000000  00000000  000a68c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000022e0  00000000  00000000  000a835b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0004090d  00000000  00000000  000aa63b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00028e4b  00000000  00000000  000eaf48  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00135aca  00000000  00000000  00113d93  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00004f7c  00000000  00000000  00249860  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	18 eb 01 20 e9 02 00 00 e5 02 00 00 e5 02 00 00     ... ............
      10:	e5 02 00 00 e5 02 00 00 e5 02 00 00 00 00 00 00     ................
	...
      2c:	61 41 00 00 e5 02 00 00 00 00 00 00 f1 41 00 00     aA...........A..
      3c:	51 42 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     QB..............
      4c:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
      5c:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
      6c:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
      7c:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
      8c:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
      9c:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
      ac:	e5 02 00 00 e5 02 00 00 e5 22 00 00 f9 22 00 00     ........."..."..
      bc:	39 20 00 00 45 20 00 00 51 20 00 00 5d 20 00 00     9 ..E ..Q ..] ..
      cc:	69 20 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     i ..............
      dc:	e5 02 00 00 e5 02 00 00 e5 02 00 00 00 00 00 00     ................
	...
      f4:	55 24 00 00 b9 28 00 00 cd 28 00 00 e1 28 00 00     U$...(...(...(..
     104:	f5 28 00 00 09 29 00 00 1d 29 00 00 31 29 00 00     .(...)...)..1)..
     114:	45 29 00 00 59 29 00 00 6d 29 00 00 81 29 00 00     E)..Y)..m)...)..
     124:	95 29 00 00 a9 29 00 00 bd 29 00 00 d1 29 00 00     .)...)...)...)..
     134:	e5 29 00 00 f9 29 00 00 0d 2a 00 00 21 2a 00 00     .)...)...*..!*..
     144:	35 2a 00 00 49 2a 00 00 5d 2a 00 00 71 2a 00 00     5*..I*..]*..q*..
     154:	85 2a 00 00 99 2a 00 00 ad 2a 00 00 c1 2a 00 00     .*...*...*...*..
     164:	d5 2a 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     .*..............
     174:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e9 3b 00 00     .............;..
     184:	f5 3b 00 00 01 3c 00 00 0d 3c 00 00 d1 20 00 00     .;...<...<... ..
     194:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     1a4:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     1b4:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     1c4:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     1d4:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     1e4:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     1f4:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     204:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     214:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     224:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     234:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     244:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................
     254:	e5 02 00 00 e5 02 00 00 e5 02 00 00 e5 02 00 00     ................

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	20000080 	.word	0x20000080
     280:	00000000 	.word	0x00000000
     284:	00007258 	.word	0x00007258

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	00007258 	.word	0x00007258
     2c4:	20000084 	.word	0x20000084
     2c8:	00007258 	.word	0x00007258
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     2d0:	b508      	push	{r3, lr}
	system_init();
     2d2:	4b02      	ldr	r3, [pc, #8]	; (2dc <atmel_start_init+0xc>)
     2d4:	4798      	blx	r3
	ethernet_phys_init();
     2d6:	4b02      	ldr	r3, [pc, #8]	; (2e0 <atmel_start_init+0x10>)
     2d8:	4798      	blx	r3
     2da:	bd08      	pop	{r3, pc}
     2dc:	00000ad5 	.word	0x00000ad5
     2e0:	00000e79 	.word	0x00000e79

000002e4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     2e4:	e7fe      	b.n	2e4 <Dummy_Handler>
	...

000002e8 <Reset_Handler>:
{
     2e8:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
     2ea:	4b1c      	ldr	r3, [pc, #112]	; (35c <Reset_Handler+0x74>)
     2ec:	4a1c      	ldr	r2, [pc, #112]	; (360 <Reset_Handler+0x78>)
     2ee:	429a      	cmp	r2, r3
     2f0:	d010      	beq.n	314 <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
     2f2:	4b1c      	ldr	r3, [pc, #112]	; (364 <Reset_Handler+0x7c>)
     2f4:	4a19      	ldr	r2, [pc, #100]	; (35c <Reset_Handler+0x74>)
     2f6:	429a      	cmp	r2, r3
     2f8:	d20c      	bcs.n	314 <Reset_Handler+0x2c>
     2fa:	3b01      	subs	r3, #1
     2fc:	1a9b      	subs	r3, r3, r2
     2fe:	f023 0303 	bic.w	r3, r3, #3
     302:	3304      	adds	r3, #4
     304:	4413      	add	r3, r2
     306:	4916      	ldr	r1, [pc, #88]	; (360 <Reset_Handler+0x78>)
                        *pDest++ = *pSrc++;
     308:	f851 0b04 	ldr.w	r0, [r1], #4
     30c:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
     310:	429a      	cmp	r2, r3
     312:	d1f9      	bne.n	308 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
     314:	4b14      	ldr	r3, [pc, #80]	; (368 <Reset_Handler+0x80>)
     316:	4a15      	ldr	r2, [pc, #84]	; (36c <Reset_Handler+0x84>)
     318:	429a      	cmp	r2, r3
     31a:	d20a      	bcs.n	332 <Reset_Handler+0x4a>
     31c:	3b01      	subs	r3, #1
     31e:	1a9b      	subs	r3, r3, r2
     320:	f023 0303 	bic.w	r3, r3, #3
     324:	3304      	adds	r3, #4
     326:	4413      	add	r3, r2
                *pDest++ = 0;
     328:	2100      	movs	r1, #0
     32a:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
     32e:	4293      	cmp	r3, r2
     330:	d1fb      	bne.n	32a <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     332:	4b0f      	ldr	r3, [pc, #60]	; (370 <Reset_Handler+0x88>)
     334:	4a0f      	ldr	r2, [pc, #60]	; (374 <Reset_Handler+0x8c>)
     336:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
     33a:	609a      	str	r2, [r3, #8]
        SCB->CPACR |=  (0xFu << 20);
     33c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
     340:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
     344:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     348:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     34c:	f3bf 8f6f 	isb	sy
        __libc_init_array();
     350:	4b09      	ldr	r3, [pc, #36]	; (378 <Reset_Handler+0x90>)
     352:	4798      	blx	r3
        main();
     354:	4b09      	ldr	r3, [pc, #36]	; (37c <Reset_Handler+0x94>)
     356:	4798      	blx	r3
     358:	e7fe      	b.n	358 <Reset_Handler+0x70>
     35a:	bf00      	nop
     35c:	20000000 	.word	0x20000000
     360:	00007258 	.word	0x00007258
     364:	20000070 	.word	0x20000070
     368:	2000eb14 	.word	0x2000eb14
     36c:	20000080 	.word	0x20000080
     370:	e000ed00 	.word	0xe000ed00
     374:	00000000 	.word	0x00000000
     378:	00005c7d 	.word	0x00005c7d
     37c:	00003d45 	.word	0x00003d45

00000380 <FLASH_0_CLOCK_init>:
}

static inline void hri_mclk_set_AHBMASK_NVMCTRL_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
     380:	4a02      	ldr	r2, [pc, #8]	; (38c <FLASH_0_CLOCK_init+0xc>)
     382:	6913      	ldr	r3, [r2, #16]
     384:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     388:	6113      	str	r3, [r2, #16]
     38a:	4770      	bx	lr
     38c:	40000800 	.word	0x40000800

00000390 <FLASH_0_init>:

	hri_mclk_set_AHBMASK_NVMCTRL_bit(MCLK);
}

void FLASH_0_init(void)
{
     390:	b508      	push	{r3, lr}
	FLASH_0_CLOCK_init();
     392:	4b03      	ldr	r3, [pc, #12]	; (3a0 <FLASH_0_init+0x10>)
     394:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
     396:	4903      	ldr	r1, [pc, #12]	; (3a4 <FLASH_0_init+0x14>)
     398:	4803      	ldr	r0, [pc, #12]	; (3a8 <FLASH_0_init+0x18>)
     39a:	4b04      	ldr	r3, [pc, #16]	; (3ac <FLASH_0_init+0x1c>)
     39c:	4798      	blx	r3
     39e:	bd08      	pop	{r3, pc}
     3a0:	00000381 	.word	0x00000381
     3a4:	41004000 	.word	0x41004000
     3a8:	2000e508 	.word	0x2000e508
     3ac:	000010ad 	.word	0x000010ad

000003b0 <SPI_0_PORT_init>:
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     3b0:	4b28      	ldr	r3, [pc, #160]	; (454 <SPI_0_PORT_init+0xa4>)
     3b2:	2210      	movs	r2, #16
     3b4:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     3b6:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     3b8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     3bc:	629a      	str	r2, [r3, #40]	; 0x28
     3be:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
     3c2:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3c4:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
	tmp &= ~PORT_PINCFG_PMUXEN;
     3c8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3cc:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3d0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3d4:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     3d8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     3dc:	f042 0203 	orr.w	r2, r2, #3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3e0:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     3e4:	2220      	movs	r2, #32
     3e6:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     3e8:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     3ea:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     3ee:	629a      	str	r2, [r3, #40]	; 0x28
     3f0:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3f2:	f893 2045 	ldrb.w	r2, [r3, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
     3f6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3fa:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3fe:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     402:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     406:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     40a:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     40e:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     412:	2240      	movs	r2, #64	; 0x40
     414:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     416:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     41a:	f502 3200 	add.w	r2, r2, #131072	; 0x20000
     41e:	629a      	str	r2, [r3, #40]	; 0x28
     420:	4a0d      	ldr	r2, [pc, #52]	; (458 <SPI_0_PORT_init+0xa8>)
     422:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     424:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
     428:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     42c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     430:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
	tmp &= ~PORT_PINCFG_PMUXEN;
     434:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     438:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     43c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     440:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     444:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     448:	f042 0203 	orr.w	r2, r2, #3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     44c:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
     450:	4770      	bx	lr
     452:	bf00      	nop
     454:	41008000 	.word	0x41008000
     458:	c0020000 	.word	0xc0020000

0000045c <SPI_0_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     45c:	4b06      	ldr	r3, [pc, #24]	; (478 <SPI_0_CLOCK_init+0x1c>)
     45e:	2240      	movs	r2, #64	; 0x40
     460:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
     464:	2243      	movs	r2, #67	; 0x43
     466:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBAMASK_SERCOM0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
     46a:	4a04      	ldr	r2, [pc, #16]	; (47c <SPI_0_CLOCK_init+0x20>)
     46c:	6953      	ldr	r3, [r2, #20]
     46e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     472:	6153      	str	r3, [r2, #20]
     474:	4770      	bx	lr
     476:	bf00      	nop
     478:	40001c00 	.word	0x40001c00
     47c:	40000800 	.word	0x40000800

00000480 <SPI_0_init>:

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}

void SPI_0_init(void)
{
     480:	b508      	push	{r3, lr}
	SPI_0_CLOCK_init();
     482:	4b04      	ldr	r3, [pc, #16]	; (494 <SPI_0_init+0x14>)
     484:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SERCOM0);
     486:	4904      	ldr	r1, [pc, #16]	; (498 <SPI_0_init+0x18>)
     488:	4804      	ldr	r0, [pc, #16]	; (49c <SPI_0_init+0x1c>)
     48a:	4b05      	ldr	r3, [pc, #20]	; (4a0 <SPI_0_init+0x20>)
     48c:	4798      	blx	r3
	SPI_0_PORT_init();
     48e:	4b05      	ldr	r3, [pc, #20]	; (4a4 <SPI_0_init+0x24>)
     490:	4798      	blx	r3
     492:	bd08      	pop	{r3, pc}
     494:	0000045d 	.word	0x0000045d
     498:	40003000 	.word	0x40003000
     49c:	2000e63c 	.word	0x2000e63c
     4a0:	00001279 	.word	0x00001279
     4a4:	000003b1 	.word	0x000003b1

000004a8 <ADC_0_PORT_init>:
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     4a8:	4b0e      	ldr	r3, [pc, #56]	; (4e4 <ADC_0_PORT_init+0x3c>)
     4aa:	2210      	movs	r2, #16
     4ac:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     4b0:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     4b4:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
     4b8:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
     4bc:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4c0:	f893 20c4 	ldrb.w	r2, [r3, #196]	; 0xc4
	tmp &= ~PORT_PINCFG_PMUXEN;
     4c4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4c8:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4cc:	f883 20c4 	strb.w	r2, [r3, #196]	; 0xc4
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4d0:	f893 20b2 	ldrb.w	r2, [r3, #178]	; 0xb2
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     4d4:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     4d8:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4dc:	f883 20b2 	strb.w	r2, [r3, #178]	; 0xb2
     4e0:	4770      	bx	lr
     4e2:	bf00      	nop
     4e4:	41008000 	.word	0x41008000

000004e8 <ADC_0_CLOCK_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
     4e8:	4a04      	ldr	r2, [pc, #16]	; (4fc <ADC_0_CLOCK_init+0x14>)
     4ea:	6a13      	ldr	r3, [r2, #32]
     4ec:	f443 7380 	orr.w	r3, r3, #256	; 0x100
     4f0:	6213      	str	r3, [r2, #32]
     4f2:	2243      	movs	r2, #67	; 0x43
     4f4:	4b02      	ldr	r3, [pc, #8]	; (500 <ADC_0_CLOCK_init+0x18>)
     4f6:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
     4fa:	4770      	bx	lr
     4fc:	40000800 	.word	0x40000800
     500:	40001c00 	.word	0x40001c00

00000504 <ADC_0_init>:
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}

void ADC_0_init(void)
{
     504:	b508      	push	{r3, lr}
	ADC_0_CLOCK_init();
     506:	4b05      	ldr	r3, [pc, #20]	; (51c <ADC_0_init+0x18>)
     508:	4798      	blx	r3
	ADC_0_PORT_init();
     50a:	4b05      	ldr	r3, [pc, #20]	; (520 <ADC_0_init+0x1c>)
     50c:	4798      	blx	r3
	adc_sync_init(&ADC_0, ADC1, (void *)NULL);
     50e:	2200      	movs	r2, #0
     510:	4904      	ldr	r1, [pc, #16]	; (524 <ADC_0_init+0x20>)
     512:	4805      	ldr	r0, [pc, #20]	; (528 <ADC_0_init+0x24>)
     514:	4b05      	ldr	r3, [pc, #20]	; (52c <ADC_0_init+0x28>)
     516:	4798      	blx	r3
     518:	bd08      	pop	{r3, pc}
     51a:	bf00      	nop
     51c:	000004e9 	.word	0x000004e9
     520:	000004a9 	.word	0x000004a9
     524:	43002000 	.word	0x43002000
     528:	2000e624 	.word	0x2000e624
     52c:	00000e85 	.word	0x00000e85

00000530 <DAC_0_PORT_init>:
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     530:	4b17      	ldr	r3, [pc, #92]	; (590 <DAC_0_PORT_init+0x60>)
     532:	2204      	movs	r2, #4
     534:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     536:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     53a:	629a      	str	r2, [r3, #40]	; 0x28
     53c:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
     540:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     542:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
	tmp &= ~PORT_PINCFG_PMUXEN;
     546:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     54a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     54e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     552:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     556:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     55a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     55e:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     562:	2220      	movs	r2, #32
     564:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     566:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     56a:	629a      	str	r2, [r3, #40]	; 0x28
     56c:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     56e:	f893 2045 	ldrb.w	r2, [r3, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
     572:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     576:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     57a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     57e:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     582:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     586:	f042 0210 	orr.w	r2, r2, #16
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     58a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
     58e:	4770      	bx	lr
     590:	41008000 	.word	0x41008000

00000594 <DAC_0_CLOCK_init>:
}

static inline void hri_mclk_set_APBDMASK_DAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_DAC;
     594:	4a04      	ldr	r2, [pc, #16]	; (5a8 <DAC_0_CLOCK_init+0x14>)
     596:	6a13      	ldr	r3, [r2, #32]
     598:	f443 7300 	orr.w	r3, r3, #512	; 0x200
     59c:	6213      	str	r3, [r2, #32]
     59e:	2240      	movs	r2, #64	; 0x40
     5a0:	4b02      	ldr	r3, [pc, #8]	; (5ac <DAC_0_CLOCK_init+0x18>)
     5a2:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
     5a6:	4770      	bx	lr
     5a8:	40000800 	.word	0x40000800
     5ac:	40001c00 	.word	0x40001c00

000005b0 <DAC_0_init>:
	hri_mclk_set_APBDMASK_DAC_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, DAC_GCLK_ID, CONF_GCLK_DAC_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}

void DAC_0_init(void)
{
     5b0:	b508      	push	{r3, lr}
	DAC_0_CLOCK_init();
     5b2:	4b04      	ldr	r3, [pc, #16]	; (5c4 <DAC_0_init+0x14>)
     5b4:	4798      	blx	r3
	dac_sync_init(&DAC_0, DAC);
     5b6:	4904      	ldr	r1, [pc, #16]	; (5c8 <DAC_0_init+0x18>)
     5b8:	4804      	ldr	r0, [pc, #16]	; (5cc <DAC_0_init+0x1c>)
     5ba:	4b05      	ldr	r3, [pc, #20]	; (5d0 <DAC_0_init+0x20>)
     5bc:	4798      	blx	r3
	DAC_0_PORT_init();
     5be:	4b05      	ldr	r3, [pc, #20]	; (5d4 <DAC_0_init+0x24>)
     5c0:	4798      	blx	r3
     5c2:	bd08      	pop	{r3, pc}
     5c4:	00000595 	.word	0x00000595
     5c8:	43002400 	.word	0x43002400
     5cc:	2000e628 	.word	0x2000e628
     5d0:	00000f9d 	.word	0x00000f9d
     5d4:	00000531 	.word	0x00000531

000005d8 <USART_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5d8:	4b10      	ldr	r3, [pc, #64]	; (61c <USART_0_PORT_init+0x44>)
     5da:	f893 2144 	ldrb.w	r2, [r3, #324]	; 0x144
	tmp &= ~PORT_PINCFG_PMUXEN;
     5de:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5e2:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5e6:	f883 2144 	strb.w	r2, [r3, #324]	; 0x144
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5ea:	f893 2132 	ldrb.w	r2, [r3, #306]	; 0x132
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5ee:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     5f2:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5f6:	f883 2132 	strb.w	r2, [r3, #306]	; 0x132
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5fa:	f893 2145 	ldrb.w	r2, [r3, #325]	; 0x145
	tmp &= ~PORT_PINCFG_PMUXEN;
     5fe:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     602:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     606:	f883 2145 	strb.w	r2, [r3, #325]	; 0x145
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     60a:	f893 2132 	ldrb.w	r2, [r3, #306]	; 0x132
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     60e:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     612:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     616:	f883 2132 	strb.w	r2, [r3, #306]	; 0x132
     61a:	4770      	bx	lr
     61c:	41008000 	.word	0x41008000

00000620 <USART_0_CLOCK_init>:
     620:	4b06      	ldr	r3, [pc, #24]	; (63c <USART_0_CLOCK_init+0x1c>)
     622:	2241      	movs	r2, #65	; 0x41
     624:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
     628:	2243      	movs	r2, #67	; 0x43
     62a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM6;
     62e:	4a04      	ldr	r2, [pc, #16]	; (640 <USART_0_CLOCK_init+0x20>)
     630:	6a13      	ldr	r3, [r2, #32]
     632:	f043 0304 	orr.w	r3, r3, #4
     636:	6213      	str	r3, [r2, #32]
     638:	4770      	bx	lr
     63a:	bf00      	nop
     63c:	40001c00 	.word	0x40001c00
     640:	40000800 	.word	0x40000800

00000644 <USART_0_init>:

	hri_mclk_set_APBDMASK_SERCOM6_bit(MCLK);
}

void USART_0_init(void) //для связи с контроллером предусилителей
{
     644:	b530      	push	{r4, r5, lr}
     646:	b083      	sub	sp, #12

	USART_0_CLOCK_init();
     648:	4b0e      	ldr	r3, [pc, #56]	; (684 <USART_0_init+0x40>)
     64a:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     64c:	4b0e      	ldr	r3, [pc, #56]	; (688 <USART_0_init+0x44>)
     64e:	22c0      	movs	r2, #192	; 0xc0
     650:	f883 2346 	strb.w	r2, [r3, #838]	; 0x346
     654:	f883 2347 	strb.w	r2, [r3, #839]	; 0x347
     658:	f883 2348 	strb.w	r2, [r3, #840]	; 0x348
     65c:	f883 2349 	strb.w	r2, [r3, #841]	; 0x349
	uint32_t irq = SERCOM6_0_IRQn;
	for (uint32_t i = 0; i < 4; i++) {
		NVIC_SetPriority((IRQn_Type)irq, PERIPHERAL_INTERRUPT_PRIORITY);
		irq++;
	}
	usart_os_init(&USART_0, SERCOM6, USART_0_buffer, USART_0_BUFFER_SIZE, (void *)NULL);
     660:	4c0a      	ldr	r4, [pc, #40]	; (68c <USART_0_init+0x48>)
     662:	2300      	movs	r3, #0
     664:	9300      	str	r3, [sp, #0]
     666:	f44f 7380 	mov.w	r3, #256	; 0x100
     66a:	4a09      	ldr	r2, [pc, #36]	; (690 <USART_0_init+0x4c>)
     66c:	4909      	ldr	r1, [pc, #36]	; (694 <USART_0_init+0x50>)
     66e:	4620      	mov	r0, r4
     670:	4d09      	ldr	r5, [pc, #36]	; (698 <USART_0_init+0x54>)
     672:	47a8      	blx	r5
	usart_os_enable(&USART_0);
     674:	4620      	mov	r0, r4
     676:	4b09      	ldr	r3, [pc, #36]	; (69c <USART_0_init+0x58>)
     678:	4798      	blx	r3
	USART_0_PORT_init();
     67a:	4b09      	ldr	r3, [pc, #36]	; (6a0 <USART_0_init+0x5c>)
     67c:	4798      	blx	r3
}
     67e:	b003      	add	sp, #12
     680:	bd30      	pop	{r4, r5, pc}
     682:	bf00      	nop
     684:	00000621 	.word	0x00000621
     688:	e000e100 	.word	0xe000e100
     68c:	2000e680 	.word	0x2000e680
     690:	2000e524 	.word	0x2000e524
     694:	43000800 	.word	0x43000800
     698:	000014d5 	.word	0x000014d5
     69c:	000015cd 	.word	0x000015cd
     6a0:	000005d9 	.word	0x000005d9

000006a4 <USART_1_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6a4:	4b10      	ldr	r3, [pc, #64]	; (6e8 <USART_1_PORT_init+0x44>)
     6a6:	f893 21c8 	ldrb.w	r2, [r3, #456]	; 0x1c8
	tmp &= ~PORT_PINCFG_PMUXEN;
     6aa:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     6ae:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6b2:	f883 21c8 	strb.w	r2, [r3, #456]	; 0x1c8
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     6b6:	f893 21b4 	ldrb.w	r2, [r3, #436]	; 0x1b4
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     6ba:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     6be:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     6c2:	f883 21b4 	strb.w	r2, [r3, #436]	; 0x1b4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6c6:	f893 21c9 	ldrb.w	r2, [r3, #457]	; 0x1c9
	tmp &= ~PORT_PINCFG_PMUXEN;
     6ca:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     6ce:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6d2:	f883 21c9 	strb.w	r2, [r3, #457]	; 0x1c9
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     6d6:	f893 21b4 	ldrb.w	r2, [r3, #436]	; 0x1b4
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     6da:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     6de:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     6e2:	f883 21b4 	strb.w	r2, [r3, #436]	; 0x1b4
     6e6:	4770      	bx	lr
     6e8:	41008000 	.word	0x41008000

000006ec <USART_1_CLOCK_init>:
     6ec:	4b06      	ldr	r3, [pc, #24]	; (708 <USART_1_CLOCK_init+0x1c>)
     6ee:	2240      	movs	r2, #64	; 0x40
     6f0:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
     6f4:	2243      	movs	r2, #67	; 0x43
     6f6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
     6fa:	4a04      	ldr	r2, [pc, #16]	; (70c <USART_1_CLOCK_init+0x20>)
     6fc:	6a13      	ldr	r3, [r2, #32]
     6fe:	f043 0308 	orr.w	r3, r3, #8
     702:	6213      	str	r3, [r2, #32]
     704:	4770      	bx	lr
     706:	bf00      	nop
     708:	40001c00 	.word	0x40001c00
     70c:	40000800 	.word	0x40000800

00000710 <USART_1_init>:

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
}

void USART_1_init(void) // для отладки
{
     710:	b508      	push	{r3, lr}
	USART_1_CLOCK_init();
     712:	4b05      	ldr	r3, [pc, #20]	; (728 <USART_1_init+0x18>)
     714:	4798      	blx	r3
	usart_sync_init(&USART_1, SERCOM7, (void *)NULL);
     716:	2200      	movs	r2, #0
     718:	4904      	ldr	r1, [pc, #16]	; (72c <USART_1_init+0x1c>)
     71a:	4805      	ldr	r0, [pc, #20]	; (730 <USART_1_init+0x20>)
     71c:	4b05      	ldr	r3, [pc, #20]	; (734 <USART_1_init+0x24>)
     71e:	4798      	blx	r3
	USART_1_PORT_init();
     720:	4b05      	ldr	r3, [pc, #20]	; (738 <USART_1_init+0x28>)
     722:	4798      	blx	r3
     724:	bd08      	pop	{r3, pc}
     726:	bf00      	nop
     728:	000006ed 	.word	0x000006ed
     72c:	43000c00 	.word	0x43000c00
     730:	2000e6cc 	.word	0x2000e6cc
     734:	000016cd 	.word	0x000016cd
     738:	000006a5 	.word	0x000006a5

0000073c <USB_0_PORT_init>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     73c:	4b1e      	ldr	r3, [pc, #120]	; (7b8 <USB_0_PORT_init+0x7c>)
     73e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
     742:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     744:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
     748:	6299      	str	r1, [r3, #40]	; 0x28
     74a:	481c      	ldr	r0, [pc, #112]	; (7bc <USB_0_PORT_init+0x80>)
     74c:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     74e:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     750:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
     754:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     758:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     75c:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
	tmp &= ~PORT_PINCFG_PMUXEN;
     760:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     764:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     768:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     76c:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     770:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     774:	f042 0207 	orr.w	r2, r2, #7
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     778:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     77c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
     780:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     782:	6299      	str	r1, [r3, #40]	; 0x28
     784:	490e      	ldr	r1, [pc, #56]	; (7c0 <USB_0_PORT_init+0x84>)
     786:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     788:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     78a:	f893 2059 	ldrb.w	r2, [r3, #89]	; 0x59
     78e:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     792:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     796:	f893 2059 	ldrb.w	r2, [r3, #89]	; 0x59
	tmp &= ~PORT_PINCFG_PMUXEN;
     79a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     79e:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7a2:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     7a6:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     7aa:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     7ae:	f042 0270 	orr.w	r2, r2, #112	; 0x70
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     7b2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
     7b6:	4770      	bx	lr
     7b8:	41008000 	.word	0x41008000
     7bc:	c0000100 	.word	0xc0000100
     7c0:	c0000200 	.word	0xc0000200

000007c4 <USB_0_CLOCK_init>:
     7c4:	2241      	movs	r2, #65	; 0x41
     7c6:	4b07      	ldr	r3, [pc, #28]	; (7e4 <USB_0_CLOCK_init+0x20>)
     7c8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
     7cc:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
     7d0:	691a      	ldr	r2, [r3, #16]
     7d2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
     7d6:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
     7d8:	699a      	ldr	r2, [r3, #24]
     7da:	f042 0201 	orr.w	r2, r2, #1
     7de:	619a      	str	r2, [r3, #24]
     7e0:	4770      	bx	lr
     7e2:	bf00      	nop
     7e4:	40001c00 	.word	0x40001c00

000007e8 <TIMER_1_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
     7e8:	4b07      	ldr	r3, [pc, #28]	; (808 <TIMER_1_CLOCK_init+0x20>)
     7ea:	695a      	ldr	r2, [r3, #20]
     7ec:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
     7f0:	615a      	str	r2, [r3, #20]
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC1;
     7f2:	695a      	ldr	r2, [r3, #20]
     7f4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
     7f8:	615a      	str	r2, [r3, #20]
     7fa:	2240      	movs	r2, #64	; 0x40
     7fc:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
     800:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
     804:	4770      	bx	lr
     806:	bf00      	nop
     808:	40000800 	.word	0x40000800

0000080c <TIMER_0_CLOCK_init>:
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC2;
     80c:	4b07      	ldr	r3, [pc, #28]	; (82c <TIMER_0_CLOCK_init+0x20>)
     80e:	699a      	ldr	r2, [r3, #24]
     810:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
     814:	619a      	str	r2, [r3, #24]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC3;
     816:	699a      	ldr	r2, [r3, #24]
     818:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
     81c:	619a      	str	r2, [r3, #24]
     81e:	2243      	movs	r2, #67	; 0x43
     820:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
     824:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
     828:	4770      	bx	lr
     82a:	bf00      	nop
     82c:	40000800 	.word	0x40000800

00000830 <USB_0_init>:
	hri_mclk_set_APBBMASK_TC3_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC2_GCLK_ID, CONF_GCLK_TC2_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}

void USB_0_init(void)
{
     830:	b508      	push	{r3, lr}
	USB_0_CLOCK_init();
     832:	4b03      	ldr	r3, [pc, #12]	; (840 <USB_0_init+0x10>)
     834:	4798      	blx	r3
	usb_d_init();
     836:	4b03      	ldr	r3, [pc, #12]	; (844 <USB_0_init+0x14>)
     838:	4798      	blx	r3
	USB_0_PORT_init();
     83a:	4b03      	ldr	r3, [pc, #12]	; (848 <USB_0_init+0x18>)
     83c:	4798      	blx	r3
     83e:	bd08      	pop	{r3, pc}
     840:	000007c5 	.word	0x000007c5
     844:	00001995 	.word	0x00001995
     848:	0000073d 	.word	0x0000073d

0000084c <ETHERNET_MAC_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     84c:	4b90      	ldr	r3, [pc, #576]	; (a90 <ETHERNET_MAC_0_PORT_init+0x244>)
     84e:	f893 2155 	ldrb.w	r2, [r3, #341]	; 0x155
	tmp &= ~PORT_PINCFG_PMUXEN;
     852:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     856:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     85a:	f883 2155 	strb.w	r2, [r3, #341]	; 0x155
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     85e:	f893 213a 	ldrb.w	r2, [r3, #314]	; 0x13a
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     862:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     866:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     86a:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     86e:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
	tmp &= ~PORT_PINCFG_PMUXEN;
     872:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     876:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     87a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     87e:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     882:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     886:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     88a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     88e:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
	tmp &= ~PORT_PINCFG_PMUXEN;
     892:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     896:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     89a:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     89e:	f893 203a 	ldrb.w	r2, [r3, #58]	; 0x3a
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     8a2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     8a6:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     8aa:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8ae:	f893 2055 	ldrb.w	r2, [r3, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
     8b2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8b6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8ba:	f883 2055 	strb.w	r2, [r3, #85]	; 0x55
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     8be:	f893 203a 	ldrb.w	r2, [r3, #58]	; 0x3a
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     8c2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     8c6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     8ca:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8ce:	f893 204d 	ldrb.w	r2, [r3, #77]	; 0x4d
	tmp &= ~PORT_PINCFG_PMUXEN;
     8d2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8d6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8da:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     8de:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     8e2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     8e6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     8ea:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8ee:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
	tmp &= ~PORT_PINCFG_PMUXEN;
     8f2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8f6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8fa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     8fe:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     902:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     906:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     90a:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     90e:	f893 214f 	ldrb.w	r2, [r3, #335]	; 0x14f
	tmp &= ~PORT_PINCFG_PMUXEN;
     912:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     916:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     91a:	f883 214f 	strb.w	r2, [r3, #335]	; 0x14f
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     91e:	f893 2137 	ldrb.w	r2, [r3, #311]	; 0x137
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     922:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     926:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     92a:	f883 2137 	strb.w	r2, [r3, #311]	; 0x137
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     92e:	f893 214e 	ldrb.w	r2, [r3, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
     932:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     936:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     93a:	f883 214e 	strb.w	r2, [r3, #334]	; 0x14e
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     93e:	f893 2137 	ldrb.w	r2, [r3, #311]	; 0x137
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     942:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     946:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     94a:	f883 2137 	strb.w	r2, [r3, #311]	; 0x137
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     94e:	f893 2152 	ldrb.w	r2, [r3, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
     952:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     956:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     95a:	f883 2152 	strb.w	r2, [r3, #338]	; 0x152
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     95e:	f893 2139 	ldrb.w	r2, [r3, #313]	; 0x139
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     962:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     966:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     96a:	f883 2139 	strb.w	r2, [r3, #313]	; 0x139
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     96e:	f893 2154 	ldrb.w	r2, [r3, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
     972:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     976:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     97a:	f883 2154 	strb.w	r2, [r3, #340]	; 0x154
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     97e:	f893 213a 	ldrb.w	r2, [r3, #314]	; 0x13a
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     982:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     986:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     98a:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     98e:	f893 204f 	ldrb.w	r2, [r3, #79]	; 0x4f
	tmp &= ~PORT_PINCFG_PMUXEN;
     992:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     996:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     99a:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     99e:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     9a2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     9a6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     9aa:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9ae:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
	tmp &= ~PORT_PINCFG_PMUXEN;
     9b2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     9b6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9ba:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     9be:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     9c2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     9c6:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     9ca:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9ce:	f893 2053 	ldrb.w	r2, [r3, #83]	; 0x53
	tmp &= ~PORT_PINCFG_PMUXEN;
     9d2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     9d6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9da:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     9de:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     9e2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     9e6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     9ea:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9ee:	f893 2150 	ldrb.w	r2, [r3, #336]	; 0x150
	tmp &= ~PORT_PINCFG_PMUXEN;
     9f2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     9f6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9fa:	f883 2150 	strb.w	r2, [r3, #336]	; 0x150
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     9fe:	f893 2138 	ldrb.w	r2, [r3, #312]	; 0x138
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     a02:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     a06:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a0a:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a0e:	f893 2151 	ldrb.w	r2, [r3, #337]	; 0x151
	tmp &= ~PORT_PINCFG_PMUXEN;
     a12:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a16:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a1a:	f883 2151 	strb.w	r2, [r3, #337]	; 0x151
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a1e:	f893 2138 	ldrb.w	r2, [r3, #312]	; 0x138
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     a22:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     a26:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a2a:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a2e:	f893 204e 	ldrb.w	r2, [r3, #78]	; 0x4e
	tmp &= ~PORT_PINCFG_PMUXEN;
     a32:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a36:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a3a:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a3e:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     a42:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     a46:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a4a:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a4e:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
	tmp &= ~PORT_PINCFG_PMUXEN;
     a52:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a56:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a5a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a5e:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     a62:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     a66:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a6a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a6e:	f893 2153 	ldrb.w	r2, [r3, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
     a72:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a76:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a7a:	f883 2153 	strb.w	r2, [r3, #339]	; 0x153
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a7e:	f893 2139 	ldrb.w	r2, [r3, #313]	; 0x139
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     a82:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     a86:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a8a:	f883 2139 	strb.w	r2, [r3, #313]	; 0x139
     a8e:	4770      	bx	lr
     a90:	41008000 	.word	0x41008000

00000a94 <ETHERNET_MAC_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
     a94:	4b04      	ldr	r3, [pc, #16]	; (aa8 <ETHERNET_MAC_0_CLOCK_init+0x14>)
     a96:	691a      	ldr	r2, [r3, #16]
     a98:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
     a9c:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
     a9e:	69da      	ldr	r2, [r3, #28]
     aa0:	f042 0204 	orr.w	r2, r2, #4
     aa4:	61da      	str	r2, [r3, #28]
     aa6:	4770      	bx	lr
     aa8:	40000800 	.word	0x40000800

00000aac <ETHERNET_MAC_0_init>:
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
}

void ETHERNET_MAC_0_init(void)
{
     aac:	b508      	push	{r3, lr}
	ETHERNET_MAC_0_CLOCK_init();
     aae:	4b04      	ldr	r3, [pc, #16]	; (ac0 <ETHERNET_MAC_0_init+0x14>)
     ab0:	4798      	blx	r3
	mac_async_init(&ETHERNET_MAC_0, GMAC);
     ab2:	4904      	ldr	r1, [pc, #16]	; (ac4 <ETHERNET_MAC_0_init+0x18>)
     ab4:	4804      	ldr	r0, [pc, #16]	; (ac8 <ETHERNET_MAC_0_init+0x1c>)
     ab6:	4b05      	ldr	r3, [pc, #20]	; (acc <ETHERNET_MAC_0_init+0x20>)
     ab8:	4798      	blx	r3
	ETHERNET_MAC_0_PORT_init();
     aba:	4b05      	ldr	r3, [pc, #20]	; (ad0 <ETHERNET_MAC_0_init+0x24>)
     abc:	4798      	blx	r3
     abe:	bd08      	pop	{r3, pc}
     ac0:	00000a95 	.word	0x00000a95
     ac4:	42000800 	.word	0x42000800
     ac8:	2000e6d8 	.word	0x2000e6d8
     acc:	00001221 	.word	0x00001221
     ad0:	0000084d 	.word	0x0000084d

00000ad4 <system_init>:
	mac_async_enable(&ETHERNET_MAC_0);
	mac_async_write(&ETHERNET_MAC_0, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
     ad4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     ad8:	4baf      	ldr	r3, [pc, #700]	; (d98 <system_init+0x2c4>)
     ada:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     adc:	4caf      	ldr	r4, [pc, #700]	; (d9c <system_init+0x2c8>)
     ade:	2340      	movs	r3, #64	; 0x40
     ae0:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     ae4:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ae8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     aec:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
     af0:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
     af4:	48aa      	ldr	r0, [pc, #680]	; (da0 <system_init+0x2cc>)
     af6:	f8c4 0128 	str.w	r0, [r4, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     afa:	f894 3146 	ldrb.w	r3, [r4, #326]	; 0x146
	tmp &= ~PORT_PINCFG_PMUXEN;
     afe:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b02:	f884 3146 	strb.w	r3, [r4, #326]	; 0x146
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b06:	2308      	movs	r3, #8
     b08:	61a3      	str	r3, [r4, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b0a:	60a3      	str	r3, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b0c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     b10:	62a3      	str	r3, [r4, #40]	; 0x28
     b12:	f04f 4540 	mov.w	r5, #3221225472	; 0xc0000000
     b16:	62a5      	str	r5, [r4, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b18:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	tmp &= ~PORT_PINCFG_PMUXEN;
     b1c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b20:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b24:	2280      	movs	r2, #128	; 0x80
     b26:	61a2      	str	r2, [r4, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b28:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b2a:	4b9e      	ldr	r3, [pc, #632]	; (da4 <system_init+0x2d0>)
     b2c:	62a3      	str	r3, [r4, #40]	; 0x28
     b2e:	62a5      	str	r5, [r4, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b30:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
	tmp &= ~PORT_PINCFG_PMUXEN;
     b34:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b38:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b3c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
     b40:	61a3      	str	r3, [r4, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b42:	60a3      	str	r3, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b44:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     b48:	62a3      	str	r3, [r4, #40]	; 0x28
     b4a:	4997      	ldr	r1, [pc, #604]	; (da8 <system_init+0x2d4>)
     b4c:	62a1      	str	r1, [r4, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b4e:	f894 1056 	ldrb.w	r1, [r4, #86]	; 0x56
	tmp &= ~PORT_PINCFG_PMUXEN;
     b52:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b56:	f884 1056 	strb.w	r1, [r4, #86]	; 0x56
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b5a:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
     b5e:	61a1      	str	r1, [r4, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b60:	60a1      	str	r1, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b62:	62a3      	str	r3, [r4, #40]	; 0x28
     b64:	4f91      	ldr	r7, [pc, #580]	; (dac <system_init+0x2d8>)
     b66:	62a7      	str	r7, [r4, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b68:	f894 6057 	ldrb.w	r6, [r4, #87]	; 0x57
	tmp &= ~PORT_PINCFG_PMUXEN;
     b6c:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b70:	f884 6057 	strb.w	r6, [r4, #87]	; 0x57
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b74:	2610      	movs	r6, #16
     b76:	f8c4 6098 	str.w	r6, [r4, #152]	; 0x98
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b7a:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b7e:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
     b82:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
     b86:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b8a:	f894 60c4 	ldrb.w	r6, [r4, #196]	; 0xc4
	tmp &= ~PORT_PINCFG_PMUXEN;
     b8e:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b92:	f884 60c4 	strb.w	r6, [r4, #196]	; 0xc4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b96:	2620      	movs	r6, #32
     b98:	f8c4 6094 	str.w	r6, [r4, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b9c:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ba0:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
     ba4:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
     ba8:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bac:	f894 60c5 	ldrb.w	r6, [r4, #197]	; 0xc5
	tmp &= ~PORT_PINCFG_PMUXEN;
     bb0:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bb4:	f884 60c5 	strb.w	r6, [r4, #197]	; 0xc5
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     bb8:	f44f 4600 	mov.w	r6, #32768	; 0x8000
     bbc:	f8c4 6098 	str.w	r6, [r4, #152]	; 0x98
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     bc0:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bc4:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
     bc8:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
     bcc:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bd0:	f894 60cf 	ldrb.w	r6, [r4, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
     bd4:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bd8:	f884 60cf 	strb.w	r6, [r4, #207]	; 0xcf
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     bdc:	f8c4 1094 	str.w	r1, [r4, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     be0:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     be4:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
     be8:	f8c4 70a8 	str.w	r7, [r4, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bec:	f894 10d7 	ldrb.w	r1, [r4, #215]	; 0xd7
	tmp &= ~PORT_PINCFG_PMUXEN;
     bf0:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bf4:	f884 10d7 	strb.w	r1, [r4, #215]	; 0xd7
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     bf8:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bfc:	496c      	ldr	r1, [pc, #432]	; (db0 <system_init+0x2dc>)
     bfe:	f8c4 1128 	str.w	r1, [r4, #296]	; 0x128
     c02:	f8c4 0128 	str.w	r0, [r4, #296]	; 0x128
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     c06:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     c0a:	f894 1147 	ldrb.w	r1, [r4, #327]	; 0x147
     c0e:	f041 0104 	orr.w	r1, r1, #4
     c12:	f884 1147 	strb.w	r1, [r4, #327]	; 0x147
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c16:	f8c4 2118 	str.w	r2, [r4, #280]	; 0x118
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c1a:	f894 2147 	ldrb.w	r2, [r4, #327]	; 0x147
	tmp &= ~PORT_PINCFG_PMUXEN;
     c1e:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c22:	f884 2147 	strb.w	r2, [r4, #327]	; 0x147
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     c26:	f44f 5200 	mov.w	r2, #8192	; 0x2000
     c2a:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c2e:	4a61      	ldr	r2, [pc, #388]	; (db4 <system_init+0x2e0>)
     c30:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
     c34:	f8c4 0128 	str.w	r0, [r4, #296]	; 0x128
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     c38:	f894 214d 	ldrb.w	r2, [r4, #333]	; 0x14d
     c3c:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     c40:	f884 214d 	strb.w	r2, [r4, #333]	; 0x14d
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c44:	f894 214d 	ldrb.w	r2, [r4, #333]	; 0x14d
	tmp &= ~PORT_PINCFG_PMUXEN;
     c48:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c4c:	f884 214d 	strb.w	r2, [r4, #333]	; 0x14d
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c50:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
     c54:	f8c4 2118 	str.w	r2, [r4, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c58:	f8c4 2108 	str.w	r2, [r4, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c5c:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
     c60:	4a55      	ldr	r2, [pc, #340]	; (db8 <system_init+0x2e4>)
     c62:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c66:	f894 2158 	ldrb.w	r2, [r4, #344]	; 0x158
	tmp &= ~PORT_PINCFG_PMUXEN;
     c6a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c6e:	f884 2158 	strb.w	r2, [r4, #344]	; 0x158
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c72:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
     c76:	f8c4 2118 	str.w	r2, [r4, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c7a:	f8c4 2108 	str.w	r2, [r4, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c7e:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
     c82:	4b4e      	ldr	r3, [pc, #312]	; (dbc <system_init+0x2e8>)
     c84:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c88:	f894 315a 	ldrb.w	r3, [r4, #346]	; 0x15a
	tmp &= ~PORT_PINCFG_PMUXEN;
     c8c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c90:	f884 315a 	strb.w	r3, [r4, #346]	; 0x15a
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     c94:	2301      	movs	r3, #1
     c96:	f8c4 3194 	str.w	r3, [r4, #404]	; 0x194
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c9a:	f8c4 3188 	str.w	r3, [r4, #392]	; 0x188
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c9e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     ca2:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
     ca6:	f8c4 51a8 	str.w	r5, [r4, #424]	; 0x1a8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     caa:	f894 31c0 	ldrb.w	r3, [r4, #448]	; 0x1c0
	tmp &= ~PORT_PINCFG_PMUXEN;
     cae:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     cb2:	f884 31c0 	strb.w	r3, [r4, #448]	; 0x1c0
	// Set pin direction to output
	gpio_set_pin_direction(SSA0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(SSA0, GPIO_PIN_FUNCTION_OFF);

	FLASH_0_init();
     cb6:	4b42      	ldr	r3, [pc, #264]	; (dc0 <system_init+0x2ec>)
     cb8:	4798      	blx	r3

	SPI_0_init();
     cba:	4b42      	ldr	r3, [pc, #264]	; (dc4 <system_init+0x2f0>)
     cbc:	4798      	blx	r3

	ADC_0_init();
     cbe:	4b42      	ldr	r3, [pc, #264]	; (dc8 <system_init+0x2f4>)
     cc0:	4798      	blx	r3

	DAC_0_init();
     cc2:	4b42      	ldr	r3, [pc, #264]	; (dcc <system_init+0x2f8>)
     cc4:	4798      	blx	r3

	USART_0_init();
     cc6:	4b42      	ldr	r3, [pc, #264]	; (dd0 <system_init+0x2fc>)
     cc8:	4798      	blx	r3

	USART_1_init();
     cca:	4b42      	ldr	r3, [pc, #264]	; (dd4 <system_init+0x300>)
     ccc:	4798      	blx	r3

	stdio_redirect_init();
     cce:	4b42      	ldr	r3, [pc, #264]	; (dd8 <system_init+0x304>)
     cd0:	4798      	blx	r3

	total_pages = _flash_get_total_pages(&FLASH_0);//(&flash->dev);
     cd2:	4e42      	ldr	r6, [pc, #264]	; (ddc <system_init+0x308>)
     cd4:	4630      	mov	r0, r6
     cd6:	4b42      	ldr	r3, [pc, #264]	; (de0 <system_init+0x30c>)
     cd8:	4798      	blx	r3
     cda:	4607      	mov	r7, r0
	page_size = flash_get_page_size(&FLASH_0);
     cdc:	4630      	mov	r0, r6
     cde:	4b41      	ldr	r3, [pc, #260]	; (de4 <system_init+0x310>)
     ce0:	4798      	blx	r3
     ce2:	4681      	mov	r9, r0
	printf("Reading from flash...");
     ce4:	4840      	ldr	r0, [pc, #256]	; (de8 <system_init+0x314>)
     ce6:	f8df 8130 	ldr.w	r8, [pc, #304]	; e18 <system_init+0x344>
     cea:	47c0      	blx	r8
	flash_read(&FLASH_0, (total_pages-1)*page_size, src_data, page_size);
     cec:	1e79      	subs	r1, r7, #1
     cee:	464b      	mov	r3, r9
     cf0:	4a3e      	ldr	r2, [pc, #248]	; (dec <system_init+0x318>)
     cf2:	fb09 f101 	mul.w	r1, r9, r1
     cf6:	4630      	mov	r0, r6
     cf8:	4e3d      	ldr	r6, [pc, #244]	; (df0 <system_init+0x31c>)
     cfa:	47b0      	blx	r6
	printf("done\n\r");
     cfc:	483d      	ldr	r0, [pc, #244]	; (df4 <system_init+0x320>)
     cfe:	47c0      	blx	r8
        printf("0x%02X = 0x%02X\n\r", 0xEE, adc_read(curmodule, channum, 0xEE));
        printf("0x%02X = 0x%02X\n\r", 0xEF, adc_read(curmodule, channum, 0xEF));
        printf("0x%02X = 0x%02X\n\r", 0xEE, adc_read(curmodule, channum, 0xEE));
        printf("0x%02X = 0x%02X\n\r", 0xEF, adc_read(curmodule, channum, 0xEF));
*/
	TIMER_1_CLOCK_init();
     d00:	4b3d      	ldr	r3, [pc, #244]	; (df8 <system_init+0x324>)
     d02:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d04:	f44f 7380 	mov.w	r3, #256	; 0x100
     d08:	60a3      	str	r3, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d0a:	4a3c      	ldr	r2, [pc, #240]	; (dfc <system_init+0x328>)
     d0c:	62a2      	str	r2, [r4, #40]	; 0x28
     d0e:	62a5      	str	r5, [r4, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     d10:	6163      	str	r3, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     d12:	6063      	str	r3, [r4, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     d14:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
     d18:	f042 0204 	orr.w	r2, r2, #4
     d1c:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d20:	61a3      	str	r3, [r4, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d22:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
	tmp &= ~PORT_PINCFG_PMUXEN;
     d26:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     d2a:	f043 0301 	orr.w	r3, r3, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d2e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     d32:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     d36:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     d3a:	f043 0304 	orr.w	r3, r3, #4
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     d3e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d42:	f44f 7300 	mov.w	r3, #512	; 0x200
     d46:	60a3      	str	r3, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d48:	4a2d      	ldr	r2, [pc, #180]	; (e00 <system_init+0x32c>)
     d4a:	62a2      	str	r2, [r4, #40]	; 0x28
     d4c:	62a5      	str	r5, [r4, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     d4e:	6163      	str	r3, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     d50:	6063      	str	r3, [r4, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     d52:	f894 2049 	ldrb.w	r2, [r4, #73]	; 0x49
     d56:	f042 0204 	orr.w	r2, r2, #4
     d5a:	f884 2049 	strb.w	r2, [r4, #73]	; 0x49
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d5e:	61a3      	str	r3, [r4, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d60:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
	tmp &= ~PORT_PINCFG_PMUXEN;
     d64:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     d68:	f043 0301 	orr.w	r3, r3, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d6c:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     d70:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     d74:	f003 030f 	and.w	r3, r3, #15
	tmp |= PORT_PMUX_PMUXO(data);
     d78:	f043 0340 	orr.w	r3, r3, #64	; 0x40
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     d7c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	gpio_set_pin_direction(PA09, GPIO_DIRECTION_OUT);
	gpio_set_pin_level(PA09, false);
	gpio_set_pin_pull_mode(PA09, GPIO_PULL_UP);//GPIO_PULL_OFF);
	gpio_set_pin_function(PA09, GPIO_PIN_FUNCTION_E);

	TIMER_1_init();
     d80:	4b20      	ldr	r3, [pc, #128]	; (e04 <system_init+0x330>)
     d82:	4798      	blx	r3

	TIMER_0_CLOCK_init();
     d84:	4b20      	ldr	r3, [pc, #128]	; (e08 <system_init+0x334>)
     d86:	4798      	blx	r3

	TIMER_0_init();
     d88:	4b20      	ldr	r3, [pc, #128]	; (e0c <system_init+0x338>)
     d8a:	4798      	blx	r3

	USB_0_init();
     d8c:	4b20      	ldr	r3, [pc, #128]	; (e10 <system_init+0x33c>)
     d8e:	4798      	blx	r3

	ETHERNET_MAC_0_init();
     d90:	4b20      	ldr	r3, [pc, #128]	; (e14 <system_init+0x340>)
     d92:	4798      	blx	r3
     d94:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     d98:	00001d39 	.word	0x00001d39
     d9c:	41008000 	.word	0x41008000
     da0:	c0020000 	.word	0xc0020000
     da4:	40000080 	.word	0x40000080
     da8:	c0000040 	.word	0xc0000040
     dac:	c0000080 	.word	0xc0000080
     db0:	40020080 	.word	0x40020080
     db4:	40022000 	.word	0x40022000
     db8:	c0000100 	.word	0xc0000100
     dbc:	c0000400 	.word	0xc0000400
     dc0:	00000391 	.word	0x00000391
     dc4:	00000481 	.word	0x00000481
     dc8:	00000505 	.word	0x00000505
     dcc:	000005b1 	.word	0x000005b1
     dd0:	00000645 	.word	0x00000645
     dd4:	00000711 	.word	0x00000711
     dd8:	00003f69 	.word	0x00003f69
     ddc:	2000e508 	.word	0x2000e508
     de0:	000022b7 	.word	0x000022b7
     de4:	00001199 	.word	0x00001199
     de8:	00006d08 	.word	0x00006d08
     dec:	2000009c 	.word	0x2000009c
     df0:	000010f5 	.word	0x000010f5
     df4:	00006d20 	.word	0x00006d20
     df8:	000007e9 	.word	0x000007e9
     dfc:	40000100 	.word	0x40000100
     e00:	40000200 	.word	0x40000200
     e04:	00002d79 	.word	0x00002d79
     e08:	0000080d 	.word	0x0000080d
     e0c:	00002e29 	.word	0x00002e29
     e10:	00000831 	.word	0x00000831
     e14:	00000aad 	.word	0x00000aad
     e18:	00005ced 	.word	0x00005ced

00000e1c <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
     e1c:	b570      	push	{r4, r5, r6, lr}
     e1e:	460d      	mov	r5, r1
     e20:	4616      	mov	r6, r2
	ASSERT(descr && mac && (addr <= 0x1F));
     e22:	4604      	mov	r4, r0
     e24:	b160      	cbz	r0, e40 <ethernet_phy_init+0x24>
     e26:	b169      	cbz	r1, e44 <ethernet_phy_init+0x28>
     e28:	2a1f      	cmp	r2, #31
     e2a:	bf8c      	ite	hi
     e2c:	2000      	movhi	r0, #0
     e2e:	2001      	movls	r0, #1
     e30:	222a      	movs	r2, #42	; 0x2a
     e32:	4905      	ldr	r1, [pc, #20]	; (e48 <ethernet_phy_init+0x2c>)
     e34:	4b05      	ldr	r3, [pc, #20]	; (e4c <ethernet_phy_init+0x30>)
     e36:	4798      	blx	r3

	descr->mac  = mac;
     e38:	6025      	str	r5, [r4, #0]
	descr->addr = addr;
     e3a:	80a6      	strh	r6, [r4, #4]
	return ERR_NONE;
}
     e3c:	2000      	movs	r0, #0
     e3e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && mac && (addr <= 0x1F));
     e40:	2000      	movs	r0, #0
     e42:	e7f5      	b.n	e30 <ethernet_phy_init+0x14>
     e44:	2000      	movs	r0, #0
     e46:	e7f3      	b.n	e30 <ethernet_phy_init+0x14>
     e48:	00006d28 	.word	0x00006d28
     e4c:	000019fd 	.word	0x000019fd

00000e50 <ETHERNET_PHY_0_init>:
#include <ethernet_phy_main.h>

struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
     e50:	b510      	push	{r4, lr}
	mac_async_enable(&ETHERNET_MAC_0);
     e52:	4c05      	ldr	r4, [pc, #20]	; (e68 <ETHERNET_PHY_0_init+0x18>)
     e54:	4620      	mov	r0, r4
     e56:	4b05      	ldr	r3, [pc, #20]	; (e6c <ETHERNET_PHY_0_init+0x1c>)
     e58:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &ETHERNET_MAC_0, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
     e5a:	2201      	movs	r2, #1
     e5c:	4621      	mov	r1, r4
     e5e:	4804      	ldr	r0, [pc, #16]	; (e70 <ETHERNET_PHY_0_init+0x20>)
     e60:	4b04      	ldr	r3, [pc, #16]	; (e74 <ETHERNET_PHY_0_init+0x24>)
     e62:	4798      	blx	r3
     e64:	bd10      	pop	{r4, pc}
     e66:	bf00      	nop
     e68:	2000e6d8 	.word	0x2000e6d8
     e6c:	00001251 	.word	0x00001251
     e70:	2000e500 	.word	0x2000e500
     e74:	00000e1d 	.word	0x00000e1d

00000e78 <ethernet_phys_init>:
		rst = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_state);
	} while (rst == ERR_NONE && link_state == true);
}

void ethernet_phys_init(void)
{
     e78:	b508      	push	{r3, lr}

	ETHERNET_PHY_0_init();
     e7a:	4b01      	ldr	r3, [pc, #4]	; (e80 <ethernet_phys_init+0x8>)
     e7c:	4798      	blx	r3
     e7e:	bd08      	pop	{r3, pc}
     e80:	00000e51 	.word	0x00000e51

00000e84 <adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t adc_sync_init(struct adc_sync_descriptor *const descr, void *const hw, void *const func)
{
     e84:	b538      	push	{r3, r4, r5, lr}
     e86:	460c      	mov	r4, r1
	ASSERT(descr && hw);
     e88:	4605      	mov	r5, r0
     e8a:	b158      	cbz	r0, ea4 <adc_sync_init+0x20>
     e8c:	1c08      	adds	r0, r1, #0
     e8e:	bf18      	it	ne
     e90:	2001      	movne	r0, #1
     e92:	2239      	movs	r2, #57	; 0x39
     e94:	4904      	ldr	r1, [pc, #16]	; (ea8 <adc_sync_init+0x24>)
     e96:	4b05      	ldr	r3, [pc, #20]	; (eac <adc_sync_init+0x28>)
     e98:	4798      	blx	r3

	return _adc_sync_init(&descr->device, hw);
     e9a:	4621      	mov	r1, r4
     e9c:	4628      	mov	r0, r5
     e9e:	4b04      	ldr	r3, [pc, #16]	; (eb0 <adc_sync_init+0x2c>)
     ea0:	4798      	blx	r3
}
     ea2:	bd38      	pop	{r3, r4, r5, pc}
     ea4:	2000      	movs	r0, #0
     ea6:	e7f4      	b.n	e92 <adc_sync_init+0xe>
     ea8:	00006d48 	.word	0x00006d48
     eac:	000019fd 	.word	0x000019fd
     eb0:	00001cad 	.word	0x00001cad

00000eb4 <adc_sync_enable_channel>:

/**
 * \brief Enable ADC
 */
int32_t adc_sync_enable_channel(struct adc_sync_descriptor *const descr, const uint8_t channel)
{
     eb4:	b538      	push	{r3, r4, r5, lr}
     eb6:	460d      	mov	r5, r1
	ASSERT(descr);
     eb8:	4604      	mov	r4, r0
     eba:	224e      	movs	r2, #78	; 0x4e
     ebc:	4905      	ldr	r1, [pc, #20]	; (ed4 <adc_sync_enable_channel+0x20>)
     ebe:	3000      	adds	r0, #0
     ec0:	bf18      	it	ne
     ec2:	2001      	movne	r0, #1
     ec4:	4b04      	ldr	r3, [pc, #16]	; (ed8 <adc_sync_enable_channel+0x24>)
     ec6:	4798      	blx	r3
	_adc_sync_enable_channel(&descr->device, channel);
     ec8:	4629      	mov	r1, r5
     eca:	4620      	mov	r0, r4
     ecc:	4b03      	ldr	r3, [pc, #12]	; (edc <adc_sync_enable_channel+0x28>)
     ece:	4798      	blx	r3

	return ERR_NONE;
}
     ed0:	2000      	movs	r0, #0
     ed2:	bd38      	pop	{r3, r4, r5, pc}
     ed4:	00006d48 	.word	0x00006d48
     ed8:	000019fd 	.word	0x000019fd
     edc:	00001ce5 	.word	0x00001ce5

00000ee0 <adc_sync_read_channel>:
/*
 * \brief Read data from ADC
 */
int32_t adc_sync_read_channel(struct adc_sync_descriptor *const descr, const uint8_t channel, uint8_t *const buffer,
                              const uint16_t length)
{
     ee0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
     ee4:	460d      	mov	r5, r1
     ee6:	4691      	mov	r9, r2
     ee8:	469a      	mov	sl, r3
	uint8_t  data_size;
	uint16_t offset = 0;

	ASSERT(descr && buffer && length);
     eea:	4680      	mov	r8, r0
     eec:	b1e0      	cbz	r0, f28 <adc_sync_read_channel+0x48>
     eee:	b1ea      	cbz	r2, f2c <adc_sync_read_channel+0x4c>
     ef0:	1c18      	adds	r0, r3, #0
     ef2:	bf18      	it	ne
     ef4:	2001      	movne	r0, #1
     ef6:	4f1c      	ldr	r7, [pc, #112]	; (f68 <adc_sync_read_channel+0x88>)
     ef8:	2267      	movs	r2, #103	; 0x67
     efa:	4639      	mov	r1, r7
     efc:	4e1b      	ldr	r6, [pc, #108]	; (f6c <adc_sync_read_channel+0x8c>)
     efe:	47b0      	blx	r6
	data_size = _adc_sync_get_data_size(&descr->device);
     f00:	4644      	mov	r4, r8
     f02:	4640      	mov	r0, r8
     f04:	4b1a      	ldr	r3, [pc, #104]	; (f70 <adc_sync_read_channel+0x90>)
     f06:	4798      	blx	r3
     f08:	4680      	mov	r8, r0
	ASSERT(!(length % data_size));
     f0a:	fb9a f0f0 	sdiv	r0, sl, r0
     f0e:	fb08 a010 	mls	r0, r8, r0, sl
     f12:	2269      	movs	r2, #105	; 0x69
     f14:	4639      	mov	r1, r7
     f16:	fab0 f080 	clz	r0, r0
     f1a:	0940      	lsrs	r0, r0, #5
     f1c:	47b0      	blx	r6
	uint16_t offset = 0;
     f1e:	2700      	movs	r7, #0

	do {
		uint16_t result;
		_adc_sync_convert(&descr->device);
     f20:	f8df b058 	ldr.w	fp, [pc, #88]	; f7c <adc_sync_read_channel+0x9c>

		while (!_adc_sync_is_channel_conversion_done(&descr->device, channel))
     f24:	4e13      	ldr	r6, [pc, #76]	; (f74 <adc_sync_read_channel+0x94>)
     f26:	e007      	b.n	f38 <adc_sync_read_channel+0x58>
	ASSERT(descr && buffer && length);
     f28:	2000      	movs	r0, #0
     f2a:	e7e4      	b.n	ef6 <adc_sync_read_channel+0x16>
     f2c:	2000      	movs	r0, #0
     f2e:	e7e2      	b.n	ef6 <adc_sync_read_channel+0x16>
     f30:	4447      	add	r7, r8
     f32:	b2bf      	uxth	r7, r7
		buffer[offset] = result;
		if (1 < data_size) {
			buffer[offset + 1] = result >> 8;
		}
		offset += data_size;
	} while (offset < length);
     f34:	45ba      	cmp	sl, r7
     f36:	d914      	bls.n	f62 <adc_sync_read_channel+0x82>
		_adc_sync_convert(&descr->device);
     f38:	4620      	mov	r0, r4
     f3a:	47d8      	blx	fp
		while (!_adc_sync_is_channel_conversion_done(&descr->device, channel))
     f3c:	4629      	mov	r1, r5
     f3e:	4620      	mov	r0, r4
     f40:	47b0      	blx	r6
     f42:	2800      	cmp	r0, #0
     f44:	d0fa      	beq.n	f3c <adc_sync_read_channel+0x5c>
		result         = _adc_sync_read_channel_data(&descr->device, channel);
     f46:	4629      	mov	r1, r5
     f48:	4620      	mov	r0, r4
     f4a:	4b0b      	ldr	r3, [pc, #44]	; (f78 <adc_sync_read_channel+0x98>)
     f4c:	4798      	blx	r3
		buffer[offset] = result;
     f4e:	f809 0007 	strb.w	r0, [r9, r7]
		if (1 < data_size) {
     f52:	f1b8 0f01 	cmp.w	r8, #1
     f56:	d9eb      	bls.n	f30 <adc_sync_read_channel+0x50>
			buffer[offset + 1] = result >> 8;
     f58:	eb09 0307 	add.w	r3, r9, r7
     f5c:	0a00      	lsrs	r0, r0, #8
     f5e:	7058      	strb	r0, [r3, #1]
     f60:	e7e6      	b.n	f30 <adc_sync_read_channel+0x50>

	return offset;
}
     f62:	4638      	mov	r0, r7
     f64:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
     f68:	00006d48 	.word	0x00006d48
     f6c:	000019fd 	.word	0x000019fd
     f70:	00001cfb 	.word	0x00001cfb
     f74:	00001d0d 	.word	0x00001d0d
     f78:	00001d2f 	.word	0x00001d2f
     f7c:	00001d19 	.word	0x00001d19

00000f80 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     f80:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     f84:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     f86:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     f88:	f3bf 8f5f 	dmb	sy
     f8c:	4770      	bx	lr

00000f8e <atomic_leave_critical>:
     f8e:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     f92:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     f94:	f383 8810 	msr	PRIMASK, r3
     f98:	4770      	bx	lr
	...

00000f9c <dac_sync_init>:

/**
 * \brief Initialize the DAC HAL instance and hardware.
 */
int32_t dac_sync_init(struct dac_sync_descriptor *const descr, void *const hw)
{
     f9c:	b538      	push	{r3, r4, r5, lr}
     f9e:	460d      	mov	r5, r1
	uint8_t i;
	int32_t rc;

	ASSERT(descr && hw);
     fa0:	4604      	mov	r4, r0
     fa2:	b198      	cbz	r0, fcc <dac_sync_init+0x30>
     fa4:	1c08      	adds	r0, r1, #0
     fa6:	bf18      	it	ne
     fa8:	2001      	movne	r0, #1
     faa:	2232      	movs	r2, #50	; 0x32
     fac:	4908      	ldr	r1, [pc, #32]	; (fd0 <dac_sync_init+0x34>)
     fae:	4b09      	ldr	r3, [pc, #36]	; (fd4 <dac_sync_init+0x38>)
     fb0:	4798      	blx	r3

	rc = _dac_sync_init(&descr->device, hw);
     fb2:	4629      	mov	r1, r5
     fb4:	4620      	mov	r0, r4
     fb6:	4b08      	ldr	r3, [pc, #32]	; (fd8 <dac_sync_init+0x3c>)
     fb8:	4798      	blx	r3
	if (rc) {
     fba:	4602      	mov	r2, r0
     fbc:	b920      	cbnz	r0, fc8 <dac_sync_init+0x2c>
		return rc;
	}

	for (i = 0; i < CHANNEL_NUM; i++) {
		descr->sel_ch[i].buffer = NULL;
     fbe:	2300      	movs	r3, #0
     fc0:	6063      	str	r3, [r4, #4]
		descr->sel_ch[i].length = 0;
     fc2:	60a3      	str	r3, [r4, #8]
		descr->sel_ch[i].buffer = NULL;
     fc4:	60e3      	str	r3, [r4, #12]
		descr->sel_ch[i].length = 0;
     fc6:	6123      	str	r3, [r4, #16]
	}

	return ERR_NONE;
}
     fc8:	4610      	mov	r0, r2
     fca:	bd38      	pop	{r3, r4, r5, pc}
     fcc:	2000      	movs	r0, #0
     fce:	e7ec      	b.n	faa <dac_sync_init+0xe>
     fd0:	00006d64 	.word	0x00006d64
     fd4:	000019fd 	.word	0x000019fd
     fd8:	00001e1d 	.word	0x00001e1d

00000fdc <dac_sync_enable_channel>:

/**
 * \brief Enable DAC channel
 */
int32_t dac_sync_enable_channel(struct dac_sync_descriptor *const descr, const uint8_t ch)
{
     fdc:	b538      	push	{r3, r4, r5, lr}
     fde:	460c      	mov	r4, r1
	ASSERT(descr && (ch < CHANNEL_NUM));
     fe0:	4605      	mov	r5, r0
     fe2:	b168      	cbz	r0, 1000 <dac_sync_enable_channel+0x24>
     fe4:	2901      	cmp	r1, #1
     fe6:	bf8c      	ite	hi
     fe8:	2000      	movhi	r0, #0
     fea:	2001      	movls	r0, #1
     fec:	2252      	movs	r2, #82	; 0x52
     fee:	4905      	ldr	r1, [pc, #20]	; (1004 <dac_sync_enable_channel+0x28>)
     ff0:	4b05      	ldr	r3, [pc, #20]	; (1008 <dac_sync_enable_channel+0x2c>)
     ff2:	4798      	blx	r3

	_dac_sync_enable_channel(&descr->device, ch);
     ff4:	4621      	mov	r1, r4
     ff6:	4628      	mov	r0, r5
     ff8:	4b04      	ldr	r3, [pc, #16]	; (100c <dac_sync_enable_channel+0x30>)
     ffa:	4798      	blx	r3

	return ERR_NONE;
}
     ffc:	2000      	movs	r0, #0
     ffe:	bd38      	pop	{r3, r4, r5, pc}
    1000:	2000      	movs	r0, #0
    1002:	e7f3      	b.n	fec <dac_sync_enable_channel+0x10>
    1004:	00006d64 	.word	0x00006d64
    1008:	000019fd 	.word	0x000019fd
    100c:	00001e49 	.word	0x00001e49

00001010 <dac_sync_write>:

/**
 * \brief DAC convert digital data to analog output
 */
int32_t dac_sync_write(struct dac_sync_descriptor *descr, const uint8_t ch, uint16_t *buffer, uint32_t length)
{
    1010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1014:	460d      	mov	r5, r1
    1016:	4690      	mov	r8, r2
    1018:	461f      	mov	r7, r3
	ASSERT(descr && (ch < CHANNEL_NUM) && buffer && length);
    101a:	4604      	mov	r4, r0
    101c:	b340      	cbz	r0, 1070 <dac_sync_write+0x60>
    101e:	2901      	cmp	r1, #1
    1020:	d921      	bls.n	1066 <dac_sync_write+0x56>
    1022:	2000      	movs	r0, #0
    1024:	226a      	movs	r2, #106	; 0x6a
    1026:	4918      	ldr	r1, [pc, #96]	; (1088 <dac_sync_write+0x78>)
    1028:	4b18      	ldr	r3, [pc, #96]	; (108c <dac_sync_write+0x7c>)
    102a:	4798      	blx	r3

	/* check whether channel is enable */
	if (!_dac_sync_is_channel_enable(&descr->device, ch)) {
    102c:	4626      	mov	r6, r4
    102e:	4629      	mov	r1, r5
    1030:	4620      	mov	r0, r4
    1032:	4b17      	ldr	r3, [pc, #92]	; (1090 <dac_sync_write+0x80>)
    1034:	4798      	blx	r3
    1036:	b1f8      	cbz	r0, 1078 <dac_sync_write+0x68>
    1038:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
		return ERR_NOT_READY;
	}

	descr->sel_ch[ch].buffer = buffer;
    103c:	f8c4 8004 	str.w	r8, [r4, #4]
	descr->sel_ch[ch].length = length;
    1040:	60a7      	str	r7, [r4, #8]

	while (descr->sel_ch[ch].length) {
    1042:	b1ef      	cbz	r7, 1080 <dac_sync_write+0x70>
		_dac_sync_write_data(&descr->device, *(descr->sel_ch[ch].buffer), ch);
    1044:	4f13      	ldr	r7, [pc, #76]	; (1094 <dac_sync_write+0x84>)
    1046:	6863      	ldr	r3, [r4, #4]
    1048:	462a      	mov	r2, r5
    104a:	8819      	ldrh	r1, [r3, #0]
    104c:	4630      	mov	r0, r6
    104e:	47b8      	blx	r7
		descr->sel_ch[ch].buffer++;
    1050:	6863      	ldr	r3, [r4, #4]
    1052:	3302      	adds	r3, #2
    1054:	6063      	str	r3, [r4, #4]
		descr->sel_ch[ch].length--;
    1056:	68a3      	ldr	r3, [r4, #8]
    1058:	3b01      	subs	r3, #1
    105a:	60a3      	str	r3, [r4, #8]
	while (descr->sel_ch[ch].length) {
    105c:	2b00      	cmp	r3, #0
    105e:	d1f2      	bne.n	1046 <dac_sync_write+0x36>
	}

	return ERR_NONE;
    1060:	2000      	movs	r0, #0
    1062:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(descr && (ch < CHANNEL_NUM) && buffer && length);
    1066:	b12a      	cbz	r2, 1074 <dac_sync_write+0x64>
    1068:	1c18      	adds	r0, r3, #0
    106a:	bf18      	it	ne
    106c:	2001      	movne	r0, #1
    106e:	e7d9      	b.n	1024 <dac_sync_write+0x14>
    1070:	2000      	movs	r0, #0
    1072:	e7d7      	b.n	1024 <dac_sync_write+0x14>
    1074:	2000      	movs	r0, #0
    1076:	e7d5      	b.n	1024 <dac_sync_write+0x14>
		return ERR_NOT_READY;
    1078:	f06f 001c 	mvn.w	r0, #28
    107c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return ERR_NONE;
    1080:	2000      	movs	r0, #0
}
    1082:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1086:	bf00      	nop
    1088:	00006d64 	.word	0x00006d64
    108c:	000019fd 	.word	0x000019fd
    1090:	00001eb5 	.word	0x00001eb5
    1094:	00001ed5 	.word	0x00001ed5

00001098 <flash_ready>:
 * \internal Ready for a new flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
    1098:	b508      	push	{r3, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    109a:	6943      	ldr	r3, [r0, #20]
    109c:	b103      	cbz	r3, 10a0 <flash_ready+0x8>
		descr->callbacks.cb_ready(descr);
    109e:	4798      	blx	r3
    10a0:	bd08      	pop	{r3, pc}

000010a2 <flash_error>:
 * \internal Error occurs in flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
    10a2:	b508      	push	{r3, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    10a4:	6983      	ldr	r3, [r0, #24]
    10a6:	b103      	cbz	r3, 10aa <flash_error+0x8>
		descr->callbacks.cb_error(descr);
    10a8:	4798      	blx	r3
    10aa:	bd08      	pop	{r3, pc}

000010ac <flash_init>:
{
    10ac:	b538      	push	{r3, r4, r5, lr}
    10ae:	460d      	mov	r5, r1
	ASSERT(flash && hw);
    10b0:	4604      	mov	r4, r0
    10b2:	b190      	cbz	r0, 10da <flash_init+0x2e>
    10b4:	1c08      	adds	r0, r1, #0
    10b6:	bf18      	it	ne
    10b8:	2001      	movne	r0, #1
    10ba:	2238      	movs	r2, #56	; 0x38
    10bc:	4908      	ldr	r1, [pc, #32]	; (10e0 <flash_init+0x34>)
    10be:	4b09      	ldr	r3, [pc, #36]	; (10e4 <flash_init+0x38>)
    10c0:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    10c2:	4629      	mov	r1, r5
    10c4:	4620      	mov	r0, r4
    10c6:	4b08      	ldr	r3, [pc, #32]	; (10e8 <flash_init+0x3c>)
    10c8:	4798      	blx	r3
	if (rc) {
    10ca:	4603      	mov	r3, r0
    10cc:	b918      	cbnz	r0, 10d6 <flash_init+0x2a>
	flash->dev.flash_cb.ready_cb = flash_ready;
    10ce:	4a07      	ldr	r2, [pc, #28]	; (10ec <flash_init+0x40>)
    10d0:	6022      	str	r2, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    10d2:	4a07      	ldr	r2, [pc, #28]	; (10f0 <flash_init+0x44>)
    10d4:	6062      	str	r2, [r4, #4]
}
    10d6:	4618      	mov	r0, r3
    10d8:	bd38      	pop	{r3, r4, r5, pc}
    10da:	2000      	movs	r0, #0
    10dc:	e7ed      	b.n	10ba <flash_init+0xe>
    10de:	bf00      	nop
    10e0:	00006d80 	.word	0x00006d80
    10e4:	000019fd 	.word	0x000019fd
    10e8:	00002239 	.word	0x00002239
    10ec:	00001099 	.word	0x00001099
    10f0:	000010a3 	.word	0x000010a3

000010f4 <flash_read>:
{
    10f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    10f8:	460d      	mov	r5, r1
    10fa:	4690      	mov	r8, r2
    10fc:	461e      	mov	r6, r3
	ASSERT(flash && buffer && length);
    10fe:	4604      	mov	r4, r0
    1100:	b1f0      	cbz	r0, 1140 <flash_read+0x4c>
    1102:	b1fa      	cbz	r2, 1144 <flash_read+0x50>
    1104:	b343      	cbz	r3, 1158 <flash_read+0x64>
    1106:	2001      	movs	r0, #1
    1108:	2256      	movs	r2, #86	; 0x56
    110a:	491e      	ldr	r1, [pc, #120]	; (1184 <flash_read+0x90>)
    110c:	4b1e      	ldr	r3, [pc, #120]	; (1188 <flash_read+0x94>)
    110e:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    1110:	46a1      	mov	r9, r4
    1112:	4620      	mov	r0, r4
    1114:	4b1d      	ldr	r3, [pc, #116]	; (118c <flash_read+0x98>)
    1116:	4798      	blx	r3
    1118:	4607      	mov	r7, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    111a:	4620      	mov	r0, r4
    111c:	4b1c      	ldr	r3, [pc, #112]	; (1190 <flash_read+0x9c>)
    111e:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    1120:	fb00 f007 	mul.w	r0, r0, r7
    1124:	42a8      	cmp	r0, r5
    1126:	d30f      	bcc.n	1148 <flash_read+0x54>
    1128:	1973      	adds	r3, r6, r5
    112a:	4298      	cmp	r0, r3
    112c:	d310      	bcc.n	1150 <flash_read+0x5c>
	_flash_read(&flash->dev, src_addr, buffer, length);
    112e:	4633      	mov	r3, r6
    1130:	4642      	mov	r2, r8
    1132:	4629      	mov	r1, r5
    1134:	4648      	mov	r0, r9
    1136:	4c17      	ldr	r4, [pc, #92]	; (1194 <flash_read+0xa0>)
    1138:	47a0      	blx	r4
	return ERR_NONE;
    113a:	2000      	movs	r0, #0
    113c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(flash && buffer && length);
    1140:	2000      	movs	r0, #0
    1142:	e7e1      	b.n	1108 <flash_read+0x14>
    1144:	2000      	movs	r0, #0
    1146:	e7df      	b.n	1108 <flash_read+0x14>
		return ERR_BAD_ADDRESS;
    1148:	f06f 000d 	mvn.w	r0, #13
    114c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    1150:	f06f 000d 	mvn.w	r0, #13
    1154:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(flash && buffer && length);
    1158:	2256      	movs	r2, #86	; 0x56
    115a:	490a      	ldr	r1, [pc, #40]	; (1184 <flash_read+0x90>)
    115c:	2000      	movs	r0, #0
    115e:	4b0a      	ldr	r3, [pc, #40]	; (1188 <flash_read+0x94>)
    1160:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    1162:	46a1      	mov	r9, r4
    1164:	4620      	mov	r0, r4
    1166:	4b09      	ldr	r3, [pc, #36]	; (118c <flash_read+0x98>)
    1168:	4798      	blx	r3
    116a:	4607      	mov	r7, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    116c:	4620      	mov	r0, r4
    116e:	4b08      	ldr	r3, [pc, #32]	; (1190 <flash_read+0x9c>)
    1170:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    1172:	fb00 f007 	mul.w	r0, r0, r7
    1176:	4285      	cmp	r5, r0
    1178:	d9d9      	bls.n	112e <flash_read+0x3a>
		return ERR_BAD_ADDRESS;
    117a:	f06f 000d 	mvn.w	r0, #13
    117e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    1182:	bf00      	nop
    1184:	00006d80 	.word	0x00006d80
    1188:	000019fd 	.word	0x000019fd
    118c:	000022b1 	.word	0x000022b1
    1190:	000022b7 	.word	0x000022b7
    1194:	000022bf 	.word	0x000022bf

00001198 <flash_get_page_size>:
{
    1198:	b510      	push	{r4, lr}
	ASSERT(flash);
    119a:	4604      	mov	r4, r0
    119c:	22f7      	movs	r2, #247	; 0xf7
    119e:	4905      	ldr	r1, [pc, #20]	; (11b4 <flash_get_page_size+0x1c>)
    11a0:	3000      	adds	r0, #0
    11a2:	bf18      	it	ne
    11a4:	2001      	movne	r0, #1
    11a6:	4b04      	ldr	r3, [pc, #16]	; (11b8 <flash_get_page_size+0x20>)
    11a8:	4798      	blx	r3
	return _flash_get_page_size(&flash->dev);
    11aa:	4620      	mov	r0, r4
    11ac:	4b03      	ldr	r3, [pc, #12]	; (11bc <flash_get_page_size+0x24>)
    11ae:	4798      	blx	r3
}
    11b0:	bd10      	pop	{r4, pc}
    11b2:	bf00      	nop
    11b4:	00006d80 	.word	0x00006d80
    11b8:	000019fd 	.word	0x000019fd
    11bc:	000022b1 	.word	0x000022b1

000011c0 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    11c0:	b570      	push	{r4, r5, r6, lr}
    11c2:	460d      	mov	r5, r1
    11c4:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    11c6:	4604      	mov	r4, r0
    11c8:	b160      	cbz	r0, 11e4 <io_write+0x24>
    11ca:	1c08      	adds	r0, r1, #0
    11cc:	bf18      	it	ne
    11ce:	2001      	movne	r0, #1
    11d0:	2234      	movs	r2, #52	; 0x34
    11d2:	4905      	ldr	r1, [pc, #20]	; (11e8 <io_write+0x28>)
    11d4:	4b05      	ldr	r3, [pc, #20]	; (11ec <io_write+0x2c>)
    11d6:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    11d8:	6823      	ldr	r3, [r4, #0]
    11da:	4632      	mov	r2, r6
    11dc:	4629      	mov	r1, r5
    11de:	4620      	mov	r0, r4
    11e0:	4798      	blx	r3
}
    11e2:	bd70      	pop	{r4, r5, r6, pc}
    11e4:	2000      	movs	r0, #0
    11e6:	e7f3      	b.n	11d0 <io_write+0x10>
    11e8:	00006d98 	.word	0x00006d98
    11ec:	000019fd 	.word	0x000019fd

000011f0 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    11f0:	b570      	push	{r4, r5, r6, lr}
    11f2:	460d      	mov	r5, r1
    11f4:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    11f6:	4604      	mov	r4, r0
    11f8:	b160      	cbz	r0, 1214 <io_read+0x24>
    11fa:	1c08      	adds	r0, r1, #0
    11fc:	bf18      	it	ne
    11fe:	2001      	movne	r0, #1
    1200:	223d      	movs	r2, #61	; 0x3d
    1202:	4905      	ldr	r1, [pc, #20]	; (1218 <io_read+0x28>)
    1204:	4b05      	ldr	r3, [pc, #20]	; (121c <io_read+0x2c>)
    1206:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    1208:	6863      	ldr	r3, [r4, #4]
    120a:	4632      	mov	r2, r6
    120c:	4629      	mov	r1, r5
    120e:	4620      	mov	r0, r4
    1210:	4798      	blx	r3
}
    1212:	bd70      	pop	{r4, r5, r6, pc}
    1214:	2000      	movs	r0, #0
    1216:	e7f3      	b.n	1200 <io_read+0x10>
    1218:	00006d98 	.word	0x00006d98
    121c:	000019fd 	.word	0x000019fd

00001220 <mac_async_init>:

/**
 * \brief Initialize the MAC driver
 */
int32_t mac_async_init(struct mac_async_descriptor *const descr, void *const hw)
{
    1220:	b538      	push	{r3, r4, r5, lr}
    1222:	460c      	mov	r4, r1
	ASSERT(descr && hw);
    1224:	4605      	mov	r5, r0
    1226:	b158      	cbz	r0, 1240 <mac_async_init+0x20>
    1228:	1c08      	adds	r0, r1, #0
    122a:	bf18      	it	ne
    122c:	2001      	movne	r0, #1
    122e:	2231      	movs	r2, #49	; 0x31
    1230:	4904      	ldr	r1, [pc, #16]	; (1244 <mac_async_init+0x24>)
    1232:	4b05      	ldr	r3, [pc, #20]	; (1248 <mac_async_init+0x28>)
    1234:	4798      	blx	r3

	return _mac_async_init(&descr->dev, hw);
    1236:	4621      	mov	r1, r4
    1238:	4628      	mov	r0, r5
    123a:	4b04      	ldr	r3, [pc, #16]	; (124c <mac_async_init+0x2c>)
    123c:	4798      	blx	r3
}
    123e:	bd38      	pop	{r3, r4, r5, pc}
    1240:	2000      	movs	r0, #0
    1242:	e7f4      	b.n	122e <mac_async_init+0xe>
    1244:	00006dac 	.word	0x00006dac
    1248:	000019fd 	.word	0x000019fd
    124c:	0000212d 	.word	0x0000212d

00001250 <mac_async_enable>:

/**
 * \brief Enable the MAC
 */
int32_t mac_async_enable(struct mac_async_descriptor *const descr)
{
    1250:	b510      	push	{r4, lr}
	ASSERT(descr);
    1252:	4604      	mov	r4, r0
    1254:	2245      	movs	r2, #69	; 0x45
    1256:	4905      	ldr	r1, [pc, #20]	; (126c <mac_async_enable+0x1c>)
    1258:	3000      	adds	r0, #0
    125a:	bf18      	it	ne
    125c:	2001      	movne	r0, #1
    125e:	4b04      	ldr	r3, [pc, #16]	; (1270 <mac_async_enable+0x20>)
    1260:	4798      	blx	r3

	return _mac_async_enable(&descr->dev);
    1262:	4620      	mov	r0, r4
    1264:	4b03      	ldr	r3, [pc, #12]	; (1274 <mac_async_enable+0x24>)
    1266:	4798      	blx	r3
}
    1268:	bd10      	pop	{r4, pc}
    126a:	bf00      	nop
    126c:	00006dac 	.word	0x00006dac
    1270:	000019fd 	.word	0x000019fd
    1274:	000021f1 	.word	0x000021f1

00001278 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    1278:	b538      	push	{r3, r4, r5, lr}
    127a:	460d      	mov	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
    127c:	4604      	mov	r4, r0
    127e:	b1b8      	cbz	r0, 12b0 <spi_m_sync_init+0x38>
    1280:	1c08      	adds	r0, r1, #0
    1282:	bf18      	it	ne
    1284:	2001      	movne	r0, #1
    1286:	2240      	movs	r2, #64	; 0x40
    1288:	490a      	ldr	r1, [pc, #40]	; (12b4 <spi_m_sync_init+0x3c>)
    128a:	4b0b      	ldr	r3, [pc, #44]	; (12b8 <spi_m_sync_init+0x40>)
    128c:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    128e:	4620      	mov	r0, r4
    1290:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_sync_init(&spi->dev, hw);
    1294:	4629      	mov	r1, r5
    1296:	4b09      	ldr	r3, [pc, #36]	; (12bc <spi_m_sync_init+0x44>)
    1298:	4798      	blx	r3

	if (rc < 0) {
    129a:	2800      	cmp	r0, #0
    129c:	db07      	blt.n	12ae <spi_m_sync_init+0x36>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    129e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    12a2:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
    12a4:	4b06      	ldr	r3, [pc, #24]	; (12c0 <spi_m_sync_init+0x48>)
    12a6:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
    12a8:	4b06      	ldr	r3, [pc, #24]	; (12c4 <spi_m_sync_init+0x4c>)
    12aa:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
    12ac:	2000      	movs	r0, #0
}
    12ae:	bd38      	pop	{r3, r4, r5, pc}
    12b0:	2000      	movs	r0, #0
    12b2:	e7e8      	b.n	1286 <spi_m_sync_init+0xe>
    12b4:	00006dc8 	.word	0x00006dc8
    12b8:	000019fd 	.word	0x000019fd
    12bc:	00002ae9 	.word	0x00002ae9
    12c0:	00001345 	.word	0x00001345
    12c4:	00001309 	.word	0x00001309

000012c8 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    12c8:	b530      	push	{r4, r5, lr}
    12ca:	b085      	sub	sp, #20
    12cc:	460c      	mov	r4, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    12ce:	4605      	mov	r5, r0
    12d0:	b190      	cbz	r0, 12f8 <spi_m_sync_transfer+0x30>
    12d2:	1c08      	adds	r0, r1, #0
    12d4:	bf18      	it	ne
    12d6:	2001      	movne	r0, #1
    12d8:	22b3      	movs	r2, #179	; 0xb3
    12da:	4908      	ldr	r1, [pc, #32]	; (12fc <spi_m_sync_transfer+0x34>)
    12dc:	4b08      	ldr	r3, [pc, #32]	; (1300 <spi_m_sync_transfer+0x38>)
    12de:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
    12e0:	6823      	ldr	r3, [r4, #0]
    12e2:	9301      	str	r3, [sp, #4]
	msg.rxbuf = p_xfer->rxbuf;
    12e4:	6863      	ldr	r3, [r4, #4]
    12e6:	9302      	str	r3, [sp, #8]
	msg.size  = p_xfer->size;
    12e8:	68a3      	ldr	r3, [r4, #8]
    12ea:	9303      	str	r3, [sp, #12]
	return _spi_m_sync_trans(&spi->dev, &msg);
    12ec:	a901      	add	r1, sp, #4
    12ee:	1d28      	adds	r0, r5, #4
    12f0:	4b04      	ldr	r3, [pc, #16]	; (1304 <spi_m_sync_transfer+0x3c>)
    12f2:	4798      	blx	r3
}
    12f4:	b005      	add	sp, #20
    12f6:	bd30      	pop	{r4, r5, pc}
    12f8:	2000      	movs	r0, #0
    12fa:	e7ed      	b.n	12d8 <spi_m_sync_transfer+0x10>
    12fc:	00006dc8 	.word	0x00006dc8
    1300:	000019fd 	.word	0x000019fd
    1304:	00002c99 	.word	0x00002c99

00001308 <_spi_m_sync_io_write>:
{
    1308:	b570      	push	{r4, r5, r6, lr}
    130a:	b084      	sub	sp, #16
    130c:	460e      	mov	r6, r1
    130e:	4615      	mov	r5, r2
	ASSERT(io);
    1310:	4604      	mov	r4, r0
    1312:	22a3      	movs	r2, #163	; 0xa3
    1314:	4908      	ldr	r1, [pc, #32]	; (1338 <_spi_m_sync_io_write+0x30>)
    1316:	3000      	adds	r0, #0
    1318:	bf18      	it	ne
    131a:	2001      	movne	r0, #1
    131c:	4b07      	ldr	r3, [pc, #28]	; (133c <_spi_m_sync_io_write+0x34>)
    131e:	4798      	blx	r3
	xfer.rxbuf = 0;
    1320:	2300      	movs	r3, #0
    1322:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
    1324:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
    1326:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    1328:	a901      	add	r1, sp, #4
    132a:	f1a4 000c 	sub.w	r0, r4, #12
    132e:	4b04      	ldr	r3, [pc, #16]	; (1340 <_spi_m_sync_io_write+0x38>)
    1330:	4798      	blx	r3
}
    1332:	b004      	add	sp, #16
    1334:	bd70      	pop	{r4, r5, r6, pc}
    1336:	bf00      	nop
    1338:	00006dc8 	.word	0x00006dc8
    133c:	000019fd 	.word	0x000019fd
    1340:	000012c9 	.word	0x000012c9

00001344 <_spi_m_sync_io_read>:
{
    1344:	b570      	push	{r4, r5, r6, lr}
    1346:	b084      	sub	sp, #16
    1348:	460e      	mov	r6, r1
    134a:	4615      	mov	r5, r2
	ASSERT(io);
    134c:	4604      	mov	r4, r0
    134e:	2287      	movs	r2, #135	; 0x87
    1350:	4908      	ldr	r1, [pc, #32]	; (1374 <_spi_m_sync_io_read+0x30>)
    1352:	3000      	adds	r0, #0
    1354:	bf18      	it	ne
    1356:	2001      	movne	r0, #1
    1358:	4b07      	ldr	r3, [pc, #28]	; (1378 <_spi_m_sync_io_read+0x34>)
    135a:	4798      	blx	r3
	xfer.rxbuf = buf;
    135c:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
    135e:	2300      	movs	r3, #0
    1360:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
    1362:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    1364:	a901      	add	r1, sp, #4
    1366:	f1a4 000c 	sub.w	r0, r4, #12
    136a:	4b04      	ldr	r3, [pc, #16]	; (137c <_spi_m_sync_io_read+0x38>)
    136c:	4798      	blx	r3
}
    136e:	b004      	add	sp, #16
    1370:	bd70      	pop	{r4, r5, r6, pc}
    1372:	bf00      	nop
    1374:	00006dc8 	.word	0x00006dc8
    1378:	000019fd 	.word	0x000019fd
    137c:	000012c9 	.word	0x000012c9

00001380 <usart_os_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_os_error(struct _usart_async_device *device)
{
    1380:	b508      	push	{r3, lr}
	struct usart_os_descriptor *descr = CONTAINER_OF(device, struct usart_os_descriptor, device);

	sem_up(&descr->rx_sem);
    1382:	303c      	adds	r0, #60	; 0x3c
    1384:	4b01      	ldr	r3, [pc, #4]	; (138c <usart_os_error+0xc>)
    1386:	4798      	blx	r3
    1388:	bd08      	pop	{r3, pc}
    138a:	bf00      	nop
    138c:	00003fc1 	.word	0x00003fc1

00001390 <usart_os_transmission_complete>:
{
    1390:	b508      	push	{r3, lr}
	sem_up(&descr->tx_sem);
    1392:	3040      	adds	r0, #64	; 0x40
    1394:	4b01      	ldr	r3, [pc, #4]	; (139c <usart_os_transmission_complete+0xc>)
    1396:	4798      	blx	r3
    1398:	bd08      	pop	{r3, pc}
    139a:	bf00      	nop
    139c:	00003fc1 	.word	0x00003fc1

000013a0 <usart_os_fill_rx_buffer>:
{
    13a0:	b508      	push	{r3, lr}
        RX_int(data);
    13a2:	4608      	mov	r0, r1
    13a4:	4b01      	ldr	r3, [pc, #4]	; (13ac <usart_os_fill_rx_buffer+0xc>)
    13a6:	4798      	blx	r3
    13a8:	bd08      	pop	{r3, pc}
    13aa:	bf00      	nop
    13ac:	00003df9 	.word	0x00003df9

000013b0 <usart_os_process_byte_sent>:
{
    13b0:	b510      	push	{r4, lr}
    13b2:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
    13b4:	8f03      	ldrh	r3, [r0, #56]	; 0x38
    13b6:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
    13b8:	429a      	cmp	r2, r3
    13ba:	d009      	beq.n	13d0 <usart_os_process_byte_sent+0x20>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
    13bc:	6b42      	ldr	r2, [r0, #52]	; 0x34
    13be:	1c59      	adds	r1, r3, #1
    13c0:	8701      	strh	r1, [r0, #56]	; 0x38
    13c2:	5cd1      	ldrb	r1, [r2, r3]
    13c4:	4b04      	ldr	r3, [pc, #16]	; (13d8 <usart_os_process_byte_sent+0x28>)
    13c6:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
    13c8:	4620      	mov	r0, r4
    13ca:	4b04      	ldr	r3, [pc, #16]	; (13dc <usart_os_process_byte_sent+0x2c>)
    13cc:	4798      	blx	r3
    13ce:	bd10      	pop	{r4, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
    13d0:	4b03      	ldr	r3, [pc, #12]	; (13e0 <usart_os_process_byte_sent+0x30>)
    13d2:	4798      	blx	r3
    13d4:	bd10      	pop	{r4, pc}
    13d6:	bf00      	nop
    13d8:	0000280f 	.word	0x0000280f
    13dc:	0000283b 	.word	0x0000283b
    13e0:	00002843 	.word	0x00002843

000013e4 <usart_os_write>:
{
    13e4:	b538      	push	{r3, r4, r5, lr}
    13e6:	4604      	mov	r4, r0
    13e8:	4615      	mov	r5, r2
	descr->tx_buffer        = (uint8_t *)buf;
    13ea:	63c1      	str	r1, [r0, #60]	; 0x3c
	descr->tx_buffer_length = length;
    13ec:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
	descr->tx_por           = 0;
    13f0:	2300      	movs	r3, #0
    13f2:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40
	_usart_async_enable_byte_sent_irq(&descr->device);
    13f6:	3008      	adds	r0, #8
    13f8:	4b06      	ldr	r3, [pc, #24]	; (1414 <usart_os_write+0x30>)
    13fa:	4798      	blx	r3
	return sem_down(&descr->tx_sem, ~0) == 0 ? length : ERR_TIMEOUT;
    13fc:	f04f 31ff 	mov.w	r1, #4294967295
    1400:	f104 0048 	add.w	r0, r4, #72	; 0x48
    1404:	4b04      	ldr	r3, [pc, #16]	; (1418 <usart_os_write+0x34>)
    1406:	4798      	blx	r3
    1408:	2800      	cmp	r0, #0
}
    140a:	bf0c      	ite	eq
    140c:	4628      	moveq	r0, r5
    140e:	f06f 0007 	mvnne.w	r0, #7
    1412:	bd38      	pop	{r3, r4, r5, pc}
    1414:	0000283b 	.word	0x0000283b
    1418:	00004005 	.word	0x00004005

0000141c <usart_os_read>:
{
    141c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1420:	b082      	sub	sp, #8
    1422:	4604      	mov	r4, r0
    1424:	4690      	mov	r8, r2
	ASSERT(buf);
    1426:	460e      	mov	r6, r1
    1428:	1c08      	adds	r0, r1, #0
    142a:	bf18      	it	ne
    142c:	2001      	movne	r0, #1
    142e:	f240 1225 	movw	r2, #293	; 0x125
    1432:	4921      	ldr	r1, [pc, #132]	; (14b8 <usart_os_read+0x9c>)
    1434:	4b21      	ldr	r3, [pc, #132]	; (14bc <usart_os_read+0xa0>)
    1436:	4798      	blx	r3
	if (ringbuffer_num(&descr->rx) < length) {
    1438:	f104 0524 	add.w	r5, r4, #36	; 0x24
    143c:	4628      	mov	r0, r5
    143e:	4b20      	ldr	r3, [pc, #128]	; (14c0 <usart_os_read+0xa4>)
    1440:	4798      	blx	r3
    1442:	4540      	cmp	r0, r8
    1444:	d313      	bcc.n	146e <usart_os_read+0x52>
		while (was_read < length) {
    1446:	f1b8 0f00 	cmp.w	r8, #0
    144a:	d00c      	beq.n	1466 <usart_os_read+0x4a>
    144c:	4634      	mov	r4, r6
    144e:	f108 33ff 	add.w	r3, r8, #4294967295
    1452:	b29b      	uxth	r3, r3
    1454:	3301      	adds	r3, #1
    1456:	441e      	add	r6, r3
			ringbuffer_get(&descr->rx, &buf[was_read++]);
    1458:	4f1a      	ldr	r7, [pc, #104]	; (14c4 <usart_os_read+0xa8>)
    145a:	4621      	mov	r1, r4
    145c:	4628      	mov	r0, r5
    145e:	47b8      	blx	r7
    1460:	3401      	adds	r4, #1
		while (was_read < length) {
    1462:	42b4      	cmp	r4, r6
    1464:	d1f9      	bne.n	145a <usart_os_read+0x3e>
	return (int32_t)length;
    1466:	4640      	mov	r0, r8
}
    1468:	b002      	add	sp, #8
    146a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		CRITICAL_SECTION_ENTER()
    146e:	a801      	add	r0, sp, #4
    1470:	4b15      	ldr	r3, [pc, #84]	; (14c8 <usart_os_read+0xac>)
    1472:	4798      	blx	r3
		descr->rx_size   = 0;
    1474:	2300      	movs	r3, #0
    1476:	8723      	strh	r3, [r4, #56]	; 0x38
		descr->rx_length = length;
    1478:	f8a4 803a 	strh.w	r8, [r4, #58]	; 0x3a
		descr->rx_buffer = buf;
    147c:	6366      	str	r6, [r4, #52]	; 0x34
		while (ringbuffer_num(&descr->rx) > 0) {
    147e:	4e10      	ldr	r6, [pc, #64]	; (14c0 <usart_os_read+0xa4>)
			ringbuffer_get(&descr->rx, &descr->rx_buffer[descr->rx_size++]);
    1480:	4f10      	ldr	r7, [pc, #64]	; (14c4 <usart_os_read+0xa8>)
		while (ringbuffer_num(&descr->rx) > 0) {
    1482:	e006      	b.n	1492 <usart_os_read+0x76>
			ringbuffer_get(&descr->rx, &descr->rx_buffer[descr->rx_size++]);
    1484:	6b61      	ldr	r1, [r4, #52]	; 0x34
    1486:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    1488:	1c5a      	adds	r2, r3, #1
    148a:	8722      	strh	r2, [r4, #56]	; 0x38
    148c:	4419      	add	r1, r3
    148e:	4628      	mov	r0, r5
    1490:	47b8      	blx	r7
		while (ringbuffer_num(&descr->rx) > 0) {
    1492:	4628      	mov	r0, r5
    1494:	47b0      	blx	r6
    1496:	2800      	cmp	r0, #0
    1498:	d1f4      	bne.n	1484 <usart_os_read+0x68>
		CRITICAL_SECTION_LEAVE()
    149a:	a801      	add	r0, sp, #4
    149c:	4b0b      	ldr	r3, [pc, #44]	; (14cc <usart_os_read+0xb0>)
    149e:	4798      	blx	r3
		if (sem_down(&descr->rx_sem, timeout) != 0) {
    14a0:	f04f 31ff 	mov.w	r1, #4294967295
    14a4:	f104 0044 	add.w	r0, r4, #68	; 0x44
    14a8:	4b09      	ldr	r3, [pc, #36]	; (14d0 <usart_os_read+0xb4>)
    14aa:	4798      	blx	r3
    14ac:	2800      	cmp	r0, #0
    14ae:	d0da      	beq.n	1466 <usart_os_read+0x4a>
			return ERR_TIMEOUT;
    14b0:	f06f 0007 	mvn.w	r0, #7
    14b4:	e7d8      	b.n	1468 <usart_os_read+0x4c>
    14b6:	bf00      	nop
    14b8:	00006de4 	.word	0x00006de4
    14bc:	000019fd 	.word	0x000019fd
    14c0:	00001a99 	.word	0x00001a99
    14c4:	00001a55 	.word	0x00001a55
    14c8:	00000f81 	.word	0x00000f81
    14cc:	00000f8f 	.word	0x00000f8f
    14d0:	00004005 	.word	0x00004005

000014d4 <usart_os_init>:
{
    14d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    14d8:	460f      	mov	r7, r1
    14da:	4615      	mov	r5, r2
    14dc:	461e      	mov	r6, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    14de:	4604      	mov	r4, r0
    14e0:	2800      	cmp	r0, #0
    14e2:	d046      	beq.n	1572 <usart_os_init+0x9e>
    14e4:	2900      	cmp	r1, #0
    14e6:	d046      	beq.n	1576 <usart_os_init+0xa2>
    14e8:	2a00      	cmp	r2, #0
    14ea:	d046      	beq.n	157a <usart_os_init+0xa6>
    14ec:	1c18      	adds	r0, r3, #0
    14ee:	bf18      	it	ne
    14f0:	2001      	movne	r0, #1
    14f2:	2241      	movs	r2, #65	; 0x41
    14f4:	4928      	ldr	r1, [pc, #160]	; (1598 <usart_os_init+0xc4>)
    14f6:	4b29      	ldr	r3, [pc, #164]	; (159c <usart_os_init+0xc8>)
    14f8:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
    14fa:	4632      	mov	r2, r6
    14fc:	4629      	mov	r1, r5
    14fe:	f104 0024 	add.w	r0, r4, #36	; 0x24
    1502:	4b27      	ldr	r3, [pc, #156]	; (15a0 <usart_os_init+0xcc>)
    1504:	4798      	blx	r3
    1506:	2800      	cmp	r0, #0
    1508:	d143      	bne.n	1592 <usart_os_init+0xbe>
	rc = sem_init(&descr->rx_sem, 0);
    150a:	f104 0644 	add.w	r6, r4, #68	; 0x44
    150e:	2100      	movs	r1, #0
    1510:	4630      	mov	r0, r6
    1512:	4b24      	ldr	r3, [pc, #144]	; (15a4 <usart_os_init+0xd0>)
    1514:	4798      	blx	r3
	if (rc < 0) {
    1516:	1e05      	subs	r5, r0, #0
    1518:	db28      	blt.n	156c <usart_os_init+0x98>
	rc = sem_init(&descr->tx_sem, 0);
    151a:	f104 0948 	add.w	r9, r4, #72	; 0x48
    151e:	2100      	movs	r1, #0
    1520:	4648      	mov	r0, r9
    1522:	4b20      	ldr	r3, [pc, #128]	; (15a4 <usart_os_init+0xd0>)
    1524:	4798      	blx	r3
	if (rc < 0) {
    1526:	1e05      	subs	r5, r0, #0
    1528:	db29      	blt.n	157e <usart_os_init+0xaa>
	rc = _usart_async_init(&descr->device, hw);
    152a:	f104 0808 	add.w	r8, r4, #8
    152e:	4639      	mov	r1, r7
    1530:	4640      	mov	r0, r8
    1532:	4b1d      	ldr	r3, [pc, #116]	; (15a8 <usart_os_init+0xd4>)
    1534:	4798      	blx	r3
	if (rc) {
    1536:	4605      	mov	r5, r0
    1538:	bb28      	cbnz	r0, 1586 <usart_os_init+0xb2>
	descr->rx_buffer = NULL;
    153a:	2300      	movs	r3, #0
    153c:	6363      	str	r3, [r4, #52]	; 0x34
	descr->rx_size   = 0;
    153e:	8723      	strh	r3, [r4, #56]	; 0x38
	descr->rx_length = 0;
    1540:	8763      	strh	r3, [r4, #58]	; 0x3a
	descr->io.read  = usart_os_read;
    1542:	4b1a      	ldr	r3, [pc, #104]	; (15ac <usart_os_init+0xd8>)
    1544:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_os_write;
    1546:	4b1a      	ldr	r3, [pc, #104]	; (15b0 <usart_os_init+0xdc>)
    1548:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_os_process_byte_sent;
    154a:	4b1a      	ldr	r3, [pc, #104]	; (15b4 <usart_os_init+0xe0>)
    154c:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_os_fill_rx_buffer;
    154e:	4b1a      	ldr	r3, [pc, #104]	; (15b8 <usart_os_init+0xe4>)
    1550:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_os_transmission_complete;
    1552:	4b1a      	ldr	r3, [pc, #104]	; (15bc <usart_os_init+0xe8>)
    1554:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_os_error;
    1556:	4b1a      	ldr	r3, [pc, #104]	; (15c0 <usart_os_init+0xec>)
    1558:	6163      	str	r3, [r4, #20]
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, true);
    155a:	2201      	movs	r2, #1
    155c:	4611      	mov	r1, r2
    155e:	4640      	mov	r0, r8
    1560:	4c18      	ldr	r4, [pc, #96]	; (15c4 <usart_os_init+0xf0>)
    1562:	47a0      	blx	r4
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, true);
    1564:	2201      	movs	r2, #1
    1566:	2103      	movs	r1, #3
    1568:	4640      	mov	r0, r8
    156a:	47a0      	blx	r4
}
    156c:	4628      	mov	r0, r5
    156e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    1572:	2000      	movs	r0, #0
    1574:	e7bd      	b.n	14f2 <usart_os_init+0x1e>
    1576:	2000      	movs	r0, #0
    1578:	e7bb      	b.n	14f2 <usart_os_init+0x1e>
    157a:	2000      	movs	r0, #0
    157c:	e7b9      	b.n	14f2 <usart_os_init+0x1e>
		sem_deinit(&descr->tx_sem);
    157e:	4648      	mov	r0, r9
    1580:	4b11      	ldr	r3, [pc, #68]	; (15c8 <usart_os_init+0xf4>)
    1582:	4798      	blx	r3
		return rc;
    1584:	e7f2      	b.n	156c <usart_os_init+0x98>
		sem_deinit(&descr->tx_sem);
    1586:	4648      	mov	r0, r9
    1588:	4c0f      	ldr	r4, [pc, #60]	; (15c8 <usart_os_init+0xf4>)
    158a:	47a0      	blx	r4
		sem_deinit(&descr->rx_sem);
    158c:	4630      	mov	r0, r6
    158e:	47a0      	blx	r4
		return rc;
    1590:	e7ec      	b.n	156c <usart_os_init+0x98>
		return ERR_INVALID_ARG;
    1592:	f06f 050c 	mvn.w	r5, #12
    1596:	e7e9      	b.n	156c <usart_os_init+0x98>
    1598:	00006de4 	.word	0x00006de4
    159c:	000019fd 	.word	0x000019fd
    15a0:	00001a05 	.word	0x00001a05
    15a4:	00003f89 	.word	0x00003f89
    15a8:	00002765 	.word	0x00002765
    15ac:	0000141d 	.word	0x0000141d
    15b0:	000013e5 	.word	0x000013e5
    15b4:	000013b1 	.word	0x000013b1
    15b8:	000013a1 	.word	0x000013a1
    15bc:	00001391 	.word	0x00001391
    15c0:	00001381 	.word	0x00001381
    15c4:	0000284d 	.word	0x0000284d
    15c8:	00004025 	.word	0x00004025

000015cc <usart_os_enable>:
{
    15cc:	b510      	push	{r4, lr}
	ASSERT(descr);
    15ce:	4604      	mov	r4, r0
    15d0:	227c      	movs	r2, #124	; 0x7c
    15d2:	4906      	ldr	r1, [pc, #24]	; (15ec <usart_os_enable+0x20>)
    15d4:	3000      	adds	r0, #0
    15d6:	bf18      	it	ne
    15d8:	2001      	movne	r0, #1
    15da:	4b05      	ldr	r3, [pc, #20]	; (15f0 <usart_os_enable+0x24>)
    15dc:	4798      	blx	r3
	_usart_async_enable(&descr->device);
    15de:	f104 0008 	add.w	r0, r4, #8
    15e2:	4b04      	ldr	r3, [pc, #16]	; (15f4 <usart_os_enable+0x28>)
    15e4:	4798      	blx	r3
}
    15e6:	2000      	movs	r0, #0
    15e8:	bd10      	pop	{r4, pc}
    15ea:	bf00      	nop
    15ec:	00006de4 	.word	0x00006de4
    15f0:	000019fd 	.word	0x000019fd
    15f4:	000027f5 	.word	0x000027f5

000015f8 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    15f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    15fc:	460f      	mov	r7, r1
    15fe:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1600:	4604      	mov	r4, r0
    1602:	b328      	cbz	r0, 1650 <usart_sync_write+0x58>
    1604:	b331      	cbz	r1, 1654 <usart_sync_write+0x5c>
    1606:	1c10      	adds	r0, r2, #0
    1608:	bf18      	it	ne
    160a:	2001      	movne	r0, #1
    160c:	22f1      	movs	r2, #241	; 0xf1
    160e:	4912      	ldr	r1, [pc, #72]	; (1658 <usart_sync_write+0x60>)
    1610:	4b12      	ldr	r3, [pc, #72]	; (165c <usart_sync_write+0x64>)
    1612:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    1614:	3408      	adds	r4, #8
    1616:	4d12      	ldr	r5, [pc, #72]	; (1660 <usart_sync_write+0x68>)
    1618:	4620      	mov	r0, r4
    161a:	47a8      	blx	r5
    161c:	2800      	cmp	r0, #0
    161e:	d0fb      	beq.n	1618 <usart_sync_write+0x20>
    1620:	3f01      	subs	r7, #1
    1622:	2600      	movs	r6, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1624:	f8df 9040 	ldr.w	r9, [pc, #64]	; 1668 <usart_sync_write+0x70>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1628:	4d0d      	ldr	r5, [pc, #52]	; (1660 <usart_sync_write+0x68>)
		_usart_sync_write_byte(&descr->device, buf[offset]);
    162a:	f817 1f01 	ldrb.w	r1, [r7, #1]!
    162e:	4620      	mov	r0, r4
    1630:	47c8      	blx	r9
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1632:	4620      	mov	r0, r4
    1634:	47a8      	blx	r5
    1636:	2800      	cmp	r0, #0
    1638:	d0fb      	beq.n	1632 <usart_sync_write+0x3a>
			;
	} while (++offset < length);
    163a:	3601      	adds	r6, #1
    163c:	4546      	cmp	r6, r8
    163e:	d3f4      	bcc.n	162a <usart_sync_write+0x32>
	while (!_usart_sync_is_transmit_done(&descr->device))
    1640:	4d08      	ldr	r5, [pc, #32]	; (1664 <usart_sync_write+0x6c>)
    1642:	4620      	mov	r0, r4
    1644:	47a8      	blx	r5
    1646:	2800      	cmp	r0, #0
    1648:	d0fb      	beq.n	1642 <usart_sync_write+0x4a>
		;
	return (int32_t)offset;
}
    164a:	4630      	mov	r0, r6
    164c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    1650:	2000      	movs	r0, #0
    1652:	e7db      	b.n	160c <usart_sync_write+0x14>
    1654:	2000      	movs	r0, #0
    1656:	e7d9      	b.n	160c <usart_sync_write+0x14>
    1658:	00006e00 	.word	0x00006e00
    165c:	000019fd 	.word	0x000019fd
    1660:	0000281d 	.word	0x0000281d
    1664:	00002827 	.word	0x00002827
    1668:	00002809 	.word	0x00002809

0000166c <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    166c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1670:	460f      	mov	r7, r1
    1672:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1674:	4604      	mov	r4, r0
    1676:	b1e0      	cbz	r0, 16b2 <usart_sync_read+0x46>
    1678:	b1e9      	cbz	r1, 16b6 <usart_sync_read+0x4a>
    167a:	1c10      	adds	r0, r2, #0
    167c:	bf18      	it	ne
    167e:	2001      	movne	r0, #1
    1680:	f44f 7286 	mov.w	r2, #268	; 0x10c
    1684:	490d      	ldr	r1, [pc, #52]	; (16bc <usart_sync_read+0x50>)
    1686:	4b0e      	ldr	r3, [pc, #56]	; (16c0 <usart_sync_read+0x54>)
    1688:	4798      	blx	r3
    168a:	3f01      	subs	r7, #1
	uint32_t                      offset = 0;
    168c:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    168e:	3408      	adds	r4, #8
    1690:	4d0c      	ldr	r5, [pc, #48]	; (16c4 <usart_sync_read+0x58>)
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    1692:	f8df 9034 	ldr.w	r9, [pc, #52]	; 16c8 <usart_sync_read+0x5c>
		while (!_usart_sync_is_byte_received(&descr->device))
    1696:	4620      	mov	r0, r4
    1698:	47a8      	blx	r5
    169a:	2800      	cmp	r0, #0
    169c:	d0fb      	beq.n	1696 <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    169e:	4620      	mov	r0, r4
    16a0:	47c8      	blx	r9
    16a2:	f807 0f01 	strb.w	r0, [r7, #1]!
	} while (++offset < length);
    16a6:	3601      	adds	r6, #1
    16a8:	4546      	cmp	r6, r8
    16aa:	d3f4      	bcc.n	1696 <usart_sync_read+0x2a>

	return (int32_t)offset;
}
    16ac:	4630      	mov	r0, r6
    16ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    16b2:	2000      	movs	r0, #0
    16b4:	e7e4      	b.n	1680 <usart_sync_read+0x14>
    16b6:	2000      	movs	r0, #0
    16b8:	e7e2      	b.n	1680 <usart_sync_read+0x14>
    16ba:	bf00      	nop
    16bc:	00006e00 	.word	0x00006e00
    16c0:	000019fd 	.word	0x000019fd
    16c4:	00002831 	.word	0x00002831
    16c8:	00002815 	.word	0x00002815

000016cc <usart_sync_init>:
{
    16cc:	b538      	push	{r3, r4, r5, lr}
    16ce:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    16d0:	4604      	mov	r4, r0
    16d2:	b198      	cbz	r0, 16fc <usart_sync_init+0x30>
    16d4:	1c08      	adds	r0, r1, #0
    16d6:	bf18      	it	ne
    16d8:	2001      	movne	r0, #1
    16da:	2234      	movs	r2, #52	; 0x34
    16dc:	4908      	ldr	r1, [pc, #32]	; (1700 <usart_sync_init+0x34>)
    16de:	4b09      	ldr	r3, [pc, #36]	; (1704 <usart_sync_init+0x38>)
    16e0:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    16e2:	4629      	mov	r1, r5
    16e4:	f104 0008 	add.w	r0, r4, #8
    16e8:	4b07      	ldr	r3, [pc, #28]	; (1708 <usart_sync_init+0x3c>)
    16ea:	4798      	blx	r3
	if (init_status) {
    16ec:	4603      	mov	r3, r0
    16ee:	b918      	cbnz	r0, 16f8 <usart_sync_init+0x2c>
	descr->io.read  = usart_sync_read;
    16f0:	4a06      	ldr	r2, [pc, #24]	; (170c <usart_sync_init+0x40>)
    16f2:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
    16f4:	4a06      	ldr	r2, [pc, #24]	; (1710 <usart_sync_init+0x44>)
    16f6:	6022      	str	r2, [r4, #0]
}
    16f8:	4618      	mov	r0, r3
    16fa:	bd38      	pop	{r3, r4, r5, pc}
    16fc:	2000      	movs	r0, #0
    16fe:	e7ec      	b.n	16da <usart_sync_init+0xe>
    1700:	00006e00 	.word	0x00006e00
    1704:	000019fd 	.word	0x000019fd
    1708:	00002739 	.word	0x00002739
    170c:	0000166d 	.word	0x0000166d
    1710:	000015f9 	.word	0x000015f9

00001714 <usart_sync_enable>:
{
    1714:	b510      	push	{r4, lr}
	ASSERT(descr);
    1716:	4604      	mov	r4, r0
    1718:	2253      	movs	r2, #83	; 0x53
    171a:	4906      	ldr	r1, [pc, #24]	; (1734 <usart_sync_enable+0x20>)
    171c:	3000      	adds	r0, #0
    171e:	bf18      	it	ne
    1720:	2001      	movne	r0, #1
    1722:	4b05      	ldr	r3, [pc, #20]	; (1738 <usart_sync_enable+0x24>)
    1724:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    1726:	f104 0008 	add.w	r0, r4, #8
    172a:	4b04      	ldr	r3, [pc, #16]	; (173c <usart_sync_enable+0x28>)
    172c:	4798      	blx	r3
}
    172e:	2000      	movs	r0, #0
    1730:	bd10      	pop	{r4, pc}
    1732:	bf00      	nop
    1734:	00006e00 	.word	0x00006e00
    1738:	000019fd 	.word	0x000019fd
    173c:	000027e1 	.word	0x000027e1

00001740 <_usb_d_find_ep>:
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    1740:	4b0f      	ldr	r3, [pc, #60]	; (1780 <_usb_d_find_ep+0x40>)
    1742:	7859      	ldrb	r1, [r3, #1]
    1744:	4288      	cmp	r0, r1
    1746:	d018      	beq.n	177a <_usb_d_find_ep+0x3a>
{
    1748:	b430      	push	{r4, r5}
    174a:	461a      	mov	r2, r3
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    174c:	2300      	movs	r3, #0
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    174e:	f000 050f 	and.w	r5, r0, #15
    1752:	e007      	b.n	1764 <_usb_d_find_ep+0x24>
    1754:	3301      	adds	r3, #1
    1756:	b25b      	sxtb	r3, r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    1758:	2b04      	cmp	r3, #4
    175a:	d009      	beq.n	1770 <_usb_d_find_ep+0x30>
    175c:	3220      	adds	r2, #32
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    175e:	7851      	ldrb	r1, [r2, #1]
    1760:	4281      	cmp	r1, r0
    1762:	d007      	beq.n	1774 <_usb_d_find_ep+0x34>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    1764:	7814      	ldrb	r4, [r2, #0]
    1766:	2c00      	cmp	r4, #0
    1768:	d1f4      	bne.n	1754 <_usb_d_find_ep+0x14>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    176a:	428d      	cmp	r5, r1
    176c:	d1f2      	bne.n	1754 <_usb_d_find_ep+0x14>
    176e:	e001      	b.n	1774 <_usb_d_find_ep+0x34>
			return i;
		}
	}
	return -1;
    1770:	f04f 33ff 	mov.w	r3, #4294967295
}
    1774:	4618      	mov	r0, r3
    1776:	bc30      	pop	{r4, r5}
    1778:	4770      	bx	lr
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    177a:	2300      	movs	r3, #0
}
    177c:	4618      	mov	r0, r3
    177e:	4770      	bx	lr
    1780:	2000029c 	.word	0x2000029c

00001784 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    1784:	2000      	movs	r0, #0
    1786:	4770      	bx	lr

00001788 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    1788:	b538      	push	{r3, r4, r5, lr}
    178a:	4604      	mov	r4, r0
    178c:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    178e:	4b09      	ldr	r3, [pc, #36]	; (17b4 <usb_d_cb_trans_more+0x2c>)
    1790:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    1792:	4b09      	ldr	r3, [pc, #36]	; (17b8 <usb_d_cb_trans_more+0x30>)
    1794:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    1798:	789b      	ldrb	r3, [r3, #2]
    179a:	2b03      	cmp	r3, #3
    179c:	d001      	beq.n	17a2 <usb_d_cb_trans_more+0x1a>
		return ept->callbacks.more(ep, transfered);
	}
	return false;
    179e:	2000      	movs	r0, #0
}
    17a0:	bd38      	pop	{r3, r4, r5, pc}
		return ept->callbacks.more(ep, transfered);
    17a2:	4b05      	ldr	r3, [pc, #20]	; (17b8 <usb_d_cb_trans_more+0x30>)
    17a4:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    17a8:	6983      	ldr	r3, [r0, #24]
    17aa:	4629      	mov	r1, r5
    17ac:	4620      	mov	r0, r4
    17ae:	4798      	blx	r3
    17b0:	bd38      	pop	{r3, r4, r5, pc}
    17b2:	bf00      	nop
    17b4:	00001741 	.word	0x00001741
    17b8:	2000029c 	.word	0x2000029c

000017bc <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    17bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    17be:	b085      	sub	sp, #20
    17c0:	4606      	mov	r6, r0
    17c2:	460d      	mov	r5, r1
    17c4:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    17c6:	4b4d      	ldr	r3, [pc, #308]	; (18fc <_usb_d_cb_trans_done+0x140>)
    17c8:	4798      	blx	r3
    17ca:	4604      	mov	r4, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    17cc:	2d00      	cmp	r5, #0
    17ce:	d15b      	bne.n	1888 <_usb_d_cb_trans_done+0xcc>
		ept->xfer.hdr.status = USB_XFER_DONE;
    17d0:	4a4b      	ldr	r2, [pc, #300]	; (1900 <_usb_d_cb_trans_done+0x144>)
    17d2:	0143      	lsls	r3, r0, #5
    17d4:	18d1      	adds	r1, r2, r3
    17d6:	2000      	movs	r0, #0
    17d8:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    17da:	5cd3      	ldrb	r3, [r2, r3]
    17dc:	b173      	cbz	r3, 17fc <_usb_d_cb_trans_done+0x40>
			usb_d_ctrl_trans_done(ept);
			return;
		}
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    17de:	4b48      	ldr	r3, [pc, #288]	; (1900 <_usb_d_cb_trans_done+0x144>)
    17e0:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    17e4:	2201      	movs	r2, #1
    17e6:	709a      	strb	r2, [r3, #2]
	} else {
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    17e8:	4845      	ldr	r0, [pc, #276]	; (1900 <_usb_d_cb_trans_done+0x144>)
    17ea:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    17ee:	69c3      	ldr	r3, [r0, #28]
    17f0:	463a      	mov	r2, r7
    17f2:	78c1      	ldrb	r1, [r0, #3]
    17f4:	4630      	mov	r0, r6
    17f6:	4798      	blx	r3
}
    17f8:	b005      	add	sp, #20
    17fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (state == USB_EP_S_X_DATA) {
    17fc:	788b      	ldrb	r3, [r1, #2]
    17fe:	2b03      	cmp	r3, #3
    1800:	d00b      	beq.n	181a <_usb_d_cb_trans_done+0x5e>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    1802:	483f      	ldr	r0, [pc, #252]	; (1900 <_usb_d_cb_trans_done+0x144>)
    1804:	eb00 1244 	add.w	r2, r0, r4, lsl #5
    1808:	4614      	mov	r4, r2
    180a:	69d3      	ldr	r3, [r2, #28]
    180c:	320c      	adds	r2, #12
    180e:	2100      	movs	r1, #0
    1810:	7860      	ldrb	r0, [r4, #1]
    1812:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    1814:	2302      	movs	r3, #2
    1816:	70a3      	strb	r3, [r4, #2]
    1818:	e7ee      	b.n	17f8 <_usb_d_cb_trans_done+0x3c>
	bool    req_dir = USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN;
    181a:	460b      	mov	r3, r1
    181c:	f991 500c 	ldrsb.w	r5, [r1, #12]
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    1820:	460a      	mov	r2, r1
    1822:	69ce      	ldr	r6, [r1, #28]
    1824:	320c      	adds	r2, #12
    1826:	2101      	movs	r1, #1
    1828:	7858      	ldrb	r0, [r3, #1]
    182a:	47b0      	blx	r6
		if (err) {
    182c:	b1a0      	cbz	r0, 1858 <_usb_d_cb_trans_done+0x9c>
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    182e:	4b34      	ldr	r3, [pc, #208]	; (1900 <_usb_d_cb_trans_done+0x144>)
    1830:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    1834:	2205      	movs	r2, #5
    1836:	709a      	strb	r2, [r3, #2]
			ept->xfer.hdr.status = USB_XFER_HALT;
    1838:	2202      	movs	r2, #2
    183a:	70da      	strb	r2, [r3, #3]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    183c:	2d00      	cmp	r5, #0
    183e:	db09      	blt.n	1854 <_usb_d_cb_trans_done+0x98>
    1840:	482f      	ldr	r0, [pc, #188]	; (1900 <_usb_d_cb_trans_done+0x144>)
    1842:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    1846:	7840      	ldrb	r0, [r0, #1]
    1848:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    184c:	2101      	movs	r1, #1
    184e:	4b2d      	ldr	r3, [pc, #180]	; (1904 <_usb_d_cb_trans_done+0x148>)
    1850:	4798      	blx	r3
    1852:	e7d1      	b.n	17f8 <_usb_d_cb_trans_done+0x3c>
    1854:	7858      	ldrb	r0, [r3, #1]
    1856:	e7f9      	b.n	184c <_usb_d_cb_trans_done+0x90>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    1858:	4829      	ldr	r0, [pc, #164]	; (1900 <_usb_d_cb_trans_done+0x144>)
    185a:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    185e:	2304      	movs	r3, #4
    1860:	7083      	strb	r3, [r0, #2]
			_usb_d_trans(ept->xfer.hdr.ep, !req_dir, NULL, 0, 1);
    1862:	7843      	ldrb	r3, [r0, #1]
	struct usb_d_transfer trans
    1864:	2200      	movs	r2, #0
    1866:	9201      	str	r2, [sp, #4]
    1868:	9202      	str	r2, [sp, #8]
    186a:	4295      	cmp	r5, r2
    186c:	bfac      	ite	ge
    186e:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    1872:	f003 030f 	andlt.w	r3, r3, #15
    1876:	f88d 300c 	strb.w	r3, [sp, #12]
    187a:	2301      	movs	r3, #1
    187c:	f88d 300d 	strb.w	r3, [sp, #13]
	return _usb_d_dev_ep_trans(&trans);
    1880:	a801      	add	r0, sp, #4
    1882:	4b21      	ldr	r3, [pc, #132]	; (1908 <_usb_d_cb_trans_done+0x14c>)
    1884:	4798      	blx	r3
    1886:	e7b7      	b.n	17f8 <_usb_d_cb_trans_done+0x3c>
	} else if (code == USB_TRANS_STALL) {
    1888:	2d01      	cmp	r5, #1
    188a:	d00a      	beq.n	18a2 <_usb_d_cb_trans_done+0xe6>
	} else if (code == USB_TRANS_ABORT) {
    188c:	2d02      	cmp	r5, #2
    188e:	d01c      	beq.n	18ca <_usb_d_cb_trans_done+0x10e>
	} else if (code == USB_TRANS_RESET) {
    1890:	2d03      	cmp	r5, #3
    1892:	d02a      	beq.n	18ea <_usb_d_cb_trans_done+0x12e>
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    1894:	4b1a      	ldr	r3, [pc, #104]	; (1900 <_usb_d_cb_trans_done+0x144>)
    1896:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    189a:	2206      	movs	r2, #6
    189c:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_ERROR;
    189e:	70da      	strb	r2, [r3, #3]
    18a0:	e7a2      	b.n	17e8 <_usb_d_cb_trans_done+0x2c>
		ept->xfer.hdr.status = USB_XFER_HALT;
    18a2:	4a17      	ldr	r2, [pc, #92]	; (1900 <_usb_d_cb_trans_done+0x144>)
    18a4:	0143      	lsls	r3, r0, #5
    18a6:	18d1      	adds	r1, r2, r3
    18a8:	2002      	movs	r0, #2
    18aa:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    18ac:	5cd3      	ldrb	r3, [r2, r3]
    18ae:	b12b      	cbz	r3, 18bc <_usb_d_cb_trans_done+0x100>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    18b0:	4b13      	ldr	r3, [pc, #76]	; (1900 <_usb_d_cb_trans_done+0x144>)
    18b2:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    18b6:	2205      	movs	r2, #5
    18b8:	709a      	strb	r2, [r3, #2]
    18ba:	e795      	b.n	17e8 <_usb_d_cb_trans_done+0x2c>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    18bc:	460b      	mov	r3, r1
    18be:	7098      	strb	r0, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    18c0:	2100      	movs	r1, #0
    18c2:	4630      	mov	r0, r6
    18c4:	4b0f      	ldr	r3, [pc, #60]	; (1904 <_usb_d_cb_trans_done+0x148>)
    18c6:	4798      	blx	r3
    18c8:	e78e      	b.n	17e8 <_usb_d_cb_trans_done+0x2c>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    18ca:	4a0d      	ldr	r2, [pc, #52]	; (1900 <_usb_d_cb_trans_done+0x144>)
    18cc:	0143      	lsls	r3, r0, #5
    18ce:	18d1      	adds	r1, r2, r3
    18d0:	2004      	movs	r0, #4
    18d2:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    18d4:	5cd3      	ldrb	r3, [r2, r3]
    18d6:	b12b      	cbz	r3, 18e4 <_usb_d_cb_trans_done+0x128>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    18d8:	4b09      	ldr	r3, [pc, #36]	; (1900 <_usb_d_cb_trans_done+0x144>)
    18da:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    18de:	2201      	movs	r2, #1
    18e0:	709a      	strb	r2, [r3, #2]
    18e2:	e781      	b.n	17e8 <_usb_d_cb_trans_done+0x2c>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    18e4:	2302      	movs	r3, #2
    18e6:	708b      	strb	r3, [r1, #2]
			return;
    18e8:	e786      	b.n	17f8 <_usb_d_cb_trans_done+0x3c>
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    18ea:	4b05      	ldr	r3, [pc, #20]	; (1900 <_usb_d_cb_trans_done+0x144>)
    18ec:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    18f0:	2200      	movs	r2, #0
    18f2:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_RESET;
    18f4:	2205      	movs	r2, #5
    18f6:	70da      	strb	r2, [r3, #3]
    18f8:	e776      	b.n	17e8 <_usb_d_cb_trans_done+0x2c>
    18fa:	bf00      	nop
    18fc:	00001741 	.word	0x00001741
    1900:	2000029c 	.word	0x2000029c
    1904:	00003831 	.word	0x00003831
    1908:	000039d9 	.word	0x000039d9

0000190c <usb_d_cb_trans_setup>:
{
    190c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1910:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    1912:	4b1c      	ldr	r3, [pc, #112]	; (1984 <usb_d_cb_trans_setup+0x78>)
    1914:	4798      	blx	r3
    1916:	4606      	mov	r6, r0
	uint8_t *        req      = ept->xfer.req;
    1918:	4c1b      	ldr	r4, [pc, #108]	; (1988 <usb_d_cb_trans_setup+0x7c>)
    191a:	eb04 1440 	add.w	r4, r4, r0, lsl #5
    191e:	340c      	adds	r4, #12
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    1920:	4621      	mov	r1, r4
    1922:	4628      	mov	r0, r5
    1924:	4b19      	ldr	r3, [pc, #100]	; (198c <usb_d_cb_trans_setup+0x80>)
    1926:	4798      	blx	r3
	if (n != 8) {
    1928:	b2c0      	uxtb	r0, r0
    192a:	2808      	cmp	r0, #8
    192c:	d009      	beq.n	1942 <usb_d_cb_trans_setup+0x36>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    192e:	2101      	movs	r1, #1
    1930:	4628      	mov	r0, r5
    1932:	4c17      	ldr	r4, [pc, #92]	; (1990 <usb_d_cb_trans_setup+0x84>)
    1934:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    1936:	2101      	movs	r1, #1
    1938:	f045 0080 	orr.w	r0, r5, #128	; 0x80
    193c:	47a0      	blx	r4
		return;
    193e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    1942:	2100      	movs	r1, #0
    1944:	4628      	mov	r0, r5
    1946:	4f12      	ldr	r7, [pc, #72]	; (1990 <usb_d_cb_trans_setup+0x84>)
    1948:	47b8      	blx	r7
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    194a:	f045 0880 	orr.w	r8, r5, #128	; 0x80
    194e:	2100      	movs	r1, #0
    1950:	4640      	mov	r0, r8
    1952:	47b8      	blx	r7
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    1954:	4b0c      	ldr	r3, [pc, #48]	; (1988 <usb_d_cb_trans_setup+0x7c>)
    1956:	eb03 1346 	add.w	r3, r3, r6, lsl #5
    195a:	2201      	movs	r2, #1
    195c:	709a      	strb	r2, [r3, #2]
	if (!ept->callbacks.req(ep, req)) {
    195e:	695b      	ldr	r3, [r3, #20]
    1960:	4621      	mov	r1, r4
    1962:	4628      	mov	r0, r5
    1964:	4798      	blx	r3
    1966:	b108      	cbz	r0, 196c <usb_d_cb_trans_setup+0x60>
    1968:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    196c:	4b06      	ldr	r3, [pc, #24]	; (1988 <usb_d_cb_trans_setup+0x7c>)
    196e:	eb03 1646 	add.w	r6, r3, r6, lsl #5
    1972:	2305      	movs	r3, #5
    1974:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    1976:	2101      	movs	r1, #1
    1978:	4628      	mov	r0, r5
    197a:	47b8      	blx	r7
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    197c:	2101      	movs	r1, #1
    197e:	4640      	mov	r0, r8
    1980:	47b8      	blx	r7
    1982:	e7f1      	b.n	1968 <usb_d_cb_trans_setup+0x5c>
    1984:	00001741 	.word	0x00001741
    1988:	2000029c 	.word	0x2000029c
    198c:	00003979 	.word	0x00003979
    1990:	00003831 	.word	0x00003831

00001994 <usb_d_init>:

int32_t usb_d_init(void)
{
    1994:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    1996:	4b11      	ldr	r3, [pc, #68]	; (19dc <usb_d_init+0x48>)
    1998:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    199a:	2800      	cmp	r0, #0
    199c:	db1c      	blt.n	19d8 <usb_d_init+0x44>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    199e:	4c10      	ldr	r4, [pc, #64]	; (19e0 <usb_d_init+0x4c>)
    19a0:	2280      	movs	r2, #128	; 0x80
    19a2:	2100      	movs	r1, #0
    19a4:	4620      	mov	r0, r4
    19a6:	4b0f      	ldr	r3, [pc, #60]	; (19e4 <usb_d_init+0x50>)
    19a8:	4798      	blx	r3
    19aa:	4623      	mov	r3, r4
    19ac:	f104 0080 	add.w	r0, r4, #128	; 0x80
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    19b0:	21ff      	movs	r1, #255	; 0xff
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    19b2:	4a0d      	ldr	r2, [pc, #52]	; (19e8 <usb_d_init+0x54>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    19b4:	7059      	strb	r1, [r3, #1]
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    19b6:	615a      	str	r2, [r3, #20]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    19b8:	619a      	str	r2, [r3, #24]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    19ba:	61da      	str	r2, [r3, #28]
    19bc:	3320      	adds	r3, #32
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    19be:	4283      	cmp	r3, r0
    19c0:	d1f8      	bne.n	19b4 <usb_d_init+0x20>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    19c2:	490a      	ldr	r1, [pc, #40]	; (19ec <usb_d_init+0x58>)
    19c4:	2000      	movs	r0, #0
    19c6:	4c0a      	ldr	r4, [pc, #40]	; (19f0 <usb_d_init+0x5c>)
    19c8:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    19ca:	490a      	ldr	r1, [pc, #40]	; (19f4 <usb_d_init+0x60>)
    19cc:	2001      	movs	r0, #1
    19ce:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    19d0:	4909      	ldr	r1, [pc, #36]	; (19f8 <usb_d_init+0x64>)
    19d2:	2002      	movs	r0, #2
    19d4:	47a0      	blx	r4
	return ERR_NONE;
    19d6:	2000      	movs	r0, #0
}
    19d8:	bd10      	pop	{r4, pc}
    19da:	bf00      	nop
    19dc:	00003735 	.word	0x00003735
    19e0:	2000029c 	.word	0x2000029c
    19e4:	00005cdb 	.word	0x00005cdb
    19e8:	00001785 	.word	0x00001785
    19ec:	0000190d 	.word	0x0000190d
    19f0:	00003bb9 	.word	0x00003bb9
    19f4:	00001789 	.word	0x00001789
    19f8:	000017bd 	.word	0x000017bd

000019fc <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    19fc:	b900      	cbnz	r0, 1a00 <assert+0x4>
		__asm("BKPT #0");
    19fe:	be00      	bkpt	0x0000
    1a00:	4770      	bx	lr
	...

00001a04 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
    1a04:	b570      	push	{r4, r5, r6, lr}
    1a06:	460e      	mov	r6, r1
    1a08:	4615      	mov	r5, r2
	ASSERT(rb && buf && size);
    1a0a:	4604      	mov	r4, r0
    1a0c:	b178      	cbz	r0, 1a2e <ringbuffer_init+0x2a>
    1a0e:	b181      	cbz	r1, 1a32 <ringbuffer_init+0x2e>
    1a10:	b1a2      	cbz	r2, 1a3c <ringbuffer_init+0x38>
    1a12:	2001      	movs	r0, #1
    1a14:	2228      	movs	r2, #40	; 0x28
    1a16:	490d      	ldr	r1, [pc, #52]	; (1a4c <ringbuffer_init+0x48>)
    1a18:	4b0d      	ldr	r3, [pc, #52]	; (1a50 <ringbuffer_init+0x4c>)
    1a1a:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
    1a1c:	1e6b      	subs	r3, r5, #1
    1a1e:	421d      	tst	r5, r3
    1a20:	d109      	bne.n	1a36 <ringbuffer_init+0x32>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
    1a22:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
    1a24:	2000      	movs	r0, #0
    1a26:	60a0      	str	r0, [r4, #8]
	rb->write_index = rb->read_index;
    1a28:	60e0      	str	r0, [r4, #12]
	rb->buf         = (uint8_t *)buf;
    1a2a:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
    1a2c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    1a2e:	2000      	movs	r0, #0
    1a30:	e7f0      	b.n	1a14 <ringbuffer_init+0x10>
    1a32:	2000      	movs	r0, #0
    1a34:	e7ee      	b.n	1a14 <ringbuffer_init+0x10>
		return ERR_INVALID_ARG;
    1a36:	f06f 000c 	mvn.w	r0, #12
    1a3a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    1a3c:	2228      	movs	r2, #40	; 0x28
    1a3e:	4903      	ldr	r1, [pc, #12]	; (1a4c <ringbuffer_init+0x48>)
    1a40:	2000      	movs	r0, #0
    1a42:	4b03      	ldr	r3, [pc, #12]	; (1a50 <ringbuffer_init+0x4c>)
    1a44:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
    1a46:	1e6b      	subs	r3, r5, #1
    1a48:	e7eb      	b.n	1a22 <ringbuffer_init+0x1e>
    1a4a:	bf00      	nop
    1a4c:	00006e1c 	.word	0x00006e1c
    1a50:	000019fd 	.word	0x000019fd

00001a54 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
    1a54:	b538      	push	{r3, r4, r5, lr}
    1a56:	460d      	mov	r5, r1
	ASSERT(rb && data);
    1a58:	4604      	mov	r4, r0
    1a5a:	b1a0      	cbz	r0, 1a86 <ringbuffer_get+0x32>
    1a5c:	1c08      	adds	r0, r1, #0
    1a5e:	bf18      	it	ne
    1a60:	2001      	movne	r0, #1
    1a62:	2240      	movs	r2, #64	; 0x40
    1a64:	490a      	ldr	r1, [pc, #40]	; (1a90 <ringbuffer_get+0x3c>)
    1a66:	4b0b      	ldr	r3, [pc, #44]	; (1a94 <ringbuffer_get+0x40>)
    1a68:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
    1a6a:	68a3      	ldr	r3, [r4, #8]
    1a6c:	68e2      	ldr	r2, [r4, #12]
    1a6e:	429a      	cmp	r2, r3
    1a70:	d00b      	beq.n	1a8a <ringbuffer_get+0x36>
		*data = rb->buf[rb->read_index & rb->size];
    1a72:	6862      	ldr	r2, [r4, #4]
    1a74:	4013      	ands	r3, r2
    1a76:	6822      	ldr	r2, [r4, #0]
    1a78:	5cd3      	ldrb	r3, [r2, r3]
    1a7a:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
    1a7c:	68a3      	ldr	r3, [r4, #8]
    1a7e:	3301      	adds	r3, #1
    1a80:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
    1a82:	2000      	movs	r0, #0
    1a84:	bd38      	pop	{r3, r4, r5, pc}
    1a86:	2000      	movs	r0, #0
    1a88:	e7eb      	b.n	1a62 <ringbuffer_get+0xe>
	}

	return ERR_NOT_FOUND;
    1a8a:	f06f 0009 	mvn.w	r0, #9
}
    1a8e:	bd38      	pop	{r3, r4, r5, pc}
    1a90:	00006e1c 	.word	0x00006e1c
    1a94:	000019fd 	.word	0x000019fd

00001a98 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
    1a98:	b510      	push	{r4, lr}
	ASSERT(rb);
    1a9a:	4604      	mov	r4, r0
    1a9c:	2267      	movs	r2, #103	; 0x67
    1a9e:	4905      	ldr	r1, [pc, #20]	; (1ab4 <ringbuffer_num+0x1c>)
    1aa0:	3000      	adds	r0, #0
    1aa2:	bf18      	it	ne
    1aa4:	2001      	movne	r0, #1
    1aa6:	4b04      	ldr	r3, [pc, #16]	; (1ab8 <ringbuffer_num+0x20>)
    1aa8:	4798      	blx	r3

	return rb->write_index - rb->read_index;
    1aaa:	68e0      	ldr	r0, [r4, #12]
    1aac:	68a3      	ldr	r3, [r4, #8]
}
    1aae:	1ac0      	subs	r0, r0, r3
    1ab0:	bd10      	pop	{r4, pc}
    1ab2:	bf00      	nop
    1ab4:	00006e1c 	.word	0x00006e1c
    1ab8:	000019fd 	.word	0x000019fd

00001abc <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    1abc:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    1abe:	4a06      	ldr	r2, [pc, #24]	; (1ad8 <_sbrk+0x1c>)
    1ac0:	6812      	ldr	r2, [r2, #0]
    1ac2:	b122      	cbz	r2, 1ace <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    1ac4:	4a04      	ldr	r2, [pc, #16]	; (1ad8 <_sbrk+0x1c>)
    1ac6:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    1ac8:	4403      	add	r3, r0
    1aca:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
    1acc:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    1ace:	4903      	ldr	r1, [pc, #12]	; (1adc <_sbrk+0x20>)
    1ad0:	4a01      	ldr	r2, [pc, #4]	; (1ad8 <_sbrk+0x1c>)
    1ad2:	6011      	str	r1, [r2, #0]
    1ad4:	e7f6      	b.n	1ac4 <_sbrk+0x8>
    1ad6:	bf00      	nop
    1ad8:	2000031c 	.word	0x2000031c
    1adc:	2001eb18 	.word	0x2001eb18

00001ae0 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    1ae0:	f04f 30ff 	mov.w	r0, #4294967295
    1ae4:	4770      	bx	lr

00001ae6 <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    1ae6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    1aea:	604b      	str	r3, [r1, #4]

	return 0;
}
    1aec:	2000      	movs	r0, #0
    1aee:	4770      	bx	lr

00001af0 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    1af0:	2001      	movs	r0, #1
    1af2:	4770      	bx	lr

00001af4 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    1af4:	2000      	movs	r0, #0
    1af6:	4770      	bx	lr

00001af8 <_adc_init>:
 *
 * \param[in] hw The pointer to hardware instance
 * \param[in] i The number of hardware instance
 */
static int32_t _adc_init(void *const hw, const uint8_t i)
{
    1af8:	b410      	push	{r4}
	uint16_t calib_reg = 0;
	if (hw == ADC0) {
    1afa:	4b5e      	ldr	r3, [pc, #376]	; (1c74 <_adc_init+0x17c>)
    1afc:	4298      	cmp	r0, r3
    1afe:	f000 809c 	beq.w	1c3a <_adc_init+0x142>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
	} else if (hw == ADC1) {
    1b02:	4b5d      	ldr	r3, [pc, #372]	; (1c78 <_adc_init+0x180>)
    1b04:	4298      	cmp	r0, r3
    1b06:	f000 80a6 	beq.w	1c56 <_adc_init+0x15e>
	uint16_t calib_reg = 0;
    1b0a:	2200      	movs	r2, #0
	};
}

static inline bool hri_adc_is_syncing(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
    1b0c:	6b03      	ldr	r3, [r0, #48]	; 0x30
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
	}

	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
    1b0e:	f013 0f01 	tst.w	r3, #1
    1b12:	d11b      	bne.n	1b4c <_adc_init+0x54>
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1b14:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b16:	f013 0f03 	tst.w	r3, #3
    1b1a:	d1fb      	bne.n	1b14 <_adc_init+0x1c>

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	tmp = ((Adc *)hw)->CTRLA.reg;
    1b1c:	8803      	ldrh	r3, [r0, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
    1b1e:	f013 0f02 	tst.w	r3, #2
    1b22:	d00d      	beq.n	1b40 <_adc_init+0x48>
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
    1b24:	8803      	ldrh	r3, [r0, #0]
    1b26:	f023 0302 	bic.w	r3, r3, #2
    1b2a:	041b      	lsls	r3, r3, #16
    1b2c:	0c1b      	lsrs	r3, r3, #16
    1b2e:	8003      	strh	r3, [r0, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1b30:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b32:	f013 0f03 	tst.w	r3, #3
    1b36:	d1fb      	bne.n	1b30 <_adc_init+0x38>
    1b38:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b3a:	f013 0f02 	tst.w	r3, #2
    1b3e:	d1fb      	bne.n	1b38 <_adc_init+0x40>
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
    1b40:	2301      	movs	r3, #1
    1b42:	8003      	strh	r3, [r0, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1b44:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b46:	f013 0f03 	tst.w	r3, #3
    1b4a:	d1fb      	bne.n	1b44 <_adc_init+0x4c>
    1b4c:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b4e:	f013 0f01 	tst.w	r3, #1
    1b52:	d1fb      	bne.n	1b4c <_adc_init+0x54>
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
    1b54:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
		hri_adc_write_CTRLA_reg(hw, ADC_CTRLA_SWRST);
	}
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);

	hri_adc_write_CALIB_reg(hw, calib_reg);
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
    1b58:	2316      	movs	r3, #22
    1b5a:	4a48      	ldr	r2, [pc, #288]	; (1c7c <_adc_init+0x184>)
    1b5c:	fb03 2301 	mla	r3, r3, r1, r2
    1b60:	889b      	ldrh	r3, [r3, #4]
	((Adc *)hw)->CTRLB.reg = data;
    1b62:	80c3      	strh	r3, [r0, #6]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1b64:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b66:	f3c3 030b 	ubfx	r3, r3, #0, #12
    1b6a:	2b00      	cmp	r3, #0
    1b6c:	d1fa      	bne.n	1b64 <_adc_init+0x6c>
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
    1b6e:	2316      	movs	r3, #22
    1b70:	4a42      	ldr	r2, [pc, #264]	; (1c7c <_adc_init+0x184>)
    1b72:	fb03 2301 	mla	r3, r3, r1, r2
    1b76:	799b      	ldrb	r3, [r3, #6]
	((Adc *)hw)->REFCTRL.reg = data;
    1b78:	7203      	strb	r3, [r0, #8]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1b7a:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b7c:	f3c3 030b 	ubfx	r3, r3, #0, #12
    1b80:	2b00      	cmp	r3, #0
    1b82:	d1fa      	bne.n	1b7a <_adc_init+0x82>
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
    1b84:	2316      	movs	r3, #22
    1b86:	4a3d      	ldr	r2, [pc, #244]	; (1c7c <_adc_init+0x184>)
    1b88:	fb03 2301 	mla	r3, r3, r1, r2
    1b8c:	79da      	ldrb	r2, [r3, #7]
	((Adc *)hw)->EVCTRL.reg = data;
    1b8e:	7082      	strb	r2, [r0, #2]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
    1b90:	891b      	ldrh	r3, [r3, #8]
	((Adc *)hw)->INPUTCTRL.reg = data;
    1b92:	8083      	strh	r3, [r0, #4]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1b94:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1b96:	f3c3 030b 	ubfx	r3, r3, #0, #12
    1b9a:	2b00      	cmp	r3, #0
    1b9c:	d1fa      	bne.n	1b94 <_adc_init+0x9c>
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
    1b9e:	2316      	movs	r3, #22
    1ba0:	4a36      	ldr	r2, [pc, #216]	; (1c7c <_adc_init+0x184>)
    1ba2:	fb03 2301 	mla	r3, r3, r1, r2
    1ba6:	7a9b      	ldrb	r3, [r3, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
    1ba8:	7283      	strb	r3, [r0, #10]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1baa:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1bac:	f3c3 030b 	ubfx	r3, r3, #0, #12
    1bb0:	2b00      	cmp	r3, #0
    1bb2:	d1fa      	bne.n	1baa <_adc_init+0xb2>
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
    1bb4:	2316      	movs	r3, #22
    1bb6:	4a31      	ldr	r2, [pc, #196]	; (1c7c <_adc_init+0x184>)
    1bb8:	fb03 2301 	mla	r3, r3, r1, r2
    1bbc:	7adb      	ldrb	r3, [r3, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
    1bbe:	72c3      	strb	r3, [r0, #11]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1bc0:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1bc2:	f3c3 030b 	ubfx	r3, r3, #0, #12
    1bc6:	2b00      	cmp	r3, #0
    1bc8:	d1fa      	bne.n	1bc0 <_adc_init+0xc8>
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
    1bca:	2316      	movs	r3, #22
    1bcc:	4a2b      	ldr	r2, [pc, #172]	; (1c7c <_adc_init+0x184>)
    1bce:	fb03 2301 	mla	r3, r3, r1, r2
    1bd2:	899b      	ldrh	r3, [r3, #12]
	((Adc *)hw)->WINLT.reg = data;
    1bd4:	8183      	strh	r3, [r0, #12]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1bd6:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1bd8:	f013 0f80 	tst.w	r3, #128	; 0x80
    1bdc:	d1fb      	bne.n	1bd6 <_adc_init+0xde>
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
    1bde:	2316      	movs	r3, #22
    1be0:	4a26      	ldr	r2, [pc, #152]	; (1c7c <_adc_init+0x184>)
    1be2:	fb03 2301 	mla	r3, r3, r1, r2
    1be6:	89db      	ldrh	r3, [r3, #14]
	((Adc *)hw)->WINUT.reg = data;
    1be8:	81c3      	strh	r3, [r0, #14]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1bea:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1bec:	f413 7f80 	tst.w	r3, #256	; 0x100
    1bf0:	d1fb      	bne.n	1bea <_adc_init+0xf2>
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
    1bf2:	2316      	movs	r3, #22
    1bf4:	4a21      	ldr	r2, [pc, #132]	; (1c7c <_adc_init+0x184>)
    1bf6:	fb03 2301 	mla	r3, r3, r1, r2
    1bfa:	8a1b      	ldrh	r3, [r3, #16]
	((Adc *)hw)->GAINCORR.reg = data;
    1bfc:	8203      	strh	r3, [r0, #16]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1bfe:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1c00:	f413 7f00 	tst.w	r3, #512	; 0x200
    1c04:	d1fb      	bne.n	1bfe <_adc_init+0x106>
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
    1c06:	2316      	movs	r3, #22
    1c08:	4a1c      	ldr	r2, [pc, #112]	; (1c7c <_adc_init+0x184>)
    1c0a:	fb03 2301 	mla	r3, r3, r1, r2
    1c0e:	8a5b      	ldrh	r3, [r3, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
    1c10:	8243      	strh	r3, [r0, #18]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1c12:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1c14:	f413 6f80 	tst.w	r3, #1024	; 0x400
    1c18:	d1fb      	bne.n	1c12 <_adc_init+0x11a>
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
    1c1a:	2216      	movs	r2, #22
    1c1c:	4b17      	ldr	r3, [pc, #92]	; (1c7c <_adc_init+0x184>)
    1c1e:	fb02 3101 	mla	r1, r2, r1, r3
    1c22:	7d0b      	ldrb	r3, [r1, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
    1c24:	70c3      	strb	r3, [r0, #3]
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
    1c26:	884b      	ldrh	r3, [r1, #2]
	((Adc *)hw)->CTRLA.reg = data;
    1c28:	8003      	strh	r3, [r0, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1c2a:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1c2c:	f013 0f03 	tst.w	r3, #3
    1c30:	d1fb      	bne.n	1c2a <_adc_init+0x132>

	return ERR_NONE;
}
    1c32:	2000      	movs	r0, #0
    1c34:	f85d 4b04 	ldr.w	r4, [sp], #4
    1c38:	4770      	bx	lr
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    1c3a:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    1c3e:	681b      	ldr	r3, [r3, #0]
    1c40:	00da      	lsls	r2, r3, #3
    1c42:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
    1c46:	091c      	lsrs	r4, r3, #4
    1c48:	f004 0470 	and.w	r4, r4, #112	; 0x70
    1c4c:	4322      	orrs	r2, r4
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
    1c4e:	f3c3 0382 	ubfx	r3, r3, #2, #3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    1c52:	431a      	orrs	r2, r3
    1c54:	e75a      	b.n	1b0c <_adc_init+0x14>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    1c56:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    1c5a:	681b      	ldr	r3, [r3, #0]
    1c5c:	0ada      	lsrs	r2, r3, #11
    1c5e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
    1c62:	0c9c      	lsrs	r4, r3, #18
    1c64:	f004 0470 	and.w	r4, r4, #112	; 0x70
    1c68:	4322      	orrs	r2, r4
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
    1c6a:	f3c3 4302 	ubfx	r3, r3, #16, #3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    1c6e:	431a      	orrs	r2, r3
    1c70:	e74c      	b.n	1b0c <_adc_init+0x14>
    1c72:	bf00      	nop
    1c74:	43001c00 	.word	0x43001c00
    1c78:	43002000 	.word	0x43002000
    1c7c:	00006e40 	.word	0x00006e40

00001c80 <_adc_get_regs>:
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
    1c80:	f100 403d 	add.w	r0, r0, #3170893824	; 0xbd000000
    1c84:	f5a0 50e0 	sub.w	r0, r0, #7168	; 0x1c00
		if (_adcs[i].number == n) {
    1c88:	f3c0 2087 	ubfx	r0, r0, #10, #8
    1c8c:	2801      	cmp	r0, #1
    1c8e:	d007      	beq.n	1ca0 <_adc_get_regs+0x20>
{
    1c90:	b508      	push	{r3, lr}
	ASSERT(false);
    1c92:	2288      	movs	r2, #136	; 0x88
    1c94:	4903      	ldr	r1, [pc, #12]	; (1ca4 <_adc_get_regs+0x24>)
    1c96:	2000      	movs	r0, #0
    1c98:	4b03      	ldr	r3, [pc, #12]	; (1ca8 <_adc_get_regs+0x28>)
    1c9a:	4798      	blx	r3
}
    1c9c:	2000      	movs	r0, #0
    1c9e:	bd08      	pop	{r3, pc}
    1ca0:	2000      	movs	r0, #0
    1ca2:	4770      	bx	lr
    1ca4:	00006e58 	.word	0x00006e58
    1ca8:	000019fd 	.word	0x000019fd

00001cac <_adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_sync_init(struct _adc_sync_device *const device, void *const hw)
{
    1cac:	b538      	push	{r3, r4, r5, lr}
    1cae:	460c      	mov	r4, r1
	ASSERT(device);
    1cb0:	4605      	mov	r5, r0
    1cb2:	22d9      	movs	r2, #217	; 0xd9
    1cb4:	4907      	ldr	r1, [pc, #28]	; (1cd4 <_adc_sync_init+0x28>)
    1cb6:	3000      	adds	r0, #0
    1cb8:	bf18      	it	ne
    1cba:	2001      	movne	r0, #1
    1cbc:	4b06      	ldr	r3, [pc, #24]	; (1cd8 <_adc_sync_init+0x2c>)
    1cbe:	4798      	blx	r3

	device->hw = hw;
    1cc0:	602c      	str	r4, [r5, #0]

	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    1cc2:	4620      	mov	r0, r4
    1cc4:	4b05      	ldr	r3, [pc, #20]	; (1cdc <_adc_sync_init+0x30>)
    1cc6:	4798      	blx	r3
    1cc8:	4601      	mov	r1, r0
    1cca:	4620      	mov	r0, r4
    1ccc:	4b04      	ldr	r3, [pc, #16]	; (1ce0 <_adc_sync_init+0x34>)
    1cce:	4798      	blx	r3
}
    1cd0:	bd38      	pop	{r3, r4, r5, pc}
    1cd2:	bf00      	nop
    1cd4:	00006e58 	.word	0x00006e58
    1cd8:	000019fd 	.word	0x000019fd
    1cdc:	00001c81 	.word	0x00001c81
    1ce0:	00001af9 	.word	0x00001af9

00001ce4 <_adc_sync_enable_channel>:
 */
void _adc_sync_enable_channel(struct _adc_sync_device *const device, const uint8_t channel)
{
	(void)channel;

	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
    1ce4:	6802      	ldr	r2, [r0, #0]
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
    1ce6:	8813      	ldrh	r3, [r2, #0]
    1ce8:	b29b      	uxth	r3, r3
    1cea:	f043 0302 	orr.w	r3, r3, #2
    1cee:	8013      	strh	r3, [r2, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1cf0:	6b13      	ldr	r3, [r2, #48]	; 0x30
    1cf2:	f013 0f03 	tst.w	r3, #3
    1cf6:	d1fb      	bne.n	1cf0 <_adc_sync_enable_channel+0xc>
}
    1cf8:	4770      	bx	lr

00001cfa <_adc_sync_get_data_size>:
/**
 * \brief Retrieve ADC conversion data size
 */
uint8_t _adc_sync_get_data_size(const struct _adc_sync_device *const device)
{
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
    1cfa:	6803      	ldr	r3, [r0, #0]
	tmp = ((Adc *)hw)->CTRLB.reg;
    1cfc:	88db      	ldrh	r3, [r3, #6]
    1cfe:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    1d02:	2b03      	cmp	r3, #3
}
    1d04:	bf0c      	ite	eq
    1d06:	2001      	moveq	r0, #1
    1d08:	2002      	movne	r0, #2
    1d0a:	4770      	bx	lr

00001d0c <_adc_sync_is_channel_conversion_done>:
 */
bool _adc_sync_is_channel_conversion_done(const struct _adc_sync_device *const device, const uint8_t channel)
{
	(void)channel;

	return hri_adc_get_interrupt_RESRDY_bit(device->hw);
    1d0c:	6803      	ldr	r3, [r0, #0]
	return (((Adc *)hw)->INTFLAG.reg & ADC_INTFLAG_RESRDY) >> ADC_INTFLAG_RESRDY_Pos;
    1d0e:	f893 002e 	ldrb.w	r0, [r3, #46]	; 0x2e
}
    1d12:	f000 0001 	and.w	r0, r0, #1
    1d16:	4770      	bx	lr

00001d18 <_adc_sync_convert>:
/**
 * \brief Make conversion
 */
void _adc_sync_convert(struct _adc_sync_device *const device)
{
	hri_adc_set_SWTRIG_START_bit(device->hw);
    1d18:	6802      	ldr	r2, [r0, #0]
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
    1d1a:	7d13      	ldrb	r3, [r2, #20]
    1d1c:	f043 0302 	orr.w	r3, r3, #2
    1d20:	7513      	strb	r3, [r2, #20]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1d22:	6b13      	ldr	r3, [r2, #48]	; 0x30
    1d24:	f3c3 030b 	ubfx	r3, r3, #0, #12
    1d28:	2b00      	cmp	r3, #0
    1d2a:	d1fa      	bne.n	1d22 <_adc_sync_convert+0xa>
}
    1d2c:	4770      	bx	lr

00001d2e <_adc_sync_read_channel_data>:
 */
uint16_t _adc_sync_read_channel_data(const struct _adc_sync_device *const device, const uint8_t channel)
{
	(void)channel;

	return hri_adc_read_RESULT_reg(device->hw);
    1d2e:	6803      	ldr	r3, [r0, #0]
	return ((Adc *)hw)->RESULT.reg;
    1d30:	f8b3 0040 	ldrh.w	r0, [r3, #64]	; 0x40
}
    1d34:	b280      	uxth	r0, r0
    1d36:	4770      	bx	lr

00001d38 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    1d38:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    1d3a:	4a0d      	ldr	r2, [pc, #52]	; (1d70 <_init_chip+0x38>)
    1d3c:	8813      	ldrh	r3, [r2, #0]
    1d3e:	b29b      	uxth	r3, r3
    1d40:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    1d42:	4b0c      	ldr	r3, [pc, #48]	; (1d74 <_init_chip+0x3c>)
    1d44:	4798      	blx	r3
	_oscctrl_init_sources();
    1d46:	4b0c      	ldr	r3, [pc, #48]	; (1d78 <_init_chip+0x40>)
    1d48:	4798      	blx	r3
	_mclk_init();
    1d4a:	4b0c      	ldr	r3, [pc, #48]	; (1d7c <_init_chip+0x44>)
    1d4c:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    1d4e:	2008      	movs	r0, #8
    1d50:	4c0b      	ldr	r4, [pc, #44]	; (1d80 <_init_chip+0x48>)
    1d52:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    1d54:	4b0b      	ldr	r3, [pc, #44]	; (1d84 <_init_chip+0x4c>)
    1d56:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1d58:	f640 70f7 	movw	r0, #4087	; 0xff7
    1d5c:	47a0      	blx	r4
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_DMAC;
    1d5e:	4a0a      	ldr	r2, [pc, #40]	; (1d88 <_init_chip+0x50>)
    1d60:	6913      	ldr	r3, [r2, #16]
    1d62:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    1d66:	6113      	str	r3, [r2, #16]

#if CONF_DMAC_ENABLE
	hri_mclk_set_AHBMASK_DMAC_bit(MCLK);
	_dma_init();
    1d68:	4b08      	ldr	r3, [pc, #32]	; (1d8c <_init_chip+0x54>)
    1d6a:	4798      	blx	r3
    1d6c:	bd10      	pop	{r4, pc}
    1d6e:	bf00      	nop
    1d70:	41004000 	.word	0x41004000
    1d74:	0000230d 	.word	0x0000230d
    1d78:	00002321 	.word	0x00002321
    1d7c:	00002201 	.word	0x00002201
    1d80:	00002075 	.word	0x00002075
    1d84:	00002325 	.word	0x00002325
    1d88:	40000800 	.word	0x40000800
    1d8c:	00001f5d 	.word	0x00001f5d

00001d90 <_dac_init>:
 * \param[in] hw The pointer to DAC hardware instance
 *
 * \return The status of initialization
 */
static int32_t _dac_init(void *const hw)
{
    1d90:	b510      	push	{r4, lr}
    1d92:	4604      	mov	r4, r0
	ASSERT(hw == DAC);
    1d94:	22e5      	movs	r2, #229	; 0xe5
    1d96:	491e      	ldr	r1, [pc, #120]	; (1e10 <_dac_init+0x80>)
    1d98:	481e      	ldr	r0, [pc, #120]	; (1e14 <_dac_init+0x84>)
    1d9a:	4284      	cmp	r4, r0
    1d9c:	bf14      	ite	ne
    1d9e:	2000      	movne	r0, #0
    1da0:	2001      	moveq	r0, #1
    1da2:	4b1d      	ldr	r3, [pc, #116]	; (1e18 <_dac_init+0x88>)
    1da4:	4798      	blx	r3
	};
}

static inline bool hri_dac_is_syncing(const void *const hw, hri_dac_syncbusy_reg_t reg)
{
	return ((Dac *)hw)->SYNCBUSY.reg & reg;
    1da6:	68a3      	ldr	r3, [r4, #8]

	if (!hri_dac_is_syncing(hw, DAC_SYNCBUSY_SWRST)) {
    1da8:	f013 0f01 	tst.w	r3, #1
    1dac:	d119      	bne.n	1de2 <_dac_init+0x52>
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1dae:	68a3      	ldr	r3, [r4, #8]
    1db0:	f013 0f03 	tst.w	r3, #3
    1db4:	d1fb      	bne.n	1dae <_dac_init+0x1e>

static inline hri_dac_ctrla_reg_t hri_dac_get_CTRLA_reg(const void *const hw, hri_dac_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_dac_wait_for_sync(hw, DAC_SYNCBUSY_SWRST | DAC_SYNCBUSY_ENABLE);
	tmp = ((Dac *)hw)->CTRLA.reg;
    1db6:	7823      	ldrb	r3, [r4, #0]
		if (hri_dac_get_CTRLA_reg(hw, DAC_CTRLA_ENABLE)) {
    1db8:	f013 0f02 	tst.w	r3, #2
    1dbc:	d00b      	beq.n	1dd6 <_dac_init+0x46>
	((Dac *)hw)->CTRLA.reg &= ~DAC_CTRLA_ENABLE;
    1dbe:	7823      	ldrb	r3, [r4, #0]
    1dc0:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    1dc4:	7023      	strb	r3, [r4, #0]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1dc6:	68a3      	ldr	r3, [r4, #8]
    1dc8:	f013 0f03 	tst.w	r3, #3
    1dcc:	d1fb      	bne.n	1dc6 <_dac_init+0x36>
    1dce:	68a3      	ldr	r3, [r4, #8]
    1dd0:	f013 0f02 	tst.w	r3, #2
    1dd4:	d1fb      	bne.n	1dce <_dac_init+0x3e>
}

static inline void hri_dac_write_CTRLA_reg(const void *const hw, hri_dac_ctrla_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->CTRLA.reg = data;
    1dd6:	2301      	movs	r3, #1
    1dd8:	7023      	strb	r3, [r4, #0]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1dda:	68a3      	ldr	r3, [r4, #8]
    1ddc:	f013 0f03 	tst.w	r3, #3
    1de0:	d1fb      	bne.n	1dda <_dac_init+0x4a>
    1de2:	68a3      	ldr	r3, [r4, #8]
    1de4:	f013 0f01 	tst.w	r3, #1
    1de8:	d1fb      	bne.n	1de2 <_dac_init+0x52>
}

static inline void hri_dac_write_CTRLB_reg(const void *const hw, hri_dac_ctrlb_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->CTRLB.reg = data;
    1dea:	2300      	movs	r3, #0
    1dec:	7063      	strb	r3, [r4, #1]
}

static inline void hri_dac_write_EVCTRL_reg(const void *const hw, hri_dac_evctrl_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->EVCTRL.reg = data;
    1dee:	70a3      	strb	r3, [r4, #2]
}

static inline void hri_dac_write_DACCTRL_reg(const void *const hw, uint8_t index, hri_dac_dacctrl_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->DACCTRL[index].reg = data;
    1df0:	81a3      	strh	r3, [r4, #12]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1df2:	68a3      	ldr	r3, [r4, #8]
    1df4:	f013 0f02 	tst.w	r3, #2
    1df8:	d1fb      	bne.n	1df2 <_dac_init+0x62>
	((Dac *)hw)->DACCTRL[index].reg = data;
    1dfa:	2300      	movs	r3, #0
    1dfc:	81e3      	strh	r3, [r4, #14]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1dfe:	68a3      	ldr	r3, [r4, #8]
    1e00:	f013 0f02 	tst.w	r3, #2
    1e04:	d1fb      	bne.n	1dfe <_dac_init+0x6e>
}

static inline void hri_dac_write_DBGCTRL_reg(const void *const hw, hri_dac_dbgctrl_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->DBGCTRL.reg = data;
    1e06:	2301      	movs	r3, #1
    1e08:	7623      	strb	r3, [r4, #24]
	hri_dac_write_DACCTRL_reg(hw, 0, _dac.dac_ctrl0);
	hri_dac_write_DACCTRL_reg(hw, 1, _dac.dac_ctrl1);
	hri_dac_write_DBGCTRL_reg(hw, _dac.dbg_ctrl);

	return ERR_NONE;
}
    1e0a:	2000      	movs	r0, #0
    1e0c:	bd10      	pop	{r4, pc}
    1e0e:	bf00      	nop
    1e10:	00006e70 	.word	0x00006e70
    1e14:	43002400 	.word	0x43002400
    1e18:	000019fd 	.word	0x000019fd

00001e1c <_dac_sync_init>:
{
    1e1c:	b538      	push	{r3, r4, r5, lr}
    1e1e:	460c      	mov	r4, r1
	ASSERT(device);
    1e20:	4605      	mov	r5, r0
    1e22:	2253      	movs	r2, #83	; 0x53
    1e24:	4905      	ldr	r1, [pc, #20]	; (1e3c <_dac_sync_init+0x20>)
    1e26:	3000      	adds	r0, #0
    1e28:	bf18      	it	ne
    1e2a:	2001      	movne	r0, #1
    1e2c:	4b04      	ldr	r3, [pc, #16]	; (1e40 <_dac_sync_init+0x24>)
    1e2e:	4798      	blx	r3
	device->hw = hw;
    1e30:	602c      	str	r4, [r5, #0]
	return _dac_init(device->hw);
    1e32:	4620      	mov	r0, r4
    1e34:	4b03      	ldr	r3, [pc, #12]	; (1e44 <_dac_sync_init+0x28>)
    1e36:	4798      	blx	r3
}
    1e38:	bd38      	pop	{r3, r4, r5, pc}
    1e3a:	bf00      	nop
    1e3c:	00006e70 	.word	0x00006e70
    1e40:	000019fd 	.word	0x000019fd
    1e44:	00001d91 	.word	0x00001d91

00001e48 <_dac_sync_enable_channel>:
{
    1e48:	b538      	push	{r3, r4, r5, lr}
    1e4a:	460d      	mov	r5, r1
	_dac_enable_channel(device->hw, ch);
    1e4c:	6804      	ldr	r4, [r0, #0]
 * \param[in] hw The pointer to hardware instance
 * \param[in] ch The channel to enable
 */
static inline void _dac_enable_channel(void *const hw, const uint8_t ch)
{
	ASSERT(ch <= 1);
    1e4e:	f44f 7286 	mov.w	r2, #268	; 0x10c
    1e52:	4916      	ldr	r1, [pc, #88]	; (1eac <_dac_sync_enable_channel+0x64>)
    1e54:	2d01      	cmp	r5, #1
    1e56:	bf8c      	ite	hi
    1e58:	2000      	movhi	r0, #0
    1e5a:	2001      	movls	r0, #1
    1e5c:	4b14      	ldr	r3, [pc, #80]	; (1eb0 <_dac_sync_enable_channel+0x68>)
    1e5e:	4798      	blx	r3
	((Dac *)hw)->CTRLA.reg &= ~DAC_CTRLA_ENABLE;
    1e60:	7823      	ldrb	r3, [r4, #0]
    1e62:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    1e66:	7023      	strb	r3, [r4, #0]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1e68:	68a3      	ldr	r3, [r4, #8]
    1e6a:	f013 0f03 	tst.w	r3, #3
    1e6e:	d1fb      	bne.n	1e68 <_dac_sync_enable_channel+0x20>
    1e70:	eb04 0245 	add.w	r2, r4, r5, lsl #1
	((Dac *)hw)->DACCTRL[index].reg |= DAC_DACCTRL_ENABLE;
    1e74:	8993      	ldrh	r3, [r2, #12]
    1e76:	b29b      	uxth	r3, r3
    1e78:	f043 0302 	orr.w	r3, r3, #2
    1e7c:	8193      	strh	r3, [r2, #12]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1e7e:	68a3      	ldr	r3, [r4, #8]
    1e80:	f013 0f02 	tst.w	r3, #2
    1e84:	d1fb      	bne.n	1e7e <_dac_sync_enable_channel+0x36>
	((Dac *)hw)->CTRLA.reg |= DAC_CTRLA_ENABLE;
    1e86:	7823      	ldrb	r3, [r4, #0]
    1e88:	f043 0302 	orr.w	r3, r3, #2
    1e8c:	7023      	strb	r3, [r4, #0]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1e8e:	68a3      	ldr	r3, [r4, #8]
    1e90:	f013 0f03 	tst.w	r3, #3
    1e94:	d1fb      	bne.n	1e8e <_dac_sync_enable_channel+0x46>

	hri_dac_clear_CTRLA_ENABLE_bit(hw);
	hri_dac_set_DACCTRL_ENABLE_bit(hw, ch);
	hri_dac_set_CTRLA_ENABLE_bit(hw);

	if (0 == ch) {
    1e96:	b925      	cbnz	r5, 1ea2 <_dac_sync_enable_channel+0x5a>
	return (((Dac *)hw)->STATUS.reg & DAC_STATUS_READY0) >> DAC_STATUS_READY0_Pos;
    1e98:	79e3      	ldrb	r3, [r4, #7]
		while (!hri_dac_get_STATUS_READY0_bit(hw))
    1e9a:	f013 0f01 	tst.w	r3, #1
    1e9e:	d0fb      	beq.n	1e98 <_dac_sync_enable_channel+0x50>
    1ea0:	bd38      	pop	{r3, r4, r5, pc}
	return (((Dac *)hw)->STATUS.reg & DAC_STATUS_READY1) >> DAC_STATUS_READY1_Pos;
    1ea2:	79e3      	ldrb	r3, [r4, #7]
			;
	} else {
		while (!hri_dac_get_STATUS_READY1_bit(hw))
    1ea4:	f013 0f02 	tst.w	r3, #2
    1ea8:	d0fb      	beq.n	1ea2 <_dac_sync_enable_channel+0x5a>
    1eaa:	bd38      	pop	{r3, r4, r5, pc}
    1eac:	00006e70 	.word	0x00006e70
    1eb0:	000019fd 	.word	0x000019fd

00001eb4 <_dac_sync_is_channel_enable>:
 * \param[in] hw The pointer to hardware instance
 * \param[in] ch The channel to check
 */
static inline bool _dac_is_channel_enabled(void *const hw, const uint8_t ch)
{
	if (ch <= 1) {
    1eb4:	2901      	cmp	r1, #1
    1eb6:	d901      	bls.n	1ebc <_dac_sync_is_channel_enable+0x8>
		return hri_dac_get_DACCTRL_ENABLE_bit(hw, ch);
	}

	return false;
    1eb8:	2000      	movs	r0, #0
}
    1eba:	4770      	bx	lr
	return _dac_is_channel_enabled(device->hw, ch);
    1ebc:	6802      	ldr	r2, [r0, #0]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1ebe:	6893      	ldr	r3, [r2, #8]
    1ec0:	f013 0f02 	tst.w	r3, #2
    1ec4:	d1fb      	bne.n	1ebe <_dac_sync_is_channel_enable+0xa>
	tmp = ((Dac *)hw)->DACCTRL[index].reg;
    1ec6:	3104      	adds	r1, #4
    1ec8:	eb02 0241 	add.w	r2, r2, r1, lsl #1
    1ecc:	8890      	ldrh	r0, [r2, #4]
	return (bool)tmp;
    1ece:	f3c0 0040 	ubfx	r0, r0, #1, #1
    1ed2:	4770      	bx	lr

00001ed4 <_dac_sync_write_data>:
	hri_dac_write_DATA_reg(device->hw, ch, data);
    1ed4:	6800      	ldr	r0, [r0, #0]
}

static inline void hri_dac_write_DATA_reg(const void *const hw, uint8_t index, hri_dac_data_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->DATA[index].reg = data;
    1ed6:	3208      	adds	r2, #8
    1ed8:	f820 1012 	strh.w	r1, [r0, r2, lsl #1]
	while (((Dac *)hw)->SYNCBUSY.reg & reg) {
    1edc:	6883      	ldr	r3, [r0, #8]
    1ede:	f013 0f0c 	tst.w	r3, #12
    1ee2:	d1fb      	bne.n	1edc <_dac_sync_write_data+0x8>
}
    1ee4:	4770      	bx	lr
	...

00001ee8 <_dmac_handler>:
}
/**
 * \internal DMAC interrupt handler
 */
static void _dmac_handler(void)
{
    1ee8:	b508      	push	{r3, lr}
}

static inline hri_dmac_intpend_reg_t hri_dmac_get_INTPEND_reg(const void *const hw, hri_dmac_intpend_reg_t mask)
{
	uint16_t tmp;
	tmp = ((Dmac *)hw)->INTPEND.reg;
    1eea:	4a1a      	ldr	r2, [pc, #104]	; (1f54 <_dmac_handler+0x6c>)
    1eec:	8c13      	ldrh	r3, [r2, #32]
	uint8_t               channel      = hri_dmac_get_INTPEND_reg(DMAC, DMAC_INTPEND_ID_Msk);
    1eee:	f003 031f 	and.w	r3, r3, #31
	struct _dma_resource *tmp_resource = &_resources[channel];
    1ef2:	eb03 0143 	add.w	r1, r3, r3, lsl #1
    1ef6:	4818      	ldr	r0, [pc, #96]	; (1f58 <_dmac_handler+0x70>)
    1ef8:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	return ((DmacChannel *)hw)->CHSTATUS.reg;
}

static inline bool hri_dmac_get_CHINTFLAG_TERR_bit(const void *const hw, uint8_t submodule_index)
{
	return (((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg & DMAC_CHINTFLAG_TERR) >> DMAC_CHINTFLAG_TERR_Pos;
    1efc:	eb02 1203 	add.w	r2, r2, r3, lsl #4
    1f00:	f892 204e 	ldrb.w	r2, [r2, #78]	; 0x4e

	if (hri_dmac_get_CHINTFLAG_TERR_bit(DMAC, channel)) {
    1f04:	f012 0f01 	tst.w	r2, #1
    1f08:	d10a      	bne.n	1f20 <_dmac_handler+0x38>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
}

static inline bool hri_dmac_get_CHINTFLAG_TCMPL_bit(const void *const hw, uint8_t submodule_index)
{
	return (((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg & DMAC_CHINTFLAG_TCMPL) >> DMAC_CHINTFLAG_TCMPL_Pos;
    1f0a:	011a      	lsls	r2, r3, #4
    1f0c:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    1f10:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
    1f14:	f892 204e 	ldrb.w	r2, [r2, #78]	; 0x4e
		hri_dmac_clear_CHINTFLAG_TERR_bit(DMAC, channel);
		tmp_resource->dma_cb.error(tmp_resource);
	} else if (hri_dmac_get_CHINTFLAG_TCMPL_bit(DMAC, channel)) {
    1f18:	f012 0f02 	tst.w	r2, #2
    1f1c:	d10b      	bne.n	1f36 <_dmac_handler+0x4e>
    1f1e:	bd08      	pop	{r3, pc}
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    1f20:	011a      	lsls	r2, r3, #4
    1f22:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    1f26:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
    1f2a:	2101      	movs	r1, #1
    1f2c:	f882 104e 	strb.w	r1, [r2, #78]	; 0x4e
		tmp_resource->dma_cb.error(tmp_resource);
    1f30:	6843      	ldr	r3, [r0, #4]
    1f32:	4798      	blx	r3
    1f34:	bd08      	pop	{r3, pc}
}

static inline void hri_dmac_clear_CHINTFLAG_TCMPL_bit(const void *const hw, uint8_t submodule_index)
{
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    1f36:	011a      	lsls	r2, r3, #4
    1f38:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    1f3c:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
    1f40:	2102      	movs	r1, #2
    1f42:	f882 104e 	strb.w	r1, [r2, #78]	; 0x4e
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    1f46:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1f4a:	4a03      	ldr	r2, [pc, #12]	; (1f58 <_dmac_handler+0x70>)
    1f4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1f50:	4798      	blx	r3
	}
}
    1f52:	e7e4      	b.n	1f1e <_dmac_handler+0x36>
    1f54:	4100a000 	.word	0x4100a000
    1f58:	20000320 	.word	0x20000320

00001f5c <_dma_init>:
{
    1f5c:	b470      	push	{r4, r5, r6}
	((Dmac *)hw)->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    1f5e:	4a31      	ldr	r2, [pc, #196]	; (2024 <_dma_init+0xc8>)
    1f60:	8813      	ldrh	r3, [r2, #0]
    1f62:	f023 0302 	bic.w	r3, r3, #2
    1f66:	041b      	lsls	r3, r3, #16
    1f68:	0c1b      	lsrs	r3, r3, #16
    1f6a:	8013      	strh	r3, [r2, #0]
	((Dmac *)hw)->CRCCTRL.reg &= ~mask;
    1f6c:	8853      	ldrh	r3, [r2, #2]
    1f6e:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    1f72:	041b      	lsls	r3, r3, #16
    1f74:	0c1b      	lsrs	r3, r3, #16
    1f76:	8053      	strh	r3, [r2, #2]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_SWRST;
    1f78:	8813      	ldrh	r3, [r2, #0]
    1f7a:	b29b      	uxth	r3, r3
    1f7c:	f043 0301 	orr.w	r3, r3, #1
    1f80:	8013      	strh	r3, [r2, #0]
	tmp = ((Dmac *)hw)->CTRL.reg;
    1f82:	8813      	ldrh	r3, [r2, #0]
	while (hri_dmac_get_CTRL_SWRST_bit(DMAC))
    1f84:	f013 0f01 	tst.w	r3, #1
    1f88:	d1fb      	bne.n	1f82 <_dma_init+0x26>
	((Dmac *)hw)->CTRL.reg = data;
    1f8a:	4b26      	ldr	r3, [pc, #152]	; (2024 <_dma_init+0xc8>)
    1f8c:	f44f 6270 	mov.w	r2, #3840	; 0xf00
    1f90:	801a      	strh	r2, [r3, #0]
	tmp = ((Dmac *)hw)->DBGCTRL.reg;
    1f92:	7b5a      	ldrb	r2, [r3, #13]
	tmp &= ~DMAC_DBGCTRL_DBGRUN;
    1f94:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Dmac *)hw)->DBGCTRL.reg = tmp;
    1f98:	735a      	strb	r2, [r3, #13]
	((Dmac *)hw)->PRICTRL0.reg = data;
    1f9a:	2100      	movs	r1, #0
    1f9c:	6159      	str	r1, [r3, #20]
	hri_dmac_write_BASEADDR_reg(DMAC, (uint32_t)_descriptor_section);
    1f9e:	4a22      	ldr	r2, [pc, #136]	; (2028 <_dma_init+0xcc>)
	((Dmac *)hw)->BASEADDR.reg = data;
    1fa0:	635a      	str	r2, [r3, #52]	; 0x34
	hri_dmac_write_WRBADDR_reg(DMAC, (uint32_t)_write_back_section);
    1fa2:	4a22      	ldr	r2, [pc, #136]	; (202c <_dma_init+0xd0>)
	((Dmac *)hw)->WRBADDR.reg = data;
    1fa4:	639a      	str	r2, [r3, #56]	; 0x38
    1fa6:	4b22      	ldr	r3, [pc, #136]	; (2030 <_dma_init+0xd4>)
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    1fa8:	4c1f      	ldr	r4, [pc, #124]	; (2028 <_dma_init+0xcc>)
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    1faa:	460e      	mov	r6, r1
		hri_dmac_write_CHCTRLA_reg(DMAC, i, _cfgs[i].ctrla);
    1fac:	681d      	ldr	r5, [r3, #0]
    1fae:	0108      	lsls	r0, r1, #4
    1fb0:	f100 4282 	add.w	r2, r0, #1090519040	; 0x41000000
    1fb4:	f502 4220 	add.w	r2, r2, #40960	; 0xa000

static inline void hri_dmac_write_CHCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                              hri_dmac_chctrla_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg = data;
    1fb8:	6415      	str	r5, [r2, #64]	; 0x40
		hri_dmac_write_CHPRILVL_reg(DMAC, i, _cfgs[i].prilvl);
    1fba:	791d      	ldrb	r5, [r3, #4]

static inline void hri_dmac_write_CHPRILVL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chprilvl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHPRILVL.reg = data;
    1fbc:	f882 5045 	strb.w	r5, [r2, #69]	; 0x45
		hri_dmac_write_CHEVCTRL_reg(DMAC, i, _cfgs[i].evctrl);
    1fc0:	795d      	ldrb	r5, [r3, #5]

static inline void hri_dmac_write_CHEVCTRL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chevctrl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHEVCTRL.reg = data;
    1fc2:	f882 5046 	strb.w	r5, [r2, #70]	; 0x46
		hri_dmacdescriptor_write_BTCTRL_reg(&_descriptor_section[i], _cfgs[i].btctrl);
    1fc6:	88dd      	ldrh	r5, [r3, #6]
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    1fc8:	1822      	adds	r2, r4, r0
    1fca:	5225      	strh	r5, [r4, r0]
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    1fcc:	60d6      	str	r6, [r2, #12]
    1fce:	3101      	adds	r1, #1
    1fd0:	3308      	adds	r3, #8
	for (i = 0; i < DMAC_CH_NUM; i++) {
    1fd2:	2920      	cmp	r1, #32
    1fd4:	d1ea      	bne.n	1fac <_dma_init+0x50>
    1fd6:	231f      	movs	r3, #31
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    1fd8:	2001      	movs	r0, #1
    1fda:	4916      	ldr	r1, [pc, #88]	; (2034 <_dma_init+0xd8>)
		NVIC_DisableIRQ(DMAC_0_IRQn + i);
    1fdc:	b29a      	uxth	r2, r3
  if ((int32_t)(IRQn) >= 0)
    1fde:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    1fe2:	d00b      	beq.n	1ffc <_dma_init+0xa0>
    1fe4:	3301      	adds	r3, #1
	for (i = 0; i < 5; i++) {
    1fe6:	2b24      	cmp	r3, #36	; 0x24
    1fe8:	d1f8      	bne.n	1fdc <_dma_init+0x80>
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_DMAENABLE;
    1fea:	4a0e      	ldr	r2, [pc, #56]	; (2024 <_dma_init+0xc8>)
    1fec:	8813      	ldrh	r3, [r2, #0]
    1fee:	b29b      	uxth	r3, r3
    1ff0:	f043 0302 	orr.w	r3, r3, #2
    1ff4:	8013      	strh	r3, [r2, #0]
}
    1ff6:	2000      	movs	r0, #0
    1ff8:	bc70      	pop	{r4, r5, r6}
    1ffa:	4770      	bx	lr
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    1ffc:	095c      	lsrs	r4, r3, #5
    1ffe:	f002 021f 	and.w	r2, r2, #31
    2002:	fa00 f202 	lsl.w	r2, r0, r2
    2006:	f104 0520 	add.w	r5, r4, #32
    200a:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    200e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2012:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    2016:	f104 0560 	add.w	r5, r4, #96	; 0x60
    201a:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    201e:	f841 2024 	str.w	r2, [r1, r4, lsl #2]
    2022:	e7df      	b.n	1fe4 <_dma_init+0x88>
    2024:	4100a000 	.word	0x4100a000
    2028:	2000e700 	.word	0x2000e700
    202c:	2000e900 	.word	0x2000e900
    2030:	00006e88 	.word	0x00006e88
    2034:	e000e100 	.word	0xe000e100

00002038 <DMAC_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void DMAC_0_Handler(void)
{
    2038:	b508      	push	{r3, lr}
	_dmac_handler();
    203a:	4b01      	ldr	r3, [pc, #4]	; (2040 <DMAC_0_Handler+0x8>)
    203c:	4798      	blx	r3
    203e:	bd08      	pop	{r3, pc}
    2040:	00001ee9 	.word	0x00001ee9

00002044 <DMAC_1_Handler>:
}
/**
 * \brief DMAC interrupt handler
 */
void DMAC_1_Handler(void)
{
    2044:	b508      	push	{r3, lr}
	_dmac_handler();
    2046:	4b01      	ldr	r3, [pc, #4]	; (204c <DMAC_1_Handler+0x8>)
    2048:	4798      	blx	r3
    204a:	bd08      	pop	{r3, pc}
    204c:	00001ee9 	.word	0x00001ee9

00002050 <DMAC_2_Handler>:
}
/**
 * \brief DMAC interrupt handler
 */
void DMAC_2_Handler(void)
{
    2050:	b508      	push	{r3, lr}
	_dmac_handler();
    2052:	4b01      	ldr	r3, [pc, #4]	; (2058 <DMAC_2_Handler+0x8>)
    2054:	4798      	blx	r3
    2056:	bd08      	pop	{r3, pc}
    2058:	00001ee9 	.word	0x00001ee9

0000205c <DMAC_3_Handler>:
}
/**
 * \brief DMAC interrupt handler
 */
void DMAC_3_Handler(void)
{
    205c:	b508      	push	{r3, lr}
	_dmac_handler();
    205e:	4b01      	ldr	r3, [pc, #4]	; (2064 <DMAC_3_Handler+0x8>)
    2060:	4798      	blx	r3
    2062:	bd08      	pop	{r3, pc}
    2064:	00001ee9 	.word	0x00001ee9

00002068 <DMAC_4_Handler>:
}
/**
 * \brief DMAC interrupt handler
 */
void DMAC_4_Handler(void)
{
    2068:	b508      	push	{r3, lr}
	_dmac_handler();
    206a:	4b01      	ldr	r3, [pc, #4]	; (2070 <DMAC_4_Handler+0x8>)
    206c:	4798      	blx	r3
    206e:	bd08      	pop	{r3, pc}
    2070:	00001ee9 	.word	0x00001ee9

00002074 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    2074:	f010 0f01 	tst.w	r0, #1
    2078:	d008      	beq.n	208c <_gclk_init_generators_by_fref+0x18>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    207a:	4a11      	ldr	r2, [pc, #68]	; (20c0 <_gclk_init_generators_by_fref+0x4c>)
    207c:	4b11      	ldr	r3, [pc, #68]	; (20c4 <_gclk_init_generators_by_fref+0x50>)
    207e:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    2080:	4619      	mov	r1, r3
    2082:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    2086:	684b      	ldr	r3, [r1, #4]
    2088:	4213      	tst	r3, r2
    208a:	d1fc      	bne.n	2086 <_gclk_init_generators_by_fref+0x12>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    208c:	f010 0f02 	tst.w	r0, #2
    2090:	d008      	beq.n	20a4 <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    2092:	4a0d      	ldr	r2, [pc, #52]	; (20c8 <_gclk_init_generators_by_fref+0x54>)
    2094:	4b0b      	ldr	r3, [pc, #44]	; (20c4 <_gclk_init_generators_by_fref+0x50>)
    2096:	625a      	str	r2, [r3, #36]	; 0x24
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    2098:	4619      	mov	r1, r3
    209a:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    209e:	684b      	ldr	r3, [r1, #4]
    20a0:	4213      	tst	r3, r2
    20a2:	d1fc      	bne.n	209e <_gclk_init_generators_by_fref+0x2a>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    20a4:	f010 0f08 	tst.w	r0, #8
    20a8:	d008      	beq.n	20bc <_gclk_init_generators_by_fref+0x48>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    20aa:	4a08      	ldr	r2, [pc, #32]	; (20cc <_gclk_init_generators_by_fref+0x58>)
    20ac:	4b05      	ldr	r3, [pc, #20]	; (20c4 <_gclk_init_generators_by_fref+0x50>)
    20ae:	62da      	str	r2, [r3, #44]	; 0x2c
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    20b0:	4619      	mov	r1, r3
    20b2:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    20b6:	684b      	ldr	r3, [r1, #4]
    20b8:	4213      	tst	r3, r2
    20ba:	d1fc      	bne.n	20b6 <_gclk_init_generators_by_fref+0x42>
    20bc:	4770      	bx	lr
    20be:	bf00      	nop
    20c0:	00010107 	.word	0x00010107
    20c4:	40001c00 	.word	0x40001c00
    20c8:	00010106 	.word	0x00010106
    20cc:	00010104 	.word	0x00010104

000020d0 <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    20d0:	b500      	push	{lr}
    20d2:	b083      	sub	sp, #12
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    20d4:	4b14      	ldr	r3, [pc, #80]	; (2128 <GMAC_Handler+0x58>)
    20d6:	6818      	ldr	r0, [r3, #0]
    20d8:	6803      	ldr	r3, [r0, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->TSR.reg;
    20da:	695a      	ldr	r2, [r3, #20]
    20dc:	9201      	str	r2, [sp, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->RSR.reg;
    20de:	6a1a      	ldr	r2, [r3, #32]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    20e0:	9200      	str	r2, [sp, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
	return ((Gmac *)hw)->ISR.reg;
    20e2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    20e4:	9a01      	ldr	r2, [sp, #4]
    20e6:	f012 0f20 	tst.w	r2, #32
    20ea:	d00b      	beq.n	2104 <GMAC_Handler+0x34>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    20ec:	9a01      	ldr	r2, [sp, #4]
	((Gmac *)hw)->TSR.reg = data;
    20ee:	615a      	str	r2, [r3, #20]
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    20f0:	4b0d      	ldr	r3, [pc, #52]	; (2128 <GMAC_Handler+0x58>)
    20f2:	685a      	ldr	r2, [r3, #4]
    20f4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    20f8:	7bdb      	ldrb	r3, [r3, #15]
    20fa:	09db      	lsrs	r3, r3, #7
    20fc:	d002      	beq.n	2104 <GMAC_Handler+0x34>
    20fe:	6843      	ldr	r3, [r0, #4]
    2100:	b103      	cbz	r3, 2104 <GMAC_Handler+0x34>
			_gmac_dev->cb.transmited(_gmac_dev);
    2102:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    2104:	9b00      	ldr	r3, [sp, #0]
    2106:	f013 0f02 	tst.w	r3, #2
    210a:	d004      	beq.n	2116 <GMAC_Handler+0x46>
		if (_gmac_dev->cb.received != NULL) {
    210c:	4b06      	ldr	r3, [pc, #24]	; (2128 <GMAC_Handler+0x58>)
    210e:	6818      	ldr	r0, [r3, #0]
    2110:	6883      	ldr	r3, [r0, #8]
    2112:	b103      	cbz	r3, 2116 <GMAC_Handler+0x46>
			_gmac_dev->cb.received(_gmac_dev);
    2114:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    2116:	4b04      	ldr	r3, [pc, #16]	; (2128 <GMAC_Handler+0x58>)
    2118:	681b      	ldr	r3, [r3, #0]
    211a:	681b      	ldr	r3, [r3, #0]
    211c:	9a00      	ldr	r2, [sp, #0]
	((Gmac *)hw)->RSR.reg = data;
    211e:	621a      	str	r2, [r3, #32]
}
    2120:	b003      	add	sp, #12
    2122:	f85d fb04 	ldr.w	pc, [sp], #4
    2126:	bf00      	nop
    2128:	200004a0 	.word	0x200004a0

0000212c <_mac_async_init>:

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    212c:	b430      	push	{r4, r5}
	dev->hw = hw;
    212e:	6001      	str	r1, [r0, #0]
	((Gmac *)hw)->NCR.reg = data;
    2130:	2310      	movs	r3, #16
    2132:	600b      	str	r3, [r1, #0]
	                       (CONF_GMAC_NCR_LBL ? GMAC_NCR_LBL : 0) | (CONF_GMAC_NCR_MPE ? GMAC_NCR_MPE : 0)
	                           | (CONF_GMAC_NCR_WESTAT ? GMAC_NCR_WESTAT : 0) | (CONF_GMAC_NCR_BP ? GMAC_NCR_BP : 0)
	                           | (CONF_GMAC_NCR_ENPBPR ? GMAC_NCR_ENPBPR : 0)
	                           | (CONF_GMAC_NCR_TXPBPF ? GMAC_NCR_TXPBPF : 0));
	hri_gmac_write_NCFGR_reg(
	    dev->hw,
    2134:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->NCFGR.reg = data;
    2136:	4a28      	ldr	r2, [pc, #160]	; (21d8 <_mac_async_init+0xac>)
    2138:	605a      	str	r2, [r3, #4]
	        | (CONF_GMAC_NCFGR_LFERD ? GMAC_NCFGR_LFERD : 0) | (CONF_GMAC_NCFGR_RFCS ? GMAC_NCFGR_RFCS : 0)
	        | GMAC_NCFGR_CLK(CONF_GMAC_NCFGR_CLK) | (CONF_GMAC_NCFGR_DCPF ? GMAC_NCFGR_DCPF : 0)
	        | (CONF_GMAC_NCFGR_RXCOEN ? GMAC_NCFGR_RXCOEN : 0) | (CONF_GMAC_NCFGR_EFRHD ? GMAC_NCFGR_EFRHD : 0)
	        | (CONF_GMAC_NCFGR_IRXFCS ? GMAC_NCFGR_IRXFCS : 0) | (CONF_GMAC_NCFGR_IPGSEN ? GMAC_NCFGR_IPGSEN : 0)
	        | (CONF_GMAC_NCFGR_RXBP ? GMAC_NCFGR_RXBP : 0) | (CONF_GMAC_NCFGR_IRXER ? GMAC_NCFGR_IRXER : 0));
	hri_gmac_write_UR_reg(dev->hw, (CONF_GMAC_UR_MII ? GMAC_UR_MII : 0));
    213a:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->UR.reg = data;
    213c:	2201      	movs	r2, #1
    213e:	60da      	str	r2, [r3, #12]
	hri_gmac_write_DCFGR_reg(
	    dev->hw,
    2140:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->DCFGR.reg = data;
    2142:	4a26      	ldr	r2, [pc, #152]	; (21dc <_mac_async_init+0xb0>)
    2144:	611a      	str	r2, [r3, #16]
	    GMAC_DCFGR_FBLDO(CONF_GMAC_DCFGR_FBLDO) | (CONF_GMAC_DCFGR_ESMA ? GMAC_DCFGR_ESMA : 0)
	        | (CONF_GMAC_DCFGR_ESPA ? GMAC_DCFGR_ESPA : 0) | GMAC_DCFGR_RXBMS(CONF_GMAC_DCFGR_RXBMS)
	        | (CONF_GMAC_DCFGR_TXPBMS ? GMAC_DCFGR_TXPBMS : 0) | (CONF_GMAC_DCFGR_TXCOEN ? GMAC_DCFGR_TXCOEN : 0)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
    2146:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_WOL_reg(const void *const hw, hri_gmac_wol_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->WOL.reg = data;
    2148:	2300      	movs	r3, #0
    214a:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
    214e:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    2150:	f240 1101 	movw	r1, #257	; 0x101
    2154:	f8c2 10bc 	str.w	r1, [r2, #188]	; 0xbc
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    2158:	4921      	ldr	r1, [pc, #132]	; (21e0 <_mac_async_init+0xb4>)
    215a:	f101 0220 	add.w	r2, r1, #32
    215e:	608a      	str	r2, [r1, #8]
		_txbuf_descrs[i].status.val     = 0;
    2160:	60cb      	str	r3, [r1, #12]
		_txbuf_descrs[i].status.bm.used = 1;
    2162:	2280      	movs	r2, #128	; 0x80
    2164:	73ca      	strb	r2, [r1, #15]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    2166:	f201 52fc 	addw	r2, r1, #1532	; 0x5fc
    216a:	610a      	str	r2, [r1, #16]
		_txbuf_descrs[i].status.val     = 0;
    216c:	614b      	str	r3, [r1, #20]
	_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    216e:	22c0      	movs	r2, #192	; 0xc0
    2170:	75ca      	strb	r2, [r1, #23]
	_txbuf_index                                            = 0;
    2172:	604b      	str	r3, [r1, #4]
	_last_txbuf_index                                       = 0;
    2174:	f8c1 3bd8 	str.w	r3, [r1, #3032]	; 0xbd8
    2178:	f501 633e 	add.w	r3, r1, #3040	; 0xbe0
    217c:	4a19      	ldr	r2, [pc, #100]	; (21e4 <_mac_async_init+0xb8>)
    217e:	f501 519f 	add.w	r1, r1, #5088	; 0x13e0
		_rxbuf_descrs[i].status.val  = 0;
    2182:	2400      	movs	r4, #0
		_rxbuf_descrs[i].address.val = (uint32_t)_rxbuf[i];
    2184:	f842 3c04 	str.w	r3, [r2, #-4]
		_rxbuf_descrs[i].status.val  = 0;
    2188:	f842 4b08 	str.w	r4, [r2], #8
    218c:	3380      	adds	r3, #128	; 0x80
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    218e:	428b      	cmp	r3, r1
    2190:	d1f8      	bne.n	2184 <_mac_async_init+0x58>
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    2192:	4b15      	ldr	r3, [pc, #84]	; (21e8 <_mac_async_init+0xbc>)
    2194:	f893 2360 	ldrb.w	r2, [r3, #864]	; 0x360
    2198:	f042 0202 	orr.w	r2, r2, #2
    219c:	f883 2360 	strb.w	r2, [r3, #864]	; 0x360
	_rxbuf_index                                             = 0;
    21a0:	2100      	movs	r1, #0
    21a2:	f8c3 1368 	str.w	r1, [r3, #872]	; 0x368
	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    21a6:	6804      	ldr	r4, [r0, #0]
    21a8:	4a0d      	ldr	r2, [pc, #52]	; (21e0 <_mac_async_init+0xb4>)
    21aa:	f102 0508 	add.w	r5, r2, #8
	((Gmac *)hw)->TBQB.reg = data;
    21ae:	61e5      	str	r5, [r4, #28]
	hri_gmac_write_RBQB_reg(dev->hw, (uint32_t)_rxbuf_descrs);
    21b0:	6804      	ldr	r4, [r0, #0]
    21b2:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
	((Gmac *)hw)->RBQB.reg = data;
    21b6:	61a3      	str	r3, [r4, #24]
	_mac_init_bufdescr(dev);

	_gmac_dev = dev;
    21b8:	6010      	str	r0, [r2, #0]
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    21ba:	4b0c      	ldr	r3, [pc, #48]	; (21ec <_mac_async_init+0xc0>)
    21bc:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    21c0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    21c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    21c8:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    21cc:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    21d0:	609a      	str	r2, [r3, #8]
	NVIC_DisableIRQ(GMAC_IRQn);
	NVIC_ClearPendingIRQ(GMAC_IRQn);
	NVIC_EnableIRQ(GMAC_IRQn);

	return ERR_NONE;
}
    21d2:	4608      	mov	r0, r1
    21d4:	bc30      	pop	{r4, r5}
    21d6:	4770      	bx	lr
    21d8:	00100103 	.word	0x00100103
    21dc:	00020704 	.word	0x00020704
    21e0:	200004a0 	.word	0x200004a0
    21e4:	20001884 	.word	0x20001884
    21e8:	20001598 	.word	0x20001598
    21ec:	e000e100 	.word	0xe000e100

000021f0 <_mac_async_enable>:
	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    21f0:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    21f2:	6813      	ldr	r3, [r2, #0]
    21f4:	f043 030c 	orr.w	r3, r3, #12
    21f8:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
}
    21fa:	2000      	movs	r0, #0
    21fc:	4770      	bx	lr
	...

00002200 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    2200:	2201      	movs	r2, #1
    2202:	4b01      	ldr	r3, [pc, #4]	; (2208 <_mclk_init+0x8>)
    2204:	715a      	strb	r2, [r3, #5]
    2206:	4770      	bx	lr
    2208:	40000800 	.word	0x40000800

0000220c <_nvm_interrupt_handler>:
 * \internal NVM interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _nvm_interrupt_handler(struct _flash_device *device)
{
    220c:	b508      	push	{r3, lr}
	void *const hw = device->hw;
    220e:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_DONE) >> NVMCTRL_INTFLAG_DONE_Pos;
    2210:	8a1a      	ldrh	r2, [r3, #16]

	if (hri_nvmctrl_get_INTFLAG_DONE_bit(hw)) {
    2212:	f012 0f01 	tst.w	r2, #1
    2216:	d005      	beq.n	2224 <_nvm_interrupt_handler+0x18>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_DONE;
    2218:	2201      	movs	r2, #1
    221a:	821a      	strh	r2, [r3, #16]
		hri_nvmctrl_clear_INTFLAG_DONE_bit(hw);

		if (NULL != device->flash_cb.ready_cb) {
    221c:	6803      	ldr	r3, [r0, #0]
    221e:	b153      	cbz	r3, 2236 <_nvm_interrupt_handler+0x2a>
			device->flash_cb.ready_cb(device);
    2220:	4798      	blx	r3
    2222:	bd08      	pop	{r3, pc}
	return ((Nvmctrl *)hw)->INTFLAG.reg;
    2224:	8a1a      	ldrh	r2, [r3, #16]
    2226:	b292      	uxth	r2, r2
		}
	} else if (hri_nvmctrl_read_INTFLAG_reg(hw) && ~NVMCTRL_INTFLAG_ERR) {
    2228:	b12a      	cbz	r2, 2236 <_nvm_interrupt_handler+0x2a>
	((Nvmctrl *)hw)->INTFLAG.reg = mask;
    222a:	f240 225e 	movw	r2, #606	; 0x25e
    222e:	821a      	strh	r2, [r3, #16]
		hri_nvmctrl_clear_INTFLAG_reg(hw, NVMCTRL_INTFLAG_ERR);

		if (NULL != device->flash_cb.error_cb) {
    2230:	6843      	ldr	r3, [r0, #4]
    2232:	b103      	cbz	r3, 2236 <_nvm_interrupt_handler+0x2a>
			device->flash_cb.error_cb(device);
    2234:	4798      	blx	r3
    2236:	bd08      	pop	{r3, pc}

00002238 <_flash_init>:
{
    2238:	b538      	push	{r3, r4, r5, lr}
    223a:	460c      	mov	r4, r1
	ASSERT(device && (hw == NVMCTRL));
    223c:	4605      	mov	r5, r0
    223e:	b350      	cbz	r0, 2296 <_flash_init+0x5e>
    2240:	4816      	ldr	r0, [pc, #88]	; (229c <_flash_init+0x64>)
    2242:	4281      	cmp	r1, r0
    2244:	bf14      	ite	ne
    2246:	2000      	movne	r0, #0
    2248:	2001      	moveq	r0, #1
    224a:	224b      	movs	r2, #75	; 0x4b
    224c:	4914      	ldr	r1, [pc, #80]	; (22a0 <_flash_init+0x68>)
    224e:	4b15      	ldr	r3, [pc, #84]	; (22a4 <_flash_init+0x6c>)
    2250:	4798      	blx	r3
	device->hw = hw;
    2252:	612c      	str	r4, [r5, #16]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_nvmctrl_ctrla_reg_t hri_nvmctrl_read_CTRLA_reg(const void *const hw)
{
	return ((Nvmctrl *)hw)->CTRLA.reg;
    2254:	8823      	ldrh	r3, [r4, #0]
	hri_nvmctrl_write_CTRLA_reg(hw, ctrla);
    2256:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    225a:	049b      	lsls	r3, r3, #18
    225c:	0c9b      	lsrs	r3, r3, #18
	((Nvmctrl *)hw)->CTRLA.reg = data;
    225e:	8023      	strh	r3, [r4, #0]
	_nvm_dev = device;
    2260:	4b11      	ldr	r3, [pc, #68]	; (22a8 <_flash_init+0x70>)
    2262:	601d      	str	r5, [r3, #0]
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    2264:	4b11      	ldr	r3, [pc, #68]	; (22ac <_flash_init+0x74>)
    2266:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    226a:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    226e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2272:	f3bf 8f6f 	isb	sy
    2276:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    227a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    227e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2282:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    2286:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    228a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    228e:	6019      	str	r1, [r3, #0]
    2290:	601a      	str	r2, [r3, #0]
}
    2292:	2000      	movs	r0, #0
    2294:	bd38      	pop	{r3, r4, r5, pc}
    2296:	2000      	movs	r0, #0
    2298:	e7d7      	b.n	224a <_flash_init+0x12>
    229a:	bf00      	nop
    229c:	41004000 	.word	0x41004000
    22a0:	00006f88 	.word	0x00006f88
    22a4:	000019fd 	.word	0x000019fd
    22a8:	20001904 	.word	0x20001904
    22ac:	e000e100 	.word	0xe000e100

000022b0 <_flash_get_page_size>:
}
    22b0:	f44f 7000 	mov.w	r0, #512	; 0x200
    22b4:	4770      	bx	lr

000022b6 <_flash_get_total_pages>:
	return (uint32_t)hri_nvmctrl_read_PARAM_NVMP_bf(device->hw);
    22b6:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->PARAM.reg & NVMCTRL_PARAM_NVMP_Msk) >> NVMCTRL_PARAM_NVMP_Pos;
    22b8:	6898      	ldr	r0, [r3, #8]
}
    22ba:	b280      	uxth	r0, r0
    22bc:	4770      	bx	lr

000022be <_flash_read>:
{
    22be:	b410      	push	{r4}
	while (!hri_nvmctrl_get_STATUS_READY_bit(device->hw)) {
    22c0:	6904      	ldr	r4, [r0, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    22c2:	8a60      	ldrh	r0, [r4, #18]
    22c4:	f010 0f01 	tst.w	r0, #1
    22c8:	d0fb      	beq.n	22c2 <_flash_read+0x4>
	for (i = 0; i < length; i++) {
    22ca:	b143      	cbz	r3, 22de <_flash_read+0x20>
    22cc:	3901      	subs	r1, #1
    22ce:	4610      	mov	r0, r2
    22d0:	4413      	add	r3, r2
		buffer[i] = nvm_addr[src_addr + i];
    22d2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    22d6:	f800 4b01 	strb.w	r4, [r0], #1
	for (i = 0; i < length; i++) {
    22da:	4298      	cmp	r0, r3
    22dc:	d1f9      	bne.n	22d2 <_flash_read+0x14>
}
    22de:	f85d 4b04 	ldr.w	r4, [sp], #4
    22e2:	4770      	bx	lr

000022e4 <NVMCTRL_0_Handler>:

/**
 * \internal NVM 0 interrupt handler
 */
void NVMCTRL_0_Handler(void)
{
    22e4:	b508      	push	{r3, lr}
	_nvm_interrupt_handler(_nvm_dev);
    22e6:	4b02      	ldr	r3, [pc, #8]	; (22f0 <NVMCTRL_0_Handler+0xc>)
    22e8:	6818      	ldr	r0, [r3, #0]
    22ea:	4b02      	ldr	r3, [pc, #8]	; (22f4 <NVMCTRL_0_Handler+0x10>)
    22ec:	4798      	blx	r3
    22ee:	bd08      	pop	{r3, pc}
    22f0:	20001904 	.word	0x20001904
    22f4:	0000220d 	.word	0x0000220d

000022f8 <NVMCTRL_1_Handler>:

/**
 * \internal NVM 1 interrupt handler
 */
void NVMCTRL_1_Handler(void)
{
    22f8:	b508      	push	{r3, lr}
	_nvm_interrupt_handler(_nvm_dev);
    22fa:	4b02      	ldr	r3, [pc, #8]	; (2304 <NVMCTRL_1_Handler+0xc>)
    22fc:	6818      	ldr	r0, [r3, #0]
    22fe:	4b02      	ldr	r3, [pc, #8]	; (2308 <NVMCTRL_1_Handler+0x10>)
    2300:	4798      	blx	r3
    2302:	bd08      	pop	{r3, pc}
    2304:	20001904 	.word	0x20001904
    2308:	0000220d 	.word	0x0000220d

0000230c <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    230c:	4b03      	ldr	r3, [pc, #12]	; (231c <_osc32kctrl_init_sources+0x10>)
    230e:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    2310:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    2314:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    2316:	2201      	movs	r2, #1
    2318:	741a      	strb	r2, [r3, #16]
    231a:	4770      	bx	lr
    231c:	40001400 	.word	0x40001400

00002320 <_oscctrl_init_sources>:

/**
 * \brief Initialize clock sources
 */
void _oscctrl_init_sources(void)
{
    2320:	4770      	bx	lr
	...

00002324 <_oscctrl_init_referenced_generators>:
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    2324:	4a47      	ldr	r2, [pc, #284]	; (2444 <_oscctrl_init_referenced_generators+0x120>)
    2326:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    2328:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    232c:	f043 0304 	orr.w	r3, r3, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    2330:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    2332:	4611      	mov	r1, r2
    2334:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    2338:	684b      	ldr	r3, [r1, #4]
    233a:	4213      	tst	r3, r2
    233c:	d1fc      	bne.n	2338 <_oscctrl_init_referenced_generators+0x14>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    233e:	4a41      	ldr	r2, [pc, #260]	; (2444 <_oscctrl_init_referenced_generators+0x120>)
    2340:	6853      	ldr	r3, [r2, #4]
{
	void *hw = (void *)OSCCTRL;

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    2342:	f013 0f04 	tst.w	r3, #4
    2346:	d1fb      	bne.n	2340 <_oscctrl_init_referenced_generators+0x1c>
}

static inline void hri_oscctrl_write_DFLLCTRLA_reg(const void *const hw, hri_oscctrl_dfllctrla_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    2348:	4b3f      	ldr	r3, [pc, #252]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    234a:	2200      	movs	r2, #0
    234c:	771a      	strb	r2, [r3, #28]
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    234e:	4a3f      	ldr	r2, [pc, #252]	; (244c <_oscctrl_init_referenced_generators+0x128>)
    2350:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    2352:	461a      	mov	r2, r3
    2354:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    2358:	f013 0f10 	tst.w	r3, #16
    235c:	d1fa      	bne.n	2354 <_oscctrl_init_referenced_generators+0x30>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    235e:	2200      	movs	r2, #0
    2360:	4b39      	ldr	r3, [pc, #228]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    2362:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    2366:	461a      	mov	r2, r3
    2368:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    236c:	f013 0f04 	tst.w	r3, #4
    2370:	d1fa      	bne.n	2368 <_oscctrl_init_referenced_generators+0x44>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    2372:	2202      	movs	r2, #2
    2374:	4b34      	ldr	r3, [pc, #208]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    2376:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    2378:	461a      	mov	r2, r3
    237a:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    237e:	f013 0f02 	tst.w	r3, #2
    2382:	d1fa      	bne.n	237a <_oscctrl_init_referenced_generators+0x56>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    2384:	4b30      	ldr	r3, [pc, #192]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    2386:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    2388:	625a      	str	r2, [r3, #36]	; 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    238a:	461a      	mov	r2, r3
    238c:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    2390:	f013 0f08 	tst.w	r3, #8
    2394:	d1fa      	bne.n	238c <_oscctrl_init_referenced_generators+0x68>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    2396:	2280      	movs	r2, #128	; 0x80
    2398:	4b2b      	ldr	r3, [pc, #172]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    239a:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    239e:	461a      	mov	r2, r3
    23a0:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    23a4:	f013 0f04 	tst.w	r3, #4
    23a8:	d1fa      	bne.n	23a0 <_oscctrl_init_referenced_generators+0x7c>
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    23aa:	2243      	movs	r2, #67	; 0x43
    23ac:	4b25      	ldr	r3, [pc, #148]	; (2444 <_oscctrl_init_referenced_generators+0x120>)
    23ae:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    23b2:	4a27      	ldr	r2, [pc, #156]	; (2450 <_oscctrl_init_referenced_generators+0x12c>)
    23b4:	f5a3 6340 	sub.w	r3, r3, #3072	; 0xc00
    23b8:	635a      	str	r2, [r3, #52]	; 0x34
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    23ba:	461a      	mov	r2, r3
    23bc:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    23be:	f013 0f06 	tst.w	r3, #6
    23c2:	d1fb      	bne.n	23bc <_oscctrl_init_referenced_generators+0x98>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    23c4:	4b20      	ldr	r3, [pc, #128]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    23c6:	f44f 6200 	mov.w	r2, #2048	; 0x800
    23ca:	639a      	str	r2, [r3, #56]	; 0x38
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    23cc:	2202      	movs	r2, #2
    23ce:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    23d2:	461a      	mov	r2, r3
    23d4:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    23d6:	f013 0f02 	tst.w	r3, #2
    23da:	d1fb      	bne.n	23d4 <_oscctrl_init_referenced_generators+0xb0>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    23dc:	4b1a      	ldr	r3, [pc, #104]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    23de:	f893 3020 	ldrb.w	r3, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    23e2:	f013 0f01 	tst.w	r3, #1
    23e6:	d026      	beq.n	2436 <_oscctrl_init_referenced_generators+0x112>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    23e8:	4a17      	ldr	r2, [pc, #92]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    23ea:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    23ec:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    23f0:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    23f4:	d1f9      	bne.n	23ea <_oscctrl_init_referenced_generators+0xc6>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    23f6:	4b14      	ldr	r3, [pc, #80]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    23f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
#endif
#endif

#if CONF_FDPLL0_CONFIG == 1
#if CONF_FDPLL0_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 0) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 0)))
    23fa:	f012 0f01 	tst.w	r2, #1
    23fe:	d103      	bne.n	2408 <_oscctrl_init_referenced_generators+0xe4>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    2400:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    2402:	f012 0f02 	tst.w	r2, #2
    2406:	d0f7      	beq.n	23f8 <_oscctrl_init_referenced_generators+0xd4>
	return ((Gclk *)hw)->SYNCBUSY.reg;
    2408:	4a0e      	ldr	r2, [pc, #56]	; (2444 <_oscctrl_init_referenced_generators+0x120>)
    240a:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    240c:	2b00      	cmp	r3, #0
    240e:	d1fc      	bne.n	240a <_oscctrl_init_referenced_generators+0xe6>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    2410:	4a0c      	ldr	r2, [pc, #48]	; (2444 <_oscctrl_init_referenced_generators+0x120>)
    2412:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    2414:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    2418:	f043 0307 	orr.w	r3, r3, #7
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    241c:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    241e:	4611      	mov	r1, r2
    2420:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    2424:	684b      	ldr	r3, [r1, #4]
    2426:	4213      	tst	r3, r2
    2428:	d1fc      	bne.n	2424 <_oscctrl_init_referenced_generators+0x100>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    242a:	4a06      	ldr	r2, [pc, #24]	; (2444 <_oscctrl_init_referenced_generators+0x120>)
    242c:	6853      	ldr	r3, [r2, #4]
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    242e:	f013 0f04 	tst.w	r3, #4
    2432:	d1fb      	bne.n	242c <_oscctrl_init_referenced_generators+0x108>
		;
#endif
	(void)hw;
}
    2434:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    2436:	4a04      	ldr	r2, [pc, #16]	; (2448 <_oscctrl_init_referenced_generators+0x124>)
    2438:	6913      	ldr	r3, [r2, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    243a:	f413 7f80 	tst.w	r3, #256	; 0x100
    243e:	d0fb      	beq.n	2438 <_oscctrl_init_referenced_generators+0x114>
    2440:	e7d9      	b.n	23f6 <_oscctrl_init_referenced_generators+0xd2>
    2442:	bf00      	nop
    2444:	40001c00 	.word	0x40001c00
    2448:	40001000 	.word	0x40001000
    244c:	04010000 	.word	0x04010000
    2450:	00010e4d 	.word	0x00010e4d

00002454 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    2454:	b500      	push	{lr}
    2456:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    2458:	4b0d      	ldr	r3, [pc, #52]	; (2490 <RAMECC_Handler+0x3c>)
    245a:	789b      	ldrb	r3, [r3, #2]
    245c:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    245e:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    2460:	9b01      	ldr	r3, [sp, #4]
    2462:	f013 0f02 	tst.w	r3, #2
    2466:	d006      	beq.n	2476 <RAMECC_Handler+0x22>
    2468:	4b0a      	ldr	r3, [pc, #40]	; (2494 <RAMECC_Handler+0x40>)
    246a:	681b      	ldr	r3, [r3, #0]
    246c:	b11b      	cbz	r3, 2476 <RAMECC_Handler+0x22>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    246e:	4a08      	ldr	r2, [pc, #32]	; (2490 <RAMECC_Handler+0x3c>)
    2470:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    2472:	4798      	blx	r3
    2474:	e009      	b.n	248a <RAMECC_Handler+0x36>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    2476:	9b01      	ldr	r3, [sp, #4]
    2478:	f013 0f01 	tst.w	r3, #1
    247c:	d005      	beq.n	248a <RAMECC_Handler+0x36>
    247e:	4b05      	ldr	r3, [pc, #20]	; (2494 <RAMECC_Handler+0x40>)
    2480:	685b      	ldr	r3, [r3, #4]
    2482:	b113      	cbz	r3, 248a <RAMECC_Handler+0x36>
    2484:	4a02      	ldr	r2, [pc, #8]	; (2490 <RAMECC_Handler+0x3c>)
    2486:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    2488:	4798      	blx	r3
	} else {
		return;
	}
}
    248a:	b003      	add	sp, #12
    248c:	f85d fb04 	ldr.w	pc, [sp], #4
    2490:	41020000 	.word	0x41020000
    2494:	2000eb00 	.word	0x2000eb00

00002498 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    2498:	b470      	push	{r4, r5, r6}
    249a:	b089      	sub	sp, #36	; 0x24
    249c:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    249e:	466c      	mov	r4, sp
    24a0:	4d0d      	ldr	r5, [pc, #52]	; (24d8 <_sercom_get_hardware_index+0x40>)
    24a2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    24a4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    24a6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    24aa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    24ae:	9b00      	ldr	r3, [sp, #0]
    24b0:	42b3      	cmp	r3, r6
    24b2:	d00d      	beq.n	24d0 <_sercom_get_hardware_index+0x38>
    24b4:	4631      	mov	r1, r6
    24b6:	ab01      	add	r3, sp, #4
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    24b8:	2001      	movs	r0, #1
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    24ba:	f853 2b04 	ldr.w	r2, [r3], #4
    24be:	428a      	cmp	r2, r1
    24c0:	d007      	beq.n	24d2 <_sercom_get_hardware_index+0x3a>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    24c2:	3001      	adds	r0, #1
    24c4:	2808      	cmp	r0, #8
    24c6:	d1f8      	bne.n	24ba <_sercom_get_hardware_index+0x22>
			return i;
		}
	}
	return 0;
    24c8:	2000      	movs	r0, #0
}
    24ca:	b009      	add	sp, #36	; 0x24
    24cc:	bc70      	pop	{r4, r5, r6}
    24ce:	4770      	bx	lr
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    24d0:	2000      	movs	r0, #0
			return i;
    24d2:	b2c0      	uxtb	r0, r0
    24d4:	e7f9      	b.n	24ca <_sercom_get_hardware_index+0x32>
    24d6:	bf00      	nop
    24d8:	00006fa8 	.word	0x00006fa8

000024dc <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
    24dc:	b510      	push	{r4, lr}
	void *hw = device->hw;
    24de:	6984      	ldr	r4, [r0, #24]
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    24e0:	7e23      	ldrb	r3, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
    24e2:	f013 0f01 	tst.w	r3, #1
    24e6:	d003      	beq.n	24f0 <_sercom_usart_interrupt_handler+0x14>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
}

static inline bool hri_sercomusart_get_INTEN_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
    24e8:	7da3      	ldrb	r3, [r4, #22]
    24ea:	f013 0f01 	tst.w	r3, #1
    24ee:	d112      	bne.n	2516 <_sercom_usart_interrupt_handler+0x3a>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    24f0:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
    24f2:	f013 0f02 	tst.w	r3, #2
    24f6:	d003      	beq.n	2500 <_sercom_usart_interrupt_handler+0x24>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
}

static inline bool hri_sercomusart_get_INTEN_TXC_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
    24f8:	7da3      	ldrb	r3, [r4, #22]
    24fa:	f013 0f02 	tst.w	r3, #2
    24fe:	d10f      	bne.n	2520 <_sercom_usart_interrupt_handler+0x44>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    2500:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_TXC_bit(hw);
		device->usart_cb.tx_done_cb(device);
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
    2502:	f013 0f04 	tst.w	r3, #4
    2506:	d015      	beq.n	2534 <_sercom_usart_interrupt_handler+0x58>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
    2508:	8b63      	ldrh	r3, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
    250a:	f003 0337 	and.w	r3, r3, #55	; 0x37
    250e:	b163      	cbz	r3, 252a <_sercom_usart_interrupt_handler+0x4e>
	((Sercom *)hw)->USART.STATUS.reg = mask;
    2510:	23ff      	movs	r3, #255	; 0xff
    2512:	8363      	strh	r3, [r4, #26]
    2514:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    2516:	2301      	movs	r3, #1
    2518:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
    251a:	6803      	ldr	r3, [r0, #0]
    251c:	4798      	blx	r3
    251e:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    2520:	2302      	movs	r3, #2
    2522:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
    2524:	6883      	ldr	r3, [r0, #8]
    2526:	4798      	blx	r3
    2528:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
    252a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		       | SERCOM_USART_STATUS_ISF | SERCOM_USART_STATUS_COLL)) {
			hri_sercomusart_clear_STATUS_reg(hw, SERCOM_USART_STATUS_MASK);
			return;
		}

		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
    252c:	6843      	ldr	r3, [r0, #4]
    252e:	b2c9      	uxtb	r1, r1
    2530:	4798      	blx	r3
    2532:	bd10      	pop	{r4, pc}
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
    2534:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
    2536:	09db      	lsrs	r3, r3, #7
    2538:	d100      	bne.n	253c <_sercom_usart_interrupt_handler+0x60>
    253a:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
    253c:	2380      	movs	r3, #128	; 0x80
    253e:	7623      	strb	r3, [r4, #24]
		uint32_t status;

		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
    2540:	68c3      	ldr	r3, [r0, #12]
    2542:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
    2544:	8b63      	ldrh	r3, [r4, #26]
    2546:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
    2548:	8363      	strh	r3, [r4, #26]
    254a:	e7f6      	b.n	253a <_sercom_usart_interrupt_handler+0x5e>

0000254c <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM0) {
    254c:	4b14      	ldr	r3, [pc, #80]	; (25a0 <_sercom_init_irq_param+0x54>)
    254e:	4298      	cmp	r0, r3
    2550:	d014      	beq.n	257c <_sercom_init_irq_param+0x30>
		_sercom0_dev = (struct _spi_async_dev *)dev;
	}

	if (hw == SERCOM1) {
    2552:	4b14      	ldr	r3, [pc, #80]	; (25a4 <_sercom_init_irq_param+0x58>)
    2554:	4298      	cmp	r0, r3
    2556:	d014      	beq.n	2582 <_sercom_init_irq_param+0x36>
		_sercom1_dev = (struct _spi_async_dev *)dev;
	}

	if (hw == SERCOM2) {
    2558:	4b13      	ldr	r3, [pc, #76]	; (25a8 <_sercom_init_irq_param+0x5c>)
    255a:	4298      	cmp	r0, r3
    255c:	d014      	beq.n	2588 <_sercom_init_irq_param+0x3c>
		_sercom2_dev = (struct _spi_async_dev *)dev;
	}

	if (hw == SERCOM3) {
    255e:	4b13      	ldr	r3, [pc, #76]	; (25ac <_sercom_init_irq_param+0x60>)
    2560:	4298      	cmp	r0, r3
    2562:	d014      	beq.n	258e <_sercom_init_irq_param+0x42>
		_sercom3_dev = (struct _spi_async_dev *)dev;
	}

	if (hw == SERCOM4) {
    2564:	f1b0 4f86 	cmp.w	r0, #1124073472	; 0x43000000
    2568:	d014      	beq.n	2594 <_sercom_init_irq_param+0x48>
		_sercom4_dev = (struct _spi_async_dev *)dev;
	}

	if (hw == SERCOM5) {
    256a:	4b11      	ldr	r3, [pc, #68]	; (25b0 <_sercom_init_irq_param+0x64>)
    256c:	4298      	cmp	r0, r3
    256e:	d014      	beq.n	259a <_sercom_init_irq_param+0x4e>
		_sercom5_dev = (struct _spi_async_dev *)dev;
	}

	if (hw == SERCOM6) {
    2570:	4b10      	ldr	r3, [pc, #64]	; (25b4 <_sercom_init_irq_param+0x68>)
    2572:	4298      	cmp	r0, r3
		_sercom6_dev = (struct _usart_async_device *)dev;
    2574:	bf04      	itt	eq
    2576:	4b10      	ldreq	r3, [pc, #64]	; (25b8 <_sercom_init_irq_param+0x6c>)
    2578:	6199      	streq	r1, [r3, #24]
    257a:	4770      	bx	lr
		_sercom0_dev = (struct _spi_async_dev *)dev;
    257c:	4b0e      	ldr	r3, [pc, #56]	; (25b8 <_sercom_init_irq_param+0x6c>)
    257e:	6019      	str	r1, [r3, #0]
    2580:	e7ed      	b.n	255e <_sercom_init_irq_param+0x12>
		_sercom1_dev = (struct _spi_async_dev *)dev;
    2582:	4b0d      	ldr	r3, [pc, #52]	; (25b8 <_sercom_init_irq_param+0x6c>)
    2584:	6059      	str	r1, [r3, #4]
    2586:	e7ed      	b.n	2564 <_sercom_init_irq_param+0x18>
		_sercom2_dev = (struct _spi_async_dev *)dev;
    2588:	4b0b      	ldr	r3, [pc, #44]	; (25b8 <_sercom_init_irq_param+0x6c>)
    258a:	6099      	str	r1, [r3, #8]
    258c:	e7ed      	b.n	256a <_sercom_init_irq_param+0x1e>
		_sercom3_dev = (struct _spi_async_dev *)dev;
    258e:	4b0a      	ldr	r3, [pc, #40]	; (25b8 <_sercom_init_irq_param+0x6c>)
    2590:	60d9      	str	r1, [r3, #12]
    2592:	e7ed      	b.n	2570 <_sercom_init_irq_param+0x24>
		_sercom4_dev = (struct _spi_async_dev *)dev;
    2594:	4b08      	ldr	r3, [pc, #32]	; (25b8 <_sercom_init_irq_param+0x6c>)
    2596:	6119      	str	r1, [r3, #16]
    2598:	4770      	bx	lr
		_sercom5_dev = (struct _spi_async_dev *)dev;
    259a:	4b07      	ldr	r3, [pc, #28]	; (25b8 <_sercom_init_irq_param+0x6c>)
    259c:	6159      	str	r1, [r3, #20]
    259e:	4770      	bx	lr
    25a0:	40003000 	.word	0x40003000
    25a4:	40003400 	.word	0x40003400
    25a8:	41012000 	.word	0x41012000
    25ac:	41014000 	.word	0x41014000
    25b0:	43000400 	.word	0x43000400
    25b4:	43000800 	.word	0x43000800
    25b8:	20001908 	.word	0x20001908

000025bc <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
    25bc:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
    25be:	4b03      	ldr	r3, [pc, #12]	; (25cc <_sercom_get_irq_num+0x10>)
    25c0:	4798      	blx	r3
    25c2:	0080      	lsls	r0, r0, #2
    25c4:	302e      	adds	r0, #46	; 0x2e
}
    25c6:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    25ca:	bd08      	pop	{r3, pc}
    25cc:	00002499 	.word	0x00002499

000025d0 <_spi_handler>:
/**
 *  \brief IRQ handler used
 *  \param[in, out] p Pointer to SPI device instance.
 */
static void _spi_handler(struct _spi_async_dev *dev)
{
    25d0:	b508      	push	{r3, lr}
	void *                      hw = dev->prvt;
    25d2:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    25d4:	7e11      	ldrb	r1, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
    25d6:	7d93      	ldrb	r3, [r2, #22]
	hri_sercomspi_intflag_reg_t st;

	st = hri_sercomspi_read_INTFLAG_reg(hw);
	st &= hri_sercomspi_read_INTEN_reg(hw);
    25d8:	400b      	ands	r3, r1

	if (st & SERCOM_SPI_INTFLAG_DRE) {
    25da:	f013 0f01 	tst.w	r3, #1
    25de:	d109      	bne.n	25f4 <_spi_handler+0x24>
		dev->callbacks.tx(dev);
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
    25e0:	f013 0f04 	tst.w	r3, #4
    25e4:	d109      	bne.n	25fa <_spi_handler+0x2a>
		dev->callbacks.rx(dev);
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
    25e6:	f013 0f02 	tst.w	r3, #2
    25ea:	d109      	bne.n	2600 <_spi_handler+0x30>
		hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC);
		dev->callbacks.complete(dev);
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
    25ec:	f013 0f80 	tst.w	r3, #128	; 0x80
    25f0:	d10b      	bne.n	260a <_spi_handler+0x3a>
    25f2:	bd08      	pop	{r3, pc}
		dev->callbacks.tx(dev);
    25f4:	6883      	ldr	r3, [r0, #8]
    25f6:	4798      	blx	r3
    25f8:	bd08      	pop	{r3, pc}
		dev->callbacks.rx(dev);
    25fa:	68c3      	ldr	r3, [r0, #12]
    25fc:	4798      	blx	r3
    25fe:	bd08      	pop	{r3, pc}
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    2600:	2302      	movs	r3, #2
    2602:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev);
    2604:	6903      	ldr	r3, [r0, #16]
    2606:	4798      	blx	r3
    2608:	bd08      	pop	{r3, pc}
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    260a:	2304      	movs	r3, #4
    260c:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    260e:	2380      	movs	r3, #128	; 0x80
    2610:	7613      	strb	r3, [r2, #24]
		hri_sercomspi_clear_STATUS_reg(hw, SERCOM_SPI_STATUS_BUFOVF);
		hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_ERROR);
		dev->callbacks.err(dev, ERR_OVERFLOW);
    2612:	6943      	ldr	r3, [r0, #20]
    2614:	f06f 0112 	mvn.w	r1, #18
    2618:	4798      	blx	r3
	}
}
    261a:	e7ea      	b.n	25f2 <_spi_handler+0x22>

0000261c <_usart_init>:
{
    261c:	b510      	push	{r4, lr}
    261e:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    2620:	4b41      	ldr	r3, [pc, #260]	; (2728 <_usart_init+0x10c>)
    2622:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    2624:	2806      	cmp	r0, #6
    2626:	d05c      	beq.n	26e2 <_usart_init+0xc6>
    2628:	2807      	cmp	r0, #7
    262a:	d05c      	beq.n	26e6 <_usart_init+0xca>
	ASSERT(false);
    262c:	f240 2277 	movw	r2, #631	; 0x277
    2630:	493e      	ldr	r1, [pc, #248]	; (272c <_usart_init+0x110>)
    2632:	2000      	movs	r0, #0
    2634:	4b3e      	ldr	r3, [pc, #248]	; (2730 <_usart_init+0x114>)
    2636:	4798      	blx	r3
	return 0;
    2638:	2100      	movs	r1, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    263a:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    263c:	f013 0f01 	tst.w	r3, #1
    2640:	d122      	bne.n	2688 <_usart_init+0x6c>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    2642:	004b      	lsls	r3, r1, #1
    2644:	185a      	adds	r2, r3, r1
    2646:	4b3b      	ldr	r3, [pc, #236]	; (2734 <_usart_init+0x118>)
    2648:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    264c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    264e:	f002 021c 	and.w	r2, r2, #28
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2652:	69e3      	ldr	r3, [r4, #28]
    2654:	f013 0f03 	tst.w	r3, #3
    2658:	d1fb      	bne.n	2652 <_usart_init+0x36>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    265a:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    265c:	f013 0f02 	tst.w	r3, #2
    2660:	d00b      	beq.n	267a <_usart_init+0x5e>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    2662:	6823      	ldr	r3, [r4, #0]
    2664:	f023 0302 	bic.w	r3, r3, #2
    2668:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    266a:	69e3      	ldr	r3, [r4, #28]
    266c:	f013 0f03 	tst.w	r3, #3
    2670:	d1fb      	bne.n	266a <_usart_init+0x4e>
    2672:	69e3      	ldr	r3, [r4, #28]
    2674:	f013 0f02 	tst.w	r3, #2
    2678:	d1fb      	bne.n	2672 <_usart_init+0x56>
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    267a:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
    267e:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2680:	69e3      	ldr	r3, [r4, #28]
    2682:	f013 0f03 	tst.w	r3, #3
    2686:	d1fb      	bne.n	2680 <_usart_init+0x64>
    2688:	69e3      	ldr	r3, [r4, #28]
    268a:	f013 0f01 	tst.w	r3, #1
    268e:	d1fb      	bne.n	2688 <_usart_init+0x6c>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    2690:	460a      	mov	r2, r1
    2692:	004b      	lsls	r3, r1, #1
    2694:	440b      	add	r3, r1
    2696:	4927      	ldr	r1, [pc, #156]	; (2734 <_usart_init+0x118>)
    2698:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    269c:	6a48      	ldr	r0, [r1, #36]	; 0x24
	((Sercom *)hw)->USART.CTRLA.reg = data;
    269e:	6020      	str	r0, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    26a0:	69e3      	ldr	r3, [r4, #28]
    26a2:	f013 0f03 	tst.w	r3, #3
    26a6:	d1fb      	bne.n	26a0 <_usart_init+0x84>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    26a8:	0053      	lsls	r3, r2, #1
    26aa:	1899      	adds	r1, r3, r2
    26ac:	4b21      	ldr	r3, [pc, #132]	; (2734 <_usart_init+0x118>)
    26ae:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    26b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	((Sercom *)hw)->USART.CTRLB.reg = data;
    26b4:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    26b6:	69e3      	ldr	r3, [r4, #28]
    26b8:	f013 0f1f 	tst.w	r3, #31
    26bc:	d1fb      	bne.n	26b6 <_usart_init+0x9a>
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
    26be:	0053      	lsls	r3, r2, #1
    26c0:	1899      	adds	r1, r3, r2
    26c2:	4b1c      	ldr	r3, [pc, #112]	; (2734 <_usart_init+0x118>)
    26c4:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    26c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	((Sercom *)hw)->USART.CTRLC.reg = data;
    26ca:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    26cc:	f410 4fc0 	tst.w	r0, #24576	; 0x6000
    26d0:	d10b      	bne.n	26ea <_usart_init+0xce>
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    26d2:	0053      	lsls	r3, r2, #1
    26d4:	1899      	adds	r1, r3, r2
    26d6:	4b17      	ldr	r3, [pc, #92]	; (2734 <_usart_init+0x118>)
    26d8:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    26dc:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
	((Sercom *)hw)->USART.BAUD.reg = data;
    26de:	81a3      	strh	r3, [r4, #12]
    26e0:	e011      	b.n	2706 <_usart_init+0xea>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    26e2:	2100      	movs	r1, #0
    26e4:	e7a9      	b.n	263a <_usart_init+0x1e>
		if (_usarts[i].number == sercom_offset) {
    26e6:	2101      	movs	r1, #1
    26e8:	e7a7      	b.n	263a <_usart_init+0x1e>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    26ea:	4b12      	ldr	r3, [pc, #72]	; (2734 <_usart_init+0x118>)
    26ec:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    26f0:	8e18      	ldrh	r0, [r3, #48]	; 0x30
    26f2:	89a1      	ldrh	r1, [r4, #12]
    26f4:	f360 010c 	bfi	r1, r0, #0, #13
    26f8:	81a1      	strh	r1, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    26fa:	f893 1032 	ldrb.w	r1, [r3, #50]	; 0x32
    26fe:	89a3      	ldrh	r3, [r4, #12]
    2700:	f361 334f 	bfi	r3, r1, #13, #3
    2704:	81a3      	strh	r3, [r4, #12]
	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    2706:	4b0b      	ldr	r3, [pc, #44]	; (2734 <_usart_init+0x118>)
    2708:	0051      	lsls	r1, r2, #1
    270a:	1888      	adds	r0, r1, r2
    270c:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    2710:	f890 0033 	ldrb.w	r0, [r0, #51]	; 0x33
	((Sercom *)hw)->USART.RXPL.reg = data;
    2714:	73a0      	strb	r0, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    2716:	440a      	add	r2, r1
    2718:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    271c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    2720:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
    2724:	2000      	movs	r0, #0
    2726:	bd10      	pop	{r4, pc}
    2728:	00002499 	.word	0x00002499
    272c:	00007078 	.word	0x00007078
    2730:	000019fd 	.word	0x000019fd
    2734:	00006fa8 	.word	0x00006fa8

00002738 <_usart_sync_init>:
{
    2738:	b538      	push	{r3, r4, r5, lr}
    273a:	460c      	mov	r4, r1
	ASSERT(device);
    273c:	4605      	mov	r5, r0
    273e:	22c9      	movs	r2, #201	; 0xc9
    2740:	4905      	ldr	r1, [pc, #20]	; (2758 <_usart_sync_init+0x20>)
    2742:	3000      	adds	r0, #0
    2744:	bf18      	it	ne
    2746:	2001      	movne	r0, #1
    2748:	4b04      	ldr	r3, [pc, #16]	; (275c <_usart_sync_init+0x24>)
    274a:	4798      	blx	r3
	device->hw = hw;
    274c:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    274e:	4620      	mov	r0, r4
    2750:	4b03      	ldr	r3, [pc, #12]	; (2760 <_usart_sync_init+0x28>)
    2752:	4798      	blx	r3
}
    2754:	bd38      	pop	{r3, r4, r5, pc}
    2756:	bf00      	nop
    2758:	00007078 	.word	0x00007078
    275c:	000019fd 	.word	0x000019fd
    2760:	0000261d 	.word	0x0000261d

00002764 <_usart_async_init>:
{
    2764:	b570      	push	{r4, r5, r6, lr}
    2766:	460d      	mov	r5, r1
	ASSERT(device);
    2768:	4606      	mov	r6, r0
    276a:	22d7      	movs	r2, #215	; 0xd7
    276c:	4917      	ldr	r1, [pc, #92]	; (27cc <_usart_async_init+0x68>)
    276e:	3000      	adds	r0, #0
    2770:	bf18      	it	ne
    2772:	2001      	movne	r0, #1
    2774:	4b16      	ldr	r3, [pc, #88]	; (27d0 <_usart_async_init+0x6c>)
    2776:	4798      	blx	r3
	init_status = _usart_init(hw);
    2778:	4628      	mov	r0, r5
    277a:	4b16      	ldr	r3, [pc, #88]	; (27d4 <_usart_async_init+0x70>)
    277c:	4798      	blx	r3
	if (init_status) {
    277e:	4604      	mov	r4, r0
    2780:	b108      	cbz	r0, 2786 <_usart_async_init+0x22>
}
    2782:	4620      	mov	r0, r4
    2784:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
    2786:	61b5      	str	r5, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
    2788:	4631      	mov	r1, r6
    278a:	4628      	mov	r0, r5
    278c:	4b12      	ldr	r3, [pc, #72]	; (27d8 <_usart_async_init+0x74>)
    278e:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
    2790:	4628      	mov	r0, r5
    2792:	4b12      	ldr	r3, [pc, #72]	; (27dc <_usart_async_init+0x78>)
    2794:	4798      	blx	r3
    2796:	1d01      	adds	r1, r0, #4
    2798:	b2c9      	uxtb	r1, r1
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    279a:	2501      	movs	r5, #1
    279c:	f000 021f 	and.w	r2, r0, #31
    27a0:	fa05 f202 	lsl.w	r2, r5, r2
    27a4:	0943      	lsrs	r3, r0, #5
    27a6:	009b      	lsls	r3, r3, #2
    27a8:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    27ac:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    27b0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    27b4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    27b8:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    27bc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    27c0:	601a      	str	r2, [r3, #0]
		irq++;
    27c2:	3001      	adds	r0, #1
    27c4:	b2c0      	uxtb	r0, r0
	for (uint32_t i = 0; i < 4; i++) {
    27c6:	4281      	cmp	r1, r0
    27c8:	d1e8      	bne.n	279c <_usart_async_init+0x38>
    27ca:	e7da      	b.n	2782 <_usart_async_init+0x1e>
    27cc:	00007078 	.word	0x00007078
    27d0:	000019fd 	.word	0x000019fd
    27d4:	0000261d 	.word	0x0000261d
    27d8:	0000254d 	.word	0x0000254d
    27dc:	000025bd 	.word	0x000025bd

000027e0 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    27e0:	6802      	ldr	r2, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    27e2:	6813      	ldr	r3, [r2, #0]
    27e4:	f043 0302 	orr.w	r3, r3, #2
    27e8:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    27ea:	69d3      	ldr	r3, [r2, #28]
    27ec:	f013 0f03 	tst.w	r3, #3
    27f0:	d1fb      	bne.n	27ea <_usart_sync_enable+0xa>
}
    27f2:	4770      	bx	lr

000027f4 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    27f4:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    27f6:	6813      	ldr	r3, [r2, #0]
    27f8:	f043 0302 	orr.w	r3, r3, #2
    27fc:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    27fe:	69d3      	ldr	r3, [r2, #28]
    2800:	f013 0f03 	tst.w	r3, #3
    2804:	d1fb      	bne.n	27fe <_usart_async_enable+0xa>
}
    2806:	4770      	bx	lr

00002808 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    2808:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    280a:	6299      	str	r1, [r3, #40]	; 0x28
    280c:	4770      	bx	lr

0000280e <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    280e:	6983      	ldr	r3, [r0, #24]
    2810:	6299      	str	r1, [r3, #40]	; 0x28
    2812:	4770      	bx	lr

00002814 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    2814:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    2816:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    2818:	b2c0      	uxtb	r0, r0
    281a:	4770      	bx	lr

0000281c <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    281c:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    281e:	7e18      	ldrb	r0, [r3, #24]
}
    2820:	f000 0001 	and.w	r0, r0, #1
    2824:	4770      	bx	lr

00002826 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    2826:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    2828:	7e18      	ldrb	r0, [r3, #24]
}
    282a:	f3c0 0040 	ubfx	r0, r0, #1, #1
    282e:	4770      	bx	lr

00002830 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    2830:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    2832:	7e18      	ldrb	r0, [r3, #24]
}
    2834:	f3c0 0080 	ubfx	r0, r0, #2, #1
    2838:	4770      	bx	lr

0000283a <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
    283a:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    283c:	2201      	movs	r2, #1
    283e:	759a      	strb	r2, [r3, #22]
    2840:	4770      	bx	lr

00002842 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
    2842:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    2844:	2202      	movs	r2, #2
    2846:	759a      	strb	r2, [r3, #22]
    2848:	4770      	bx	lr
	...

0000284c <_usart_async_set_irq_state>:
{
    284c:	b570      	push	{r4, r5, r6, lr}
    284e:	460c      	mov	r4, r1
    2850:	4616      	mov	r6, r2
	ASSERT(device);
    2852:	4605      	mov	r5, r0
    2854:	f240 2237 	movw	r2, #567	; 0x237
    2858:	4915      	ldr	r1, [pc, #84]	; (28b0 <_usart_async_set_irq_state+0x64>)
    285a:	3000      	adds	r0, #0
    285c:	bf18      	it	ne
    285e:	2001      	movne	r0, #1
    2860:	4b14      	ldr	r3, [pc, #80]	; (28b4 <_usart_async_set_irq_state+0x68>)
    2862:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
    2864:	f014 0ffd 	tst.w	r4, #253	; 0xfd
    2868:	d10d      	bne.n	2886 <_usart_async_set_irq_state+0x3a>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
    286a:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    286c:	b92e      	cbnz	r6, 287a <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    286e:	2201      	movs	r2, #1
    2870:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
    2872:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    2874:	2202      	movs	r2, #2
    2876:	751a      	strb	r2, [r3, #20]
    2878:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    287a:	2201      	movs	r2, #1
    287c:	759a      	strb	r2, [r3, #22]
    287e:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    2880:	2202      	movs	r2, #2
    2882:	759a      	strb	r2, [r3, #22]
    2884:	bd70      	pop	{r4, r5, r6, pc}
	} else if (USART_ASYNC_RX_DONE == type) {
    2886:	2c01      	cmp	r4, #1
    2888:	d002      	beq.n	2890 <_usart_async_set_irq_state+0x44>
	} else if (USART_ASYNC_ERROR == type) {
    288a:	2c03      	cmp	r4, #3
    288c:	d008      	beq.n	28a0 <_usart_async_set_irq_state+0x54>
    288e:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
    2890:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    2892:	b916      	cbnz	r6, 289a <_usart_async_set_irq_state+0x4e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
    2894:	2204      	movs	r2, #4
    2896:	751a      	strb	r2, [r3, #20]
    2898:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
    289a:	2204      	movs	r2, #4
    289c:	759a      	strb	r2, [r3, #22]
    289e:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
    28a0:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    28a2:	b116      	cbz	r6, 28aa <_usart_async_set_irq_state+0x5e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
    28a4:	2280      	movs	r2, #128	; 0x80
    28a6:	759a      	strb	r2, [r3, #22]
}
    28a8:	e7f1      	b.n	288e <_usart_async_set_irq_state+0x42>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
    28aa:	2280      	movs	r2, #128	; 0x80
    28ac:	751a      	strb	r2, [r3, #20]
    28ae:	bd70      	pop	{r4, r5, r6, pc}
    28b0:	00007078 	.word	0x00007078
    28b4:	000019fd 	.word	0x000019fd

000028b8 <SERCOM0_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_0_Handler(void)
{
    28b8:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    28ba:	4b02      	ldr	r3, [pc, #8]	; (28c4 <SERCOM0_0_Handler+0xc>)
    28bc:	6818      	ldr	r0, [r3, #0]
    28be:	4b02      	ldr	r3, [pc, #8]	; (28c8 <SERCOM0_0_Handler+0x10>)
    28c0:	4798      	blx	r3
    28c2:	bd08      	pop	{r3, pc}
    28c4:	20001908 	.word	0x20001908
    28c8:	000025d1 	.word	0x000025d1

000028cc <SERCOM0_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_1_Handler(void)
{
    28cc:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    28ce:	4b02      	ldr	r3, [pc, #8]	; (28d8 <SERCOM0_1_Handler+0xc>)
    28d0:	6818      	ldr	r0, [r3, #0]
    28d2:	4b02      	ldr	r3, [pc, #8]	; (28dc <SERCOM0_1_Handler+0x10>)
    28d4:	4798      	blx	r3
    28d6:	bd08      	pop	{r3, pc}
    28d8:	20001908 	.word	0x20001908
    28dc:	000025d1 	.word	0x000025d1

000028e0 <SERCOM0_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_2_Handler(void)
{
    28e0:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    28e2:	4b02      	ldr	r3, [pc, #8]	; (28ec <SERCOM0_2_Handler+0xc>)
    28e4:	6818      	ldr	r0, [r3, #0]
    28e6:	4b02      	ldr	r3, [pc, #8]	; (28f0 <SERCOM0_2_Handler+0x10>)
    28e8:	4798      	blx	r3
    28ea:	bd08      	pop	{r3, pc}
    28ec:	20001908 	.word	0x20001908
    28f0:	000025d1 	.word	0x000025d1

000028f4 <SERCOM0_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_3_Handler(void)
{
    28f4:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    28f6:	4b02      	ldr	r3, [pc, #8]	; (2900 <SERCOM0_3_Handler+0xc>)
    28f8:	6818      	ldr	r0, [r3, #0]
    28fa:	4b02      	ldr	r3, [pc, #8]	; (2904 <SERCOM0_3_Handler+0x10>)
    28fc:	4798      	blx	r3
    28fe:	bd08      	pop	{r3, pc}
    2900:	20001908 	.word	0x20001908
    2904:	000025d1 	.word	0x000025d1

00002908 <SERCOM1_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_0_Handler(void)
{
    2908:	b508      	push	{r3, lr}
	_spi_handler(_sercom1_dev);
    290a:	4b02      	ldr	r3, [pc, #8]	; (2914 <SERCOM1_0_Handler+0xc>)
    290c:	6858      	ldr	r0, [r3, #4]
    290e:	4b02      	ldr	r3, [pc, #8]	; (2918 <SERCOM1_0_Handler+0x10>)
    2910:	4798      	blx	r3
    2912:	bd08      	pop	{r3, pc}
    2914:	20001908 	.word	0x20001908
    2918:	000025d1 	.word	0x000025d1

0000291c <SERCOM1_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_1_Handler(void)
{
    291c:	b508      	push	{r3, lr}
	_spi_handler(_sercom1_dev);
    291e:	4b02      	ldr	r3, [pc, #8]	; (2928 <SERCOM1_1_Handler+0xc>)
    2920:	6858      	ldr	r0, [r3, #4]
    2922:	4b02      	ldr	r3, [pc, #8]	; (292c <SERCOM1_1_Handler+0x10>)
    2924:	4798      	blx	r3
    2926:	bd08      	pop	{r3, pc}
    2928:	20001908 	.word	0x20001908
    292c:	000025d1 	.word	0x000025d1

00002930 <SERCOM1_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_2_Handler(void)
{
    2930:	b508      	push	{r3, lr}
	_spi_handler(_sercom1_dev);
    2932:	4b02      	ldr	r3, [pc, #8]	; (293c <SERCOM1_2_Handler+0xc>)
    2934:	6858      	ldr	r0, [r3, #4]
    2936:	4b02      	ldr	r3, [pc, #8]	; (2940 <SERCOM1_2_Handler+0x10>)
    2938:	4798      	blx	r3
    293a:	bd08      	pop	{r3, pc}
    293c:	20001908 	.word	0x20001908
    2940:	000025d1 	.word	0x000025d1

00002944 <SERCOM1_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_3_Handler(void)
{
    2944:	b508      	push	{r3, lr}
	_spi_handler(_sercom1_dev);
    2946:	4b02      	ldr	r3, [pc, #8]	; (2950 <SERCOM1_3_Handler+0xc>)
    2948:	6858      	ldr	r0, [r3, #4]
    294a:	4b02      	ldr	r3, [pc, #8]	; (2954 <SERCOM1_3_Handler+0x10>)
    294c:	4798      	blx	r3
    294e:	bd08      	pop	{r3, pc}
    2950:	20001908 	.word	0x20001908
    2954:	000025d1 	.word	0x000025d1

00002958 <SERCOM2_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_0_Handler(void)
{
    2958:	b508      	push	{r3, lr}
	_spi_handler(_sercom2_dev);
    295a:	4b02      	ldr	r3, [pc, #8]	; (2964 <SERCOM2_0_Handler+0xc>)
    295c:	6898      	ldr	r0, [r3, #8]
    295e:	4b02      	ldr	r3, [pc, #8]	; (2968 <SERCOM2_0_Handler+0x10>)
    2960:	4798      	blx	r3
    2962:	bd08      	pop	{r3, pc}
    2964:	20001908 	.word	0x20001908
    2968:	000025d1 	.word	0x000025d1

0000296c <SERCOM2_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_1_Handler(void)
{
    296c:	b508      	push	{r3, lr}
	_spi_handler(_sercom2_dev);
    296e:	4b02      	ldr	r3, [pc, #8]	; (2978 <SERCOM2_1_Handler+0xc>)
    2970:	6898      	ldr	r0, [r3, #8]
    2972:	4b02      	ldr	r3, [pc, #8]	; (297c <SERCOM2_1_Handler+0x10>)
    2974:	4798      	blx	r3
    2976:	bd08      	pop	{r3, pc}
    2978:	20001908 	.word	0x20001908
    297c:	000025d1 	.word	0x000025d1

00002980 <SERCOM2_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_2_Handler(void)
{
    2980:	b508      	push	{r3, lr}
	_spi_handler(_sercom2_dev);
    2982:	4b02      	ldr	r3, [pc, #8]	; (298c <SERCOM2_2_Handler+0xc>)
    2984:	6898      	ldr	r0, [r3, #8]
    2986:	4b02      	ldr	r3, [pc, #8]	; (2990 <SERCOM2_2_Handler+0x10>)
    2988:	4798      	blx	r3
    298a:	bd08      	pop	{r3, pc}
    298c:	20001908 	.word	0x20001908
    2990:	000025d1 	.word	0x000025d1

00002994 <SERCOM2_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_3_Handler(void)
{
    2994:	b508      	push	{r3, lr}
	_spi_handler(_sercom2_dev);
    2996:	4b02      	ldr	r3, [pc, #8]	; (29a0 <SERCOM2_3_Handler+0xc>)
    2998:	6898      	ldr	r0, [r3, #8]
    299a:	4b02      	ldr	r3, [pc, #8]	; (29a4 <SERCOM2_3_Handler+0x10>)
    299c:	4798      	blx	r3
    299e:	bd08      	pop	{r3, pc}
    29a0:	20001908 	.word	0x20001908
    29a4:	000025d1 	.word	0x000025d1

000029a8 <SERCOM3_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM3_0_Handler(void)
{
    29a8:	b508      	push	{r3, lr}
	_spi_handler(_sercom3_dev);
    29aa:	4b02      	ldr	r3, [pc, #8]	; (29b4 <SERCOM3_0_Handler+0xc>)
    29ac:	68d8      	ldr	r0, [r3, #12]
    29ae:	4b02      	ldr	r3, [pc, #8]	; (29b8 <SERCOM3_0_Handler+0x10>)
    29b0:	4798      	blx	r3
    29b2:	bd08      	pop	{r3, pc}
    29b4:	20001908 	.word	0x20001908
    29b8:	000025d1 	.word	0x000025d1

000029bc <SERCOM3_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM3_1_Handler(void)
{
    29bc:	b508      	push	{r3, lr}
	_spi_handler(_sercom3_dev);
    29be:	4b02      	ldr	r3, [pc, #8]	; (29c8 <SERCOM3_1_Handler+0xc>)
    29c0:	68d8      	ldr	r0, [r3, #12]
    29c2:	4b02      	ldr	r3, [pc, #8]	; (29cc <SERCOM3_1_Handler+0x10>)
    29c4:	4798      	blx	r3
    29c6:	bd08      	pop	{r3, pc}
    29c8:	20001908 	.word	0x20001908
    29cc:	000025d1 	.word	0x000025d1

000029d0 <SERCOM3_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM3_2_Handler(void)
{
    29d0:	b508      	push	{r3, lr}
	_spi_handler(_sercom3_dev);
    29d2:	4b02      	ldr	r3, [pc, #8]	; (29dc <SERCOM3_2_Handler+0xc>)
    29d4:	68d8      	ldr	r0, [r3, #12]
    29d6:	4b02      	ldr	r3, [pc, #8]	; (29e0 <SERCOM3_2_Handler+0x10>)
    29d8:	4798      	blx	r3
    29da:	bd08      	pop	{r3, pc}
    29dc:	20001908 	.word	0x20001908
    29e0:	000025d1 	.word	0x000025d1

000029e4 <SERCOM3_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM3_3_Handler(void)
{
    29e4:	b508      	push	{r3, lr}
	_spi_handler(_sercom3_dev);
    29e6:	4b02      	ldr	r3, [pc, #8]	; (29f0 <SERCOM3_3_Handler+0xc>)
    29e8:	68d8      	ldr	r0, [r3, #12]
    29ea:	4b02      	ldr	r3, [pc, #8]	; (29f4 <SERCOM3_3_Handler+0x10>)
    29ec:	4798      	blx	r3
    29ee:	bd08      	pop	{r3, pc}
    29f0:	20001908 	.word	0x20001908
    29f4:	000025d1 	.word	0x000025d1

000029f8 <SERCOM4_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM4_0_Handler(void)
{
    29f8:	b508      	push	{r3, lr}
	_spi_handler(_sercom4_dev);
    29fa:	4b02      	ldr	r3, [pc, #8]	; (2a04 <SERCOM4_0_Handler+0xc>)
    29fc:	6918      	ldr	r0, [r3, #16]
    29fe:	4b02      	ldr	r3, [pc, #8]	; (2a08 <SERCOM4_0_Handler+0x10>)
    2a00:	4798      	blx	r3
    2a02:	bd08      	pop	{r3, pc}
    2a04:	20001908 	.word	0x20001908
    2a08:	000025d1 	.word	0x000025d1

00002a0c <SERCOM4_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM4_1_Handler(void)
{
    2a0c:	b508      	push	{r3, lr}
	_spi_handler(_sercom4_dev);
    2a0e:	4b02      	ldr	r3, [pc, #8]	; (2a18 <SERCOM4_1_Handler+0xc>)
    2a10:	6918      	ldr	r0, [r3, #16]
    2a12:	4b02      	ldr	r3, [pc, #8]	; (2a1c <SERCOM4_1_Handler+0x10>)
    2a14:	4798      	blx	r3
    2a16:	bd08      	pop	{r3, pc}
    2a18:	20001908 	.word	0x20001908
    2a1c:	000025d1 	.word	0x000025d1

00002a20 <SERCOM4_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM4_2_Handler(void)
{
    2a20:	b508      	push	{r3, lr}
	_spi_handler(_sercom4_dev);
    2a22:	4b02      	ldr	r3, [pc, #8]	; (2a2c <SERCOM4_2_Handler+0xc>)
    2a24:	6918      	ldr	r0, [r3, #16]
    2a26:	4b02      	ldr	r3, [pc, #8]	; (2a30 <SERCOM4_2_Handler+0x10>)
    2a28:	4798      	blx	r3
    2a2a:	bd08      	pop	{r3, pc}
    2a2c:	20001908 	.word	0x20001908
    2a30:	000025d1 	.word	0x000025d1

00002a34 <SERCOM4_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM4_3_Handler(void)
{
    2a34:	b508      	push	{r3, lr}
	_spi_handler(_sercom4_dev);
    2a36:	4b02      	ldr	r3, [pc, #8]	; (2a40 <SERCOM4_3_Handler+0xc>)
    2a38:	6918      	ldr	r0, [r3, #16]
    2a3a:	4b02      	ldr	r3, [pc, #8]	; (2a44 <SERCOM4_3_Handler+0x10>)
    2a3c:	4798      	blx	r3
    2a3e:	bd08      	pop	{r3, pc}
    2a40:	20001908 	.word	0x20001908
    2a44:	000025d1 	.word	0x000025d1

00002a48 <SERCOM5_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_0_Handler(void)
{
    2a48:	b508      	push	{r3, lr}
	_spi_handler(_sercom5_dev);
    2a4a:	4b02      	ldr	r3, [pc, #8]	; (2a54 <SERCOM5_0_Handler+0xc>)
    2a4c:	6958      	ldr	r0, [r3, #20]
    2a4e:	4b02      	ldr	r3, [pc, #8]	; (2a58 <SERCOM5_0_Handler+0x10>)
    2a50:	4798      	blx	r3
    2a52:	bd08      	pop	{r3, pc}
    2a54:	20001908 	.word	0x20001908
    2a58:	000025d1 	.word	0x000025d1

00002a5c <SERCOM5_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_1_Handler(void)
{
    2a5c:	b508      	push	{r3, lr}
	_spi_handler(_sercom5_dev);
    2a5e:	4b02      	ldr	r3, [pc, #8]	; (2a68 <SERCOM5_1_Handler+0xc>)
    2a60:	6958      	ldr	r0, [r3, #20]
    2a62:	4b02      	ldr	r3, [pc, #8]	; (2a6c <SERCOM5_1_Handler+0x10>)
    2a64:	4798      	blx	r3
    2a66:	bd08      	pop	{r3, pc}
    2a68:	20001908 	.word	0x20001908
    2a6c:	000025d1 	.word	0x000025d1

00002a70 <SERCOM5_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_2_Handler(void)
{
    2a70:	b508      	push	{r3, lr}
	_spi_handler(_sercom5_dev);
    2a72:	4b02      	ldr	r3, [pc, #8]	; (2a7c <SERCOM5_2_Handler+0xc>)
    2a74:	6958      	ldr	r0, [r3, #20]
    2a76:	4b02      	ldr	r3, [pc, #8]	; (2a80 <SERCOM5_2_Handler+0x10>)
    2a78:	4798      	blx	r3
    2a7a:	bd08      	pop	{r3, pc}
    2a7c:	20001908 	.word	0x20001908
    2a80:	000025d1 	.word	0x000025d1

00002a84 <SERCOM5_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_3_Handler(void)
{
    2a84:	b508      	push	{r3, lr}
	_spi_handler(_sercom5_dev);
    2a86:	4b02      	ldr	r3, [pc, #8]	; (2a90 <SERCOM5_3_Handler+0xc>)
    2a88:	6958      	ldr	r0, [r3, #20]
    2a8a:	4b02      	ldr	r3, [pc, #8]	; (2a94 <SERCOM5_3_Handler+0x10>)
    2a8c:	4798      	blx	r3
    2a8e:	bd08      	pop	{r3, pc}
    2a90:	20001908 	.word	0x20001908
    2a94:	000025d1 	.word	0x000025d1

00002a98 <SERCOM6_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM6_0_Handler(void)
{
    2a98:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom6_dev);
    2a9a:	4b02      	ldr	r3, [pc, #8]	; (2aa4 <SERCOM6_0_Handler+0xc>)
    2a9c:	6998      	ldr	r0, [r3, #24]
    2a9e:	4b02      	ldr	r3, [pc, #8]	; (2aa8 <SERCOM6_0_Handler+0x10>)
    2aa0:	4798      	blx	r3
    2aa2:	bd08      	pop	{r3, pc}
    2aa4:	20001908 	.word	0x20001908
    2aa8:	000024dd 	.word	0x000024dd

00002aac <SERCOM6_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM6_1_Handler(void)
{
    2aac:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom6_dev);
    2aae:	4b02      	ldr	r3, [pc, #8]	; (2ab8 <SERCOM6_1_Handler+0xc>)
    2ab0:	6998      	ldr	r0, [r3, #24]
    2ab2:	4b02      	ldr	r3, [pc, #8]	; (2abc <SERCOM6_1_Handler+0x10>)
    2ab4:	4798      	blx	r3
    2ab6:	bd08      	pop	{r3, pc}
    2ab8:	20001908 	.word	0x20001908
    2abc:	000024dd 	.word	0x000024dd

00002ac0 <SERCOM6_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM6_2_Handler(void)
{
    2ac0:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom6_dev);
    2ac2:	4b02      	ldr	r3, [pc, #8]	; (2acc <SERCOM6_2_Handler+0xc>)
    2ac4:	6998      	ldr	r0, [r3, #24]
    2ac6:	4b02      	ldr	r3, [pc, #8]	; (2ad0 <SERCOM6_2_Handler+0x10>)
    2ac8:	4798      	blx	r3
    2aca:	bd08      	pop	{r3, pc}
    2acc:	20001908 	.word	0x20001908
    2ad0:	000024dd 	.word	0x000024dd

00002ad4 <SERCOM6_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM6_3_Handler(void)
{
    2ad4:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom6_dev);
    2ad6:	4b02      	ldr	r3, [pc, #8]	; (2ae0 <SERCOM6_3_Handler+0xc>)
    2ad8:	6998      	ldr	r0, [r3, #24]
    2ada:	4b02      	ldr	r3, [pc, #8]	; (2ae4 <SERCOM6_3_Handler+0x10>)
    2adc:	4798      	blx	r3
    2ade:	bd08      	pop	{r3, pc}
    2ae0:	20001908 	.word	0x20001908
    2ae4:	000024dd 	.word	0x000024dd

00002ae8 <_spi_m_sync_init>:
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    2ae8:	b570      	push	{r4, r5, r6, lr}
    2aea:	4606      	mov	r6, r0
    2aec:	460c      	mov	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    2aee:	4608      	mov	r0, r1
    2af0:	4b65      	ldr	r3, [pc, #404]	; (2c88 <_spi_m_sync_init+0x1a0>)
    2af2:	4798      	blx	r3
		if (sercomspi_regs[i].n == n) {
    2af4:	2800      	cmp	r0, #0
    2af6:	d07e      	beq.n	2bf6 <_spi_m_sync_init+0x10e>
    2af8:	2801      	cmp	r0, #1
    2afa:	d074      	beq.n	2be6 <_spi_m_sync_init+0xfe>
    2afc:	2802      	cmp	r0, #2
    2afe:	d074      	beq.n	2bea <_spi_m_sync_init+0x102>
    2b00:	2803      	cmp	r0, #3
    2b02:	d074      	beq.n	2bee <_spi_m_sync_init+0x106>
    2b04:	2804      	cmp	r0, #4
    2b06:	d074      	beq.n	2bf2 <_spi_m_sync_init+0x10a>
    2b08:	2805      	cmp	r0, #5
    2b0a:	bf08      	it	eq
    2b0c:	2505      	moveq	r5, #5
    2b0e:	d073      	beq.n	2bf8 <_spi_m_sync_init+0x110>
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    2b10:	2e00      	cmp	r6, #0
    2b12:	f000 80a7 	beq.w	2c64 <_spi_m_sync_init+0x17c>
    2b16:	2c00      	cmp	r4, #0
    2b18:	f040 80ad 	bne.w	2c76 <_spi_m_sync_init+0x18e>
	return NULL;
    2b1c:	2500      	movs	r5, #0
	ASSERT(dev && hw);
    2b1e:	2000      	movs	r0, #0
    2b20:	f640 2265 	movw	r2, #2661	; 0xa65
    2b24:	4959      	ldr	r1, [pc, #356]	; (2c8c <_spi_m_sync_init+0x1a4>)
    2b26:	4b5a      	ldr	r3, [pc, #360]	; (2c90 <_spi_m_sync_init+0x1a8>)
    2b28:	4798      	blx	r3

	if (regs == NULL) {
    2b2a:	2d00      	cmp	r5, #0
    2b2c:	f000 8097 	beq.w	2c5e <_spi_m_sync_init+0x176>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    2b30:	69e3      	ldr	r3, [r4, #28]
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    2b32:	f013 0f01 	tst.w	r3, #1
    2b36:	d11d      	bne.n	2b74 <_spi_m_sync_init+0x8c>
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    2b38:	682b      	ldr	r3, [r5, #0]
    2b3a:	f003 021c 	and.w	r2, r3, #28
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2b3e:	69e3      	ldr	r3, [r4, #28]
    2b40:	f013 0f03 	tst.w	r3, #3
    2b44:	d1fb      	bne.n	2b3e <_spi_m_sync_init+0x56>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    2b46:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    2b48:	f013 0f02 	tst.w	r3, #2
    2b4c:	d00b      	beq.n	2b66 <_spi_m_sync_init+0x7e>
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    2b4e:	6823      	ldr	r3, [r4, #0]
    2b50:	f023 0302 	bic.w	r3, r3, #2
    2b54:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2b56:	69e3      	ldr	r3, [r4, #28]
    2b58:	f013 0f03 	tst.w	r3, #3
    2b5c:	d1fb      	bne.n	2b56 <_spi_m_sync_init+0x6e>
    2b5e:	69e3      	ldr	r3, [r4, #28]
    2b60:	f013 0f02 	tst.w	r3, #2
    2b64:	d1fb      	bne.n	2b5e <_spi_m_sync_init+0x76>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    2b66:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2b6a:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2b6c:	69e3      	ldr	r3, [r4, #28]
    2b6e:	f013 0f03 	tst.w	r3, #3
    2b72:	d1fb      	bne.n	2b6c <_spi_m_sync_init+0x84>
    2b74:	69e3      	ldr	r3, [r4, #28]
    2b76:	f013 0f01 	tst.w	r3, #1
    2b7a:	d1fb      	bne.n	2b74 <_spi_m_sync_init+0x8c>
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
    2b7c:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    2b7e:	682b      	ldr	r3, [r5, #0]
    2b80:	f003 031c 	and.w	r3, r3, #28
    2b84:	2b08      	cmp	r3, #8
    2b86:	d041      	beq.n	2c0c <_spi_m_sync_init+0x124>
	ASSERT(hw && regs);
    2b88:	f640 124a 	movw	r2, #2378	; 0x94a
    2b8c:	493f      	ldr	r1, [pc, #252]	; (2c8c <_spi_m_sync_init+0x1a4>)
    2b8e:	1c20      	adds	r0, r4, #0
    2b90:	bf18      	it	ne
    2b92:	2001      	movne	r0, #1
    2b94:	4b3e      	ldr	r3, [pc, #248]	; (2c90 <_spi_m_sync_init+0x1a8>)
    2b96:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    2b98:	682b      	ldr	r3, [r5, #0]
	hri_sercomspi_write_CTRLA_reg(
    2b9a:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    2b9e:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2ba2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2ba4:	69e3      	ldr	r3, [r4, #28]
    2ba6:	f013 0f03 	tst.w	r3, #3
    2baa:	d1fb      	bne.n	2ba4 <_spi_m_sync_init+0xbc>
	    (regs->ctrlb
    2bac:	686b      	ldr	r3, [r5, #4]
	        | (SERCOM_SPI_CTRLB_RXEN));
    2bae:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
    2bb2:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
    2bb6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    2bba:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2bbc:	69e3      	ldr	r3, [r4, #28]
    2bbe:	f013 0f17 	tst.w	r3, #23
    2bc2:	d1fb      	bne.n	2bbc <_spi_m_sync_init+0xd4>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    2bc4:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
    2bc6:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    2bc8:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    2bca:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    2bce:	686b      	ldr	r3, [r5, #4]
    2bd0:	f003 0307 	and.w	r3, r3, #7
    2bd4:	2b00      	cmp	r3, #0
    2bd6:	bf0c      	ite	eq
    2bd8:	2301      	moveq	r3, #1
    2bda:	2302      	movne	r3, #2
    2bdc:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    2bde:	89eb      	ldrh	r3, [r5, #14]
    2be0:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    2be2:	2000      	movs	r0, #0
    2be4:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
    2be6:	2501      	movs	r5, #1
    2be8:	e006      	b.n	2bf8 <_spi_m_sync_init+0x110>
    2bea:	2502      	movs	r5, #2
    2bec:	e004      	b.n	2bf8 <_spi_m_sync_init+0x110>
    2bee:	2503      	movs	r5, #3
    2bf0:	e002      	b.n	2bf8 <_spi_m_sync_init+0x110>
    2bf2:	2504      	movs	r5, #4
    2bf4:	e000      	b.n	2bf8 <_spi_m_sync_init+0x110>
    2bf6:	2500      	movs	r5, #0
			return &sercomspi_regs[i];
    2bf8:	eb05 1505 	add.w	r5, r5, r5, lsl #4
    2bfc:	4b25      	ldr	r3, [pc, #148]	; (2c94 <_spi_m_sync_init+0x1ac>)
    2bfe:	441d      	add	r5, r3
	ASSERT(dev && hw);
    2c00:	2e00      	cmp	r6, #0
    2c02:	d08c      	beq.n	2b1e <_spi_m_sync_init+0x36>
    2c04:	2001      	movs	r0, #1
    2c06:	2c00      	cmp	r4, #0
    2c08:	d18a      	bne.n	2b20 <_spi_m_sync_init+0x38>
    2c0a:	e788      	b.n	2b1e <_spi_m_sync_init+0x36>
	ASSERT(hw && regs);
    2c0c:	f640 125e 	movw	r2, #2398	; 0x95e
    2c10:	491e      	ldr	r1, [pc, #120]	; (2c8c <_spi_m_sync_init+0x1a4>)
    2c12:	1c20      	adds	r0, r4, #0
    2c14:	bf18      	it	ne
    2c16:	2001      	movne	r0, #1
    2c18:	4b1d      	ldr	r3, [pc, #116]	; (2c90 <_spi_m_sync_init+0x1a8>)
    2c1a:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    2c1c:	682b      	ldr	r3, [r5, #0]
	hri_sercomspi_write_CTRLA_reg(
    2c1e:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    2c22:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2c26:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2c28:	69e3      	ldr	r3, [r4, #28]
    2c2a:	f013 0f03 	tst.w	r3, #3
    2c2e:	d1fb      	bne.n	2c28 <_spi_m_sync_init+0x140>
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    2c30:	686b      	ldr	r3, [r5, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    2c32:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
    2c36:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
    2c3a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    2c3e:	f443 7310 	orr.w	r3, r3, #576	; 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    2c42:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2c44:	69e3      	ldr	r3, [r4, #28]
    2c46:	f013 0f17 	tst.w	r3, #23
    2c4a:	d1fb      	bne.n	2c44 <_spi_m_sync_init+0x15c>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    2c4c:	68ab      	ldr	r3, [r5, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
    2c4e:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    2c50:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    2c52:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    2c56:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    2c58:	2b00      	cmp	r3, #0
    2c5a:	d1fc      	bne.n	2c56 <_spi_m_sync_init+0x16e>
    2c5c:	e7b7      	b.n	2bce <_spi_m_sync_init+0xe6>
		return ERR_INVALID_ARG;
    2c5e:	f06f 000c 	mvn.w	r0, #12
    2c62:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(dev && hw);
    2c64:	f640 2265 	movw	r2, #2661	; 0xa65
    2c68:	4908      	ldr	r1, [pc, #32]	; (2c8c <_spi_m_sync_init+0x1a4>)
    2c6a:	2000      	movs	r0, #0
    2c6c:	4b08      	ldr	r3, [pc, #32]	; (2c90 <_spi_m_sync_init+0x1a8>)
    2c6e:	4798      	blx	r3
		return ERR_INVALID_ARG;
    2c70:	f06f 000c 	mvn.w	r0, #12
    2c74:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(dev && hw);
    2c76:	f640 2265 	movw	r2, #2661	; 0xa65
    2c7a:	4904      	ldr	r1, [pc, #16]	; (2c8c <_spi_m_sync_init+0x1a4>)
    2c7c:	2001      	movs	r0, #1
    2c7e:	4b04      	ldr	r3, [pc, #16]	; (2c90 <_spi_m_sync_init+0x1a8>)
    2c80:	4798      	blx	r3
		return ERR_INVALID_ARG;
    2c82:	f06f 000c 	mvn.w	r0, #12
    2c86:	bd70      	pop	{r4, r5, r6, pc}
    2c88:	00002499 	.word	0x00002499
    2c8c:	00007078 	.word	0x00007078
    2c90:	000019fd 	.word	0x000019fd
    2c94:	00007010 	.word	0x00007010

00002c98 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    2c98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2c9c:	4681      	mov	r9, r0
    2c9e:	460e      	mov	r6, r1
	void *                 hw   = dev->prvt;
    2ca0:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    2ca2:	f8d1 8000 	ldr.w	r8, [r1]
    2ca6:	684d      	ldr	r5, [r1, #4]
    2ca8:	7907      	ldrb	r7, [r0, #4]

	ASSERT(dev && hw);
    2caa:	b1a8      	cbz	r0, 2cd8 <_spi_m_sync_trans+0x40>
    2cac:	1c20      	adds	r0, r4, #0
    2cae:	bf18      	it	ne
    2cb0:	2001      	movne	r0, #1
    2cb2:	f640 32c9 	movw	r2, #3017	; 0xbc9
    2cb6:	492e      	ldr	r1, [pc, #184]	; (2d70 <_spi_m_sync_trans+0xd8>)
    2cb8:	4b2e      	ldr	r3, [pc, #184]	; (2d74 <_spi_m_sync_trans+0xdc>)
    2cba:	4798      	blx	r3
    2cbc:	69e3      	ldr	r3, [r4, #28]

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    2cbe:	f013 0f07 	tst.w	r3, #7
    2cc2:	d134      	bne.n	2d2e <_spi_m_sync_trans+0x96>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2cc4:	69e0      	ldr	r0, [r4, #28]
    2cc6:	f010 0003 	ands.w	r0, r0, #3
    2cca:	d1fb      	bne.n	2cc4 <_spi_m_sync_trans+0x2c>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    2ccc:	6823      	ldr	r3, [r4, #0]
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    2cce:	f013 0f02 	tst.w	r3, #2
    2cd2:	d030      	beq.n	2d36 <_spi_m_sync_trans+0x9e>
    2cd4:	4602      	mov	r2, r0
    2cd6:	e008      	b.n	2cea <_spi_m_sync_trans+0x52>
    2cd8:	2000      	movs	r0, #0
    2cda:	e7ea      	b.n	2cb2 <_spi_m_sync_trans+0x1a>
	ctrl->rxcnt++;
    2cdc:	3201      	adds	r2, #1
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    2cde:	f013 0f80 	tst.w	r3, #128	; 0x80
    2ce2:	d112      	bne.n	2d0a <_spi_m_sync_trans+0x72>
		rc = _spi_err_check(iflag, hw);

		if (rc < 0) {
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    2ce4:	68b3      	ldr	r3, [r6, #8]
    2ce6:	4283      	cmp	r3, r0
    2ce8:	d91e      	bls.n	2d28 <_spi_m_sync_trans+0x90>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    2cea:	7e23      	ldrb	r3, [r4, #24]
    2cec:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    2cee:	f013 0f04 	tst.w	r3, #4
    2cf2:	d024      	beq.n	2d3e <_spi_m_sync_trans+0xa6>
	return ((Sercom *)hw)->SPI.DATA.reg;
    2cf4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	if (ctrl->rxbuf) {
    2cf6:	2d00      	cmp	r5, #0
    2cf8:	d0f0      	beq.n	2cdc <_spi_m_sync_trans+0x44>
		*ctrl->rxbuf++ = (uint8_t)data;
    2cfa:	7029      	strb	r1, [r5, #0]
		if (ctrl->char_size > 1) {
    2cfc:	2f01      	cmp	r7, #1
		*ctrl->rxbuf++ = (uint8_t)data;
    2cfe:	bf91      	iteee	ls
    2d00:	3501      	addls	r5, #1
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    2d02:	0a09      	lsrhi	r1, r1, #8
    2d04:	7069      	strbhi	r1, [r5, #1]
    2d06:	3502      	addhi	r5, #2
    2d08:	e7e8      	b.n	2cdc <_spi_m_sync_trans+0x44>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    2d0a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    2d0e:	8363      	strh	r3, [r4, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    2d10:	2380      	movs	r3, #128	; 0x80
    2d12:	7623      	strb	r3, [r4, #24]
		return ERR_OVERFLOW;
    2d14:	f06f 0012 	mvn.w	r0, #18
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    2d18:	7e23      	ldrb	r3, [r4, #24]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    2d1a:	f013 0f03 	tst.w	r3, #3
    2d1e:	d0fb      	beq.n	2d18 <_spi_m_sync_trans+0x80>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    2d20:	2303      	movs	r3, #3
    2d22:	7623      	strb	r3, [r4, #24]
		}
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
    2d24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    2d28:	4293      	cmp	r3, r2
    2d2a:	d8de      	bhi.n	2cea <_spi_m_sync_trans+0x52>
    2d2c:	e7f4      	b.n	2d18 <_spi_m_sync_trans+0x80>
		return ERR_BUSY;
    2d2e:	f06f 0003 	mvn.w	r0, #3
    2d32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ERR_NOT_INITIALIZED;
    2d36:	f06f 0013 	mvn.w	r0, #19
    2d3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (ctrl.rxcnt >= ctrl.txcnt) {
    2d3e:	4290      	cmp	r0, r2
    2d40:	d8cd      	bhi.n	2cde <_spi_m_sync_trans+0x46>
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    2d42:	f013 0f01 	tst.w	r3, #1
    2d46:	d0ca      	beq.n	2cde <_spi_m_sync_trans+0x46>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    2d48:	f8b9 1006 	ldrh.w	r1, [r9, #6]
	if (ctrl->txbuf) {
    2d4c:	f1b8 0f00 	cmp.w	r8, #0
    2d50:	d00b      	beq.n	2d6a <_spi_m_sync_trans+0xd2>
		data = *ctrl->txbuf++;
    2d52:	f898 1000 	ldrb.w	r1, [r8]
		if (ctrl->char_size > 1) {
    2d56:	2f01      	cmp	r7, #1
		data = *ctrl->txbuf++;
    2d58:	bf91      	iteee	ls
    2d5a:	f108 0801 	addls.w	r8, r8, #1
			data |= (*ctrl->txbuf) << 8;
    2d5e:	f898 e001 	ldrbhi.w	lr, [r8, #1]
    2d62:	ea41 210e 	orrhi.w	r1, r1, lr, lsl #8
			ctrl->txbuf++;
    2d66:	f108 0802 	addhi.w	r8, r8, #2
	ctrl->txcnt++;
    2d6a:	3001      	adds	r0, #1
	((Sercom *)hw)->SPI.DATA.reg = data;
    2d6c:	62a1      	str	r1, [r4, #40]	; 0x28
    2d6e:	e7b6      	b.n	2cde <_spi_m_sync_trans+0x46>
    2d70:	00007078 	.word	0x00007078
    2d74:	000019fd 	.word	0x000019fd

00002d78 <TIMER_1_init>:
	};
}

static inline bool hri_tc_is_syncing(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    2d78:	4b29      	ldr	r3, [pc, #164]	; (2e20 <TIMER_1_init+0xa8>)
    2d7a:	691b      	ldr	r3, [r3, #16]
 * \brief Initialize TC interface
 */
int8_t TIMER_1_init()
{

	if (!hri_tc_is_syncing(TC0, TC_SYNCBUSY_SWRST)) {
    2d7c:	f013 0f01 	tst.w	r3, #1
    2d80:	d11f      	bne.n	2dc2 <TIMER_1_init+0x4a>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2d82:	4a27      	ldr	r2, [pc, #156]	; (2e20 <TIMER_1_init+0xa8>)
    2d84:	6913      	ldr	r3, [r2, #16]
    2d86:	f013 0f03 	tst.w	r3, #3
    2d8a:	d1fb      	bne.n	2d84 <TIMER_1_init+0xc>

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2d8c:	4b24      	ldr	r3, [pc, #144]	; (2e20 <TIMER_1_init+0xa8>)
    2d8e:	681b      	ldr	r3, [r3, #0]
		if (hri_tc_get_CTRLA_reg(TC0, TC_CTRLA_ENABLE)) {
    2d90:	f013 0f02 	tst.w	r3, #2
    2d94:	d00d      	beq.n	2db2 <TIMER_1_init+0x3a>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    2d96:	4a22      	ldr	r2, [pc, #136]	; (2e20 <TIMER_1_init+0xa8>)
    2d98:	6813      	ldr	r3, [r2, #0]
    2d9a:	f023 0302 	bic.w	r3, r3, #2
    2d9e:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2da0:	6913      	ldr	r3, [r2, #16]
    2da2:	f013 0f03 	tst.w	r3, #3
    2da6:	d1fb      	bne.n	2da0 <TIMER_1_init+0x28>
    2da8:	4a1d      	ldr	r2, [pc, #116]	; (2e20 <TIMER_1_init+0xa8>)
    2daa:	6913      	ldr	r3, [r2, #16]
    2dac:	f013 0f02 	tst.w	r3, #2
    2db0:	d1fb      	bne.n	2daa <TIMER_1_init+0x32>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2db2:	2201      	movs	r2, #1
    2db4:	4b1a      	ldr	r3, [pc, #104]	; (2e20 <TIMER_1_init+0xa8>)
    2db6:	601a      	str	r2, [r3, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2db8:	461a      	mov	r2, r3
    2dba:	6913      	ldr	r3, [r2, #16]
    2dbc:	f013 0f03 	tst.w	r3, #3
    2dc0:	d1fb      	bne.n	2dba <TIMER_1_init+0x42>
    2dc2:	4a17      	ldr	r2, [pc, #92]	; (2e20 <TIMER_1_init+0xa8>)
    2dc4:	6913      	ldr	r3, [r2, #16]
    2dc6:	f013 0f01 	tst.w	r3, #1
    2dca:	d1fb      	bne.n	2dc4 <TIMER_1_init+0x4c>
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2dcc:	2208      	movs	r2, #8
    2dce:	4b14      	ldr	r3, [pc, #80]	; (2e20 <TIMER_1_init+0xa8>)
    2dd0:	601a      	str	r2, [r3, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2dd2:	461a      	mov	r2, r3
    2dd4:	6913      	ldr	r3, [r2, #16]
    2dd6:	f013 0f03 	tst.w	r3, #3
    2dda:	d1fb      	bne.n	2dd4 <TIMER_1_init+0x5c>
	((Tc *)hw)->COUNT16.CTRLBSET.reg = data;
    2ddc:	4b10      	ldr	r3, [pc, #64]	; (2e20 <TIMER_1_init+0xa8>)
    2dde:	2200      	movs	r2, #0
    2de0:	715a      	strb	r2, [r3, #5]
	((Tc *)hw)->COUNT16.CTRLBCLR.reg = ~data;
    2de2:	22ff      	movs	r2, #255	; 0xff
    2de4:	711a      	strb	r2, [r3, #4]
}

static inline void hri_tc_write_WAVE_reg(const void *const hw, hri_tc_wave_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.WAVE.reg = data;
    2de6:	2203      	movs	r2, #3
    2de8:	731a      	strb	r2, [r3, #12]
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    2dea:	4a0e      	ldr	r2, [pc, #56]	; (2e24 <TIMER_1_init+0xac>)
    2dec:	61da      	str	r2, [r3, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2dee:	461a      	mov	r2, r3
    2df0:	6913      	ldr	r3, [r2, #16]
    2df2:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2df6:	d1fb      	bne.n	2df0 <TIMER_1_init+0x78>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    2df8:	2236      	movs	r2, #54	; 0x36
    2dfa:	4b09      	ldr	r3, [pc, #36]	; (2e20 <TIMER_1_init+0xa8>)
    2dfc:	621a      	str	r2, [r3, #32]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2dfe:	461a      	mov	r2, r3
    2e00:	6913      	ldr	r3, [r2, #16]
    2e02:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2e06:	d1fb      	bne.n	2e00 <TIMER_1_init+0x88>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2e08:	4a05      	ldr	r2, [pc, #20]	; (2e20 <TIMER_1_init+0xa8>)
    2e0a:	6813      	ldr	r3, [r2, #0]
	tmp |= value << TC_CTRLA_ENABLE_Pos;
    2e0c:	f043 0302 	orr.w	r3, r3, #2
	((Tc *)hw)->COUNT16.CTRLA.reg = tmp;
    2e10:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2e12:	6913      	ldr	r3, [r2, #16]
    2e14:	f013 0f03 	tst.w	r3, #3
    2e18:	d1fb      	bne.n	2e12 <TIMER_1_init+0x9a>
	//		 | 0 << TC_INTENSET_OVF_Pos); /* Overflow Interrupt enable: disabled */
	
	hri_tc_write_CTRLA_ENABLE_bit(TC0, 1 << TC_CTRLA_ENABLE_Pos); /* Enable: enabled */

	return 0;
}
    2e1a:	2000      	movs	r0, #0
    2e1c:	4770      	bx	lr
    2e1e:	bf00      	nop
    2e20:	40003800 	.word	0x40003800
    2e24:	002527b8 	.word	0x002527b8

00002e28 <TIMER_0_init>:
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    2e28:	4b24      	ldr	r3, [pc, #144]	; (2ebc <TIMER_0_init+0x94>)
    2e2a:	691b      	ldr	r3, [r3, #16]
 * \brief Initialize TC interface
 */
int8_t TIMER_0_init()
{

	if (!hri_tc_is_syncing(TC2, TC_SYNCBUSY_SWRST)) {
    2e2c:	f013 0f01 	tst.w	r3, #1
    2e30:	d11f      	bne.n	2e72 <TIMER_0_init+0x4a>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2e32:	4a22      	ldr	r2, [pc, #136]	; (2ebc <TIMER_0_init+0x94>)
    2e34:	6913      	ldr	r3, [r2, #16]
    2e36:	f013 0f03 	tst.w	r3, #3
    2e3a:	d1fb      	bne.n	2e34 <TIMER_0_init+0xc>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2e3c:	4b1f      	ldr	r3, [pc, #124]	; (2ebc <TIMER_0_init+0x94>)
    2e3e:	681b      	ldr	r3, [r3, #0]
		if (hri_tc_get_CTRLA_reg(TC2, TC_CTRLA_ENABLE)) {
    2e40:	f013 0f02 	tst.w	r3, #2
    2e44:	d00d      	beq.n	2e62 <TIMER_0_init+0x3a>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    2e46:	4a1d      	ldr	r2, [pc, #116]	; (2ebc <TIMER_0_init+0x94>)
    2e48:	6813      	ldr	r3, [r2, #0]
    2e4a:	f023 0302 	bic.w	r3, r3, #2
    2e4e:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2e50:	6913      	ldr	r3, [r2, #16]
    2e52:	f013 0f03 	tst.w	r3, #3
    2e56:	d1fb      	bne.n	2e50 <TIMER_0_init+0x28>
    2e58:	4a18      	ldr	r2, [pc, #96]	; (2ebc <TIMER_0_init+0x94>)
    2e5a:	6913      	ldr	r3, [r2, #16]
    2e5c:	f013 0f02 	tst.w	r3, #2
    2e60:	d1fb      	bne.n	2e5a <TIMER_0_init+0x32>
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2e62:	2201      	movs	r2, #1
    2e64:	4b15      	ldr	r3, [pc, #84]	; (2ebc <TIMER_0_init+0x94>)
    2e66:	601a      	str	r2, [r3, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2e68:	461a      	mov	r2, r3
    2e6a:	6913      	ldr	r3, [r2, #16]
    2e6c:	f013 0f03 	tst.w	r3, #3
    2e70:	d1fb      	bne.n	2e6a <TIMER_0_init+0x42>
    2e72:	4a12      	ldr	r2, [pc, #72]	; (2ebc <TIMER_0_init+0x94>)
    2e74:	6913      	ldr	r3, [r2, #16]
    2e76:	f013 0f01 	tst.w	r3, #1
    2e7a:	d1fb      	bne.n	2e74 <TIMER_0_init+0x4c>
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2e7c:	2208      	movs	r2, #8
    2e7e:	4b0f      	ldr	r3, [pc, #60]	; (2ebc <TIMER_0_init+0x94>)
    2e80:	601a      	str	r2, [r3, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2e82:	461a      	mov	r2, r3
    2e84:	6913      	ldr	r3, [r2, #16]
    2e86:	f013 0f03 	tst.w	r3, #3
    2e8a:	d1fb      	bne.n	2e84 <TIMER_0_init+0x5c>
	((Tc *)hw)->COUNT16.CTRLBSET.reg = data;
    2e8c:	4b0b      	ldr	r3, [pc, #44]	; (2ebc <TIMER_0_init+0x94>)
    2e8e:	2200      	movs	r2, #0
    2e90:	715a      	strb	r2, [r3, #5]
	((Tc *)hw)->COUNT16.CTRLBCLR.reg = ~data;
    2e92:	22ff      	movs	r2, #255	; 0xff
    2e94:	711a      	strb	r2, [r3, #4]
	((Tc *)hw)->COUNT32.COUNT.reg = data;
    2e96:	2210      	movs	r2, #16
    2e98:	615a      	str	r2, [r3, #20]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2e9a:	461a      	mov	r2, r3
    2e9c:	6913      	ldr	r3, [r2, #16]
    2e9e:	f013 0f10 	tst.w	r3, #16
    2ea2:	d1fb      	bne.n	2e9c <TIMER_0_init+0x74>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2ea4:	4a05      	ldr	r2, [pc, #20]	; (2ebc <TIMER_0_init+0x94>)
    2ea6:	6813      	ldr	r3, [r2, #0]
	tmp |= value << TC_CTRLA_ENABLE_Pos;
    2ea8:	f043 0302 	orr.w	r3, r3, #2
	((Tc *)hw)->COUNT16.CTRLA.reg = tmp;
    2eac:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2eae:	6913      	ldr	r3, [r2, #16]
    2eb0:	f013 0f03 	tst.w	r3, #3
    2eb4:	d1fb      	bne.n	2eae <TIMER_0_init+0x86>
	//		 | 0 << TC_INTENSET_OVF_Pos); /* Overflow Interrupt enable: disabled */

	hri_tc_write_CTRLA_ENABLE_bit(TC2, 1 << TC_CTRLA_ENABLE_Pos); /* Enable: enabled */

	return 0;
}
    2eb6:	2000      	movs	r0, #0
    2eb8:	4770      	bx	lr
    2eba:	bf00      	nop
    2ebc:	4101a000 	.word	0x4101a000

00002ec0 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    2ec0:	2000      	movs	r0, #0
    2ec2:	4770      	bx	lr

00002ec4 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    2ec4:	b538      	push	{r3, r4, r5, lr}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    2ec6:	7c83      	ldrb	r3, [r0, #18]
    2ec8:	f003 030f 	and.w	r3, r3, #15
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    2ecc:	7cc2      	ldrb	r2, [r0, #19]

	if (!is_ctrl) {
    2ece:	f002 0107 	and.w	r1, r2, #7
    2ed2:	2901      	cmp	r1, #1
    2ed4:	d00b      	beq.n	2eee <_usb_d_dev_handle_setup+0x2a>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    2ed6:	015a      	lsls	r2, r3, #5
    2ed8:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    2edc:	2110      	movs	r1, #16
    2ede:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    2ee2:	015b      	lsls	r3, r3, #5
    2ee4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    2ee8:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    2eec:	bd38      	pop	{r3, r4, r5, pc}
	}
	/* Control transfer:
	 * SETUP transaction will terminate IN/OUT transaction,
	 * and start new transaction with received SETUP packet.
	 */
	if (_usb_d_dev_ep_is_busy(ept)) {
    2eee:	f012 0f40 	tst.w	r2, #64	; 0x40
    2ef2:	d00c      	beq.n	2f0e <_usb_d_dev_handle_setup+0x4a>
		ept->flags.bits.is_busy = 0;
    2ef4:	7cc2      	ldrb	r2, [r0, #19]
    2ef6:	f36f 1286 	bfc	r2, #6, #1
    2efa:	74c2      	strb	r2, [r0, #19]
    2efc:	015a      	lsls	r2, r3, #5
    2efe:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    2f02:	2180      	movs	r1, #128	; 0x80
    2f04:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    2f08:	2140      	movs	r1, #64	; 0x40
    2f0a:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105

		/* Stop transfer on either direction. */
		_usbd_ep_set_in_rdy(epn, 1, false);
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	ept->flags.bits.is_stalled = 0;
    2f0e:	7cc2      	ldrb	r2, [r0, #19]
    2f10:	f36f 02c3 	bfc	r2, #3, #1
    2f14:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    2f16:	4909      	ldr	r1, [pc, #36]	; (2f3c <_usb_d_dev_handle_setup+0x78>)
    2f18:	015a      	lsls	r2, r3, #5
    2f1a:	188c      	adds	r4, r1, r2
    2f1c:	2500      	movs	r5, #0
    2f1e:	72a5      	strb	r5, [r4, #10]
    2f20:	76a5      	strb	r5, [r4, #26]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    2f22:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    2f26:	246f      	movs	r4, #111	; 0x6f
    2f28:	f883 4107 	strb.w	r4, [r3, #263]	; 0x107
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    2f2c:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    2f30:	f882 4108 	strb.w	r4, [r2, #264]	; 0x108
	_usbd_ep_clear_bank_status(epn, 0);
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
    2f34:	6e8b      	ldr	r3, [r1, #104]	; 0x68
    2f36:	7c80      	ldrb	r0, [r0, #18]
    2f38:	4798      	blx	r3
    2f3a:	bd38      	pop	{r3, r4, r5, pc}
    2f3c:	20001924 	.word	0x20001924

00002f40 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    2f40:	b508      	push	{r3, lr}
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    2f42:	2320      	movs	r3, #32
    2f44:	fa03 f101 	lsl.w	r1, r3, r1
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    2f48:	b2c9      	uxtb	r1, r1
	uint8_t epn = USB_EP_GET_N(ept->ep);
    2f4a:	7c83      	ldrb	r3, [r0, #18]
    2f4c:	f003 030f 	and.w	r3, r3, #15
    2f50:	015b      	lsls	r3, r3, #5
    2f52:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    2f56:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    2f5a:	4b03      	ldr	r3, [pc, #12]	; (2f68 <_usb_d_dev_handle_stall+0x28>)
    2f5c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2f5e:	6882      	ldr	r2, [r0, #8]
    2f60:	2101      	movs	r1, #1
    2f62:	7c80      	ldrb	r0, [r0, #18]
    2f64:	4798      	blx	r3
    2f66:	bd08      	pop	{r3, pc}
    2f68:	20001924 	.word	0x20001924

00002f6c <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    2f6c:	b538      	push	{r3, r4, r5, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    2f6e:	7c84      	ldrb	r4, [r0, #18]
    2f70:	2cff      	cmp	r4, #255	; 0xff
    2f72:	d003      	beq.n	2f7c <_usb_d_dev_trans_done+0x10>
    2f74:	7cc3      	ldrb	r3, [r0, #19]
    2f76:	f013 0f40 	tst.w	r3, #64	; 0x40
    2f7a:	d100      	bne.n	2f7e <_usb_d_dev_trans_done+0x12>
    2f7c:	bd38      	pop	{r3, r4, r5, pc}
		return;
	}
	ept->flags.bits.is_busy = 0;
    2f7e:	7cc2      	ldrb	r2, [r0, #19]
    2f80:	f36f 1286 	bfc	r2, #6, #1
    2f84:	74c2      	strb	r2, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    2f86:	4a03      	ldr	r2, [pc, #12]	; (2f94 <_usb_d_dev_trans_done+0x28>)
    2f88:	6f15      	ldr	r5, [r2, #112]	; 0x70
    2f8a:	6882      	ldr	r2, [r0, #8]
    2f8c:	4620      	mov	r0, r4
    2f8e:	47a8      	blx	r5
    2f90:	e7f4      	b.n	2f7c <_usb_d_dev_trans_done+0x10>
    2f92:	bf00      	nop
    2f94:	20001924 	.word	0x20001924

00002f98 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    2f98:	b530      	push	{r4, r5, lr}
    2f9a:	b083      	sub	sp, #12
	uint8_t epn = USB_EP_GET_N(ept->ep);
    2f9c:	7c83      	ldrb	r3, [r0, #18]
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    2f9e:	2425      	movs	r4, #37	; 0x25
    2fa0:	f88d 4004 	strb.w	r4, [sp, #4]
    2fa4:	244a      	movs	r4, #74	; 0x4a
    2fa6:	f88d 4005 	strb.w	r4, [sp, #5]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    2faa:	2bff      	cmp	r3, #255	; 0xff
    2fac:	d01e      	beq.n	2fec <_usb_d_dev_trans_stop+0x54>
    2fae:	7cc4      	ldrb	r4, [r0, #19]
    2fb0:	f014 0f40 	tst.w	r4, #64	; 0x40
    2fb4:	d01a      	beq.n	2fec <_usb_d_dev_trans_stop+0x54>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    2fb6:	f003 040f 	and.w	r4, r3, #15
		return;
	}
	/* Stop transfer */
	if (dir) {
    2fba:	b1c9      	cbz	r1, 2ff0 <_usb_d_dev_trans_stop+0x58>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    2fbc:	0163      	lsls	r3, r4, #5
    2fbe:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    2fc2:	2580      	movs	r5, #128	; 0x80
    2fc4:	f883 5104 	strb.w	r5, [r3, #260]	; 0x104
    2fc8:	460b      	mov	r3, r1
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    2fca:	a902      	add	r1, sp, #8
    2fcc:	440b      	add	r3, r1
    2fce:	f813 1c04 	ldrb.w	r1, [r3, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    2fd2:	0163      	lsls	r3, r4, #5
    2fd4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    2fd8:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    2fdc:	0163      	lsls	r3, r4, #5
    2fde:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    2fe2:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    2fe6:	4611      	mov	r1, r2
    2fe8:	4b05      	ldr	r3, [pc, #20]	; (3000 <_usb_d_dev_trans_stop+0x68>)
    2fea:	4798      	blx	r3
}
    2fec:	b003      	add	sp, #12
    2fee:	bd30      	pop	{r4, r5, pc}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    2ff0:	0163      	lsls	r3, r4, #5
    2ff2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    2ff6:	2540      	movs	r5, #64	; 0x40
    2ff8:	f883 5105 	strb.w	r5, [r3, #261]	; 0x105
    2ffc:	e7e4      	b.n	2fc8 <_usb_d_dev_trans_stop+0x30>
    2ffe:	bf00      	nop
    3000:	00002f6d 	.word	0x00002f6d

00003004 <_usb_d_dev_handle_trfail>:
{
    3004:	b530      	push	{r4, r5, lr}
    3006:	b083      	sub	sp, #12
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    3008:	7c83      	ldrb	r3, [r0, #18]
    300a:	f003 030f 	and.w	r3, r3, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    300e:	2204      	movs	r2, #4
    3010:	f88d 2004 	strb.w	r2, [sp, #4]
    3014:	2208      	movs	r2, #8
    3016:	f88d 2005 	strb.w	r2, [sp, #5]
    301a:	015a      	lsls	r2, r3, #5
	uint8_t            eptype
    301c:	460c      	mov	r4, r1
    301e:	b391      	cbz	r1, 3086 <_usb_d_dev_handle_trfail+0x82>

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    3020:	f102 4182 	add.w	r1, r2, #1090519040	; 0x41000000
    3024:	f891 5100 	ldrb.w	r5, [r1, #256]	; 0x100
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    3028:	f3c5 1502 	ubfx	r5, r5, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    302c:	eb02 1104 	add.w	r1, r2, r4, lsl #4
    3030:	4a32      	ldr	r2, [pc, #200]	; (30fc <_usb_d_dev_handle_trfail+0xf8>)
    3032:	440a      	add	r2, r1
    3034:	7a91      	ldrb	r1, [r2, #10]
    3036:	b2c9      	uxtb	r1, r1
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    3038:	2d02      	cmp	r5, #2
    303a:	d02c      	beq.n	3096 <_usb_d_dev_handle_trfail+0x92>
	} else if (st.bit.ERRORFLOW) {
    303c:	f011 0f02 	tst.w	r1, #2
    3040:	d045      	beq.n	30ce <_usb_d_dev_handle_trfail+0xca>
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    3042:	7cc5      	ldrb	r5, [r0, #19]
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    3044:	7a91      	ldrb	r1, [r2, #10]
    3046:	f36f 0141 	bfc	r1, #1, #1
    304a:	7291      	strb	r1, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    304c:	aa02      	add	r2, sp, #8
    304e:	4422      	add	r2, r4
    3050:	f812 1c04 	ldrb.w	r1, [r2, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    3054:	015a      	lsls	r2, r3, #5
    3056:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    305a:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    305e:	015b      	lsls	r3, r3, #5
    3060:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    3064:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    3068:	f005 0307 	and.w	r3, r5, #7
    306c:	2b01      	cmp	r3, #1
    306e:	d143      	bne.n	30f8 <_usb_d_dev_handle_trfail+0xf4>
    3070:	7cc3      	ldrb	r3, [r0, #19]
    3072:	f013 0f40 	tst.w	r3, #64	; 0x40
    3076:	d03f      	beq.n	30f8 <_usb_d_dev_handle_trfail+0xf4>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    3078:	09d9      	lsrs	r1, r3, #7
    307a:	428c      	cmp	r4, r1
    307c:	d03c      	beq.n	30f8 <_usb_d_dev_handle_trfail+0xf4>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    307e:	2200      	movs	r2, #0
    3080:	4b1f      	ldr	r3, [pc, #124]	; (3100 <_usb_d_dev_handle_trfail+0xfc>)
    3082:	4798      	blx	r3
    3084:	e038      	b.n	30f8 <_usb_d_dev_handle_trfail+0xf4>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    3086:	0159      	lsls	r1, r3, #5
    3088:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    308c:	f891 5100 	ldrb.w	r5, [r1, #256]	; 0x100
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    3090:	f005 0507 	and.w	r5, r5, #7
    3094:	e7ca      	b.n	302c <_usb_d_dev_handle_trfail+0x28>
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    3096:	f011 0f01 	tst.w	r1, #1
    309a:	d0cf      	beq.n	303c <_usb_d_dev_handle_trfail+0x38>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    309c:	7a91      	ldrb	r1, [r2, #10]
    309e:	f36f 0100 	bfc	r1, #0, #1
    30a2:	7291      	strb	r1, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    30a4:	aa02      	add	r2, sp, #8
    30a6:	4422      	add	r2, r4
    30a8:	f812 1c04 	ldrb.w	r1, [r2, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    30ac:	015a      	lsls	r2, r3, #5
    30ae:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    30b2:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    30b6:	015b      	lsls	r3, r3, #5
    30b8:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    30bc:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    30c0:	2204      	movs	r2, #4
    30c2:	1c21      	adds	r1, r4, #0
    30c4:	bf18      	it	ne
    30c6:	2101      	movne	r1, #1
    30c8:	4b0d      	ldr	r3, [pc, #52]	; (3100 <_usb_d_dev_handle_trfail+0xfc>)
    30ca:	4798      	blx	r3
    30cc:	e014      	b.n	30f8 <_usb_d_dev_handle_trfail+0xf4>
	bank->STATUS_BK.reg     = 0;
    30ce:	eb04 0143 	add.w	r1, r4, r3, lsl #1
    30d2:	4a0a      	ldr	r2, [pc, #40]	; (30fc <_usb_d_dev_handle_trfail+0xf8>)
    30d4:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    30d8:	2100      	movs	r1, #0
    30da:	7291      	strb	r1, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    30dc:	aa02      	add	r2, sp, #8
    30de:	4414      	add	r4, r2
    30e0:	f814 1c04 	ldrb.w	r1, [r4, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    30e4:	015a      	lsls	r2, r3, #5
    30e6:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    30ea:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    30ee:	015b      	lsls	r3, r3, #5
    30f0:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    30f4:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    30f8:	b003      	add	sp, #12
    30fa:	bd30      	pop	{r4, r5, pc}
    30fc:	20001924 	.word	0x20001924
    3100:	00002f99 	.word	0x00002f99

00003104 <_usb_d_dev_reset_epts>:
{
    3104:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3108:	4d0c      	ldr	r5, [pc, #48]	; (313c <_usb_d_dev_reset_epts+0x38>)
    310a:	f105 0474 	add.w	r4, r5, #116	; 0x74
    310e:	f505 7594 	add.w	r5, r5, #296	; 0x128
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    3112:	f04f 0803 	mov.w	r8, #3
    3116:	4f0a      	ldr	r7, [pc, #40]	; (3140 <_usb_d_dev_reset_epts+0x3c>)
		dev_inst.ep[i].ep       = 0xFF;
    3118:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    311a:	4641      	mov	r1, r8
    311c:	4620      	mov	r0, r4
    311e:	47b8      	blx	r7
		dev_inst.ep[i].ep       = 0xFF;
    3120:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    3122:	2300      	movs	r3, #0
    3124:	74e3      	strb	r3, [r4, #19]
    3126:	3414      	adds	r4, #20
	for (i = 0; i < USB_D_N_EP; i++) {
    3128:	42ac      	cmp	r4, r5
    312a:	d1f6      	bne.n	311a <_usb_d_dev_reset_epts+0x16>
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    312c:	2260      	movs	r2, #96	; 0x60
    312e:	4619      	mov	r1, r3
    3130:	4802      	ldr	r0, [pc, #8]	; (313c <_usb_d_dev_reset_epts+0x38>)
    3132:	4b04      	ldr	r3, [pc, #16]	; (3144 <_usb_d_dev_reset_epts+0x40>)
    3134:	4798      	blx	r3
    3136:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    313a:	bf00      	nop
    313c:	20001924 	.word	0x20001924
    3140:	00002f6d 	.word	0x00002f6d
    3144:	00005cdb 	.word	0x00005cdb

00003148 <_usb_d_dev_in_next>:
{
    3148:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    314c:	4605      	mov	r5, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    314e:	7c84      	ldrb	r4, [r0, #18]
    3150:	f004 040f 	and.w	r4, r4, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    3154:	4688      	mov	r8, r1
    3156:	2900      	cmp	r1, #0
    3158:	f000 809f 	beq.w	329a <_usb_d_dev_in_next+0x152>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    315c:	4b58      	ldr	r3, [pc, #352]	; (32c0 <_usb_d_dev_in_next+0x178>)
    315e:	eb03 1344 	add.w	r3, r3, r4, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    3162:	6958      	ldr	r0, [r3, #20]
    3164:	f3c0 0e0d 	ubfx	lr, r0, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    3168:	8a2b      	ldrh	r3, [r5, #16]
    316a:	f240 32ff 	movw	r2, #1023	; 0x3ff
    316e:	4293      	cmp	r3, r2
    3170:	f000 808d 	beq.w	328e <_usb_d_dev_in_next+0x146>
    3174:	3b01      	subs	r3, #1
    3176:	b298      	uxth	r0, r3
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    3178:	7cef      	ldrb	r7, [r5, #19]
    317a:	f007 0707 	and.w	r7, r7, #7
	if (isr) {
    317e:	f1b8 0f00 	cmp.w	r8, #0
    3182:	d005      	beq.n	3190 <_usb_d_dev_in_next+0x48>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    3184:	0162      	lsls	r2, r4, #5
    3186:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    318a:	2302      	movs	r3, #2
    318c:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	ept->trans_count += trans_count;
    3190:	68a9      	ldr	r1, [r5, #8]
    3192:	eb0e 0301 	add.w	r3, lr, r1
    3196:	60ab      	str	r3, [r5, #8]
	if (ept->trans_count < ept->trans_size) {
    3198:	686e      	ldr	r6, [r5, #4]
    319a:	42b3      	cmp	r3, r6
    319c:	d23f      	bcs.n	321e <_usb_d_dev_in_next+0xd6>
		trans_next = ept->trans_size - ept->trans_count;
    319e:	1af6      	subs	r6, r6, r3
    31a0:	b2b6      	uxth	r6, r6
		if (ept->flags.bits.use_cache) {
    31a2:	7cea      	ldrb	r2, [r5, #19]
    31a4:	f012 0f20 	tst.w	r2, #32
    31a8:	d02d      	beq.n	3206 <_usb_d_dev_in_next+0xbe>
    31aa:	8a2a      	ldrh	r2, [r5, #16]
    31ac:	4296      	cmp	r6, r2
    31ae:	bf28      	it	cs
    31b0:	4616      	movcs	r6, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    31b2:	6829      	ldr	r1, [r5, #0]
    31b4:	4632      	mov	r2, r6
    31b6:	4419      	add	r1, r3
    31b8:	68e8      	ldr	r0, [r5, #12]
    31ba:	4b42      	ldr	r3, [pc, #264]	; (32c4 <_usb_d_dev_in_next+0x17c>)
    31bc:	4798      	blx	r3
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    31be:	68ea      	ldr	r2, [r5, #12]
	bank->ADDR.reg          = addr;
    31c0:	4b3f      	ldr	r3, [pc, #252]	; (32c0 <_usb_d_dev_in_next+0x178>)
    31c2:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    31c6:	611a      	str	r2, [r3, #16]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    31c8:	4b3d      	ldr	r3, [pc, #244]	; (32c0 <_usb_d_dev_in_next+0x178>)
    31ca:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    31ce:	695a      	ldr	r2, [r3, #20]
    31d0:	f366 020d 	bfi	r2, r6, #0, #14
    31d4:	615a      	str	r2, [r3, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    31d6:	695a      	ldr	r2, [r3, #20]
    31d8:	f36f 329b 	bfc	r2, #14, #14
    31dc:	615a      	str	r2, [r3, #20]
	if (!isr) {
    31de:	f1b8 0f00 	cmp.w	r8, #0
    31e2:	d108      	bne.n	31f6 <_usb_d_dev_in_next+0xae>
			inten = USB_D_BANK1_INT_FLAGS;
    31e4:	2f01      	cmp	r7, #1
    31e6:	bf0c      	ite	eq
    31e8:	224e      	moveq	r2, #78	; 0x4e
    31ea:	224a      	movne	r2, #74	; 0x4a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    31ec:	0163      	lsls	r3, r4, #5
    31ee:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    31f2:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    31f6:	0164      	lsls	r4, r4, #5
    31f8:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    31fc:	2380      	movs	r3, #128	; 0x80
    31fe:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
    3202:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3206:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    320a:	bf28      	it	cs
    320c:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
			_usbd_ep_set_buf(epn, 1, (uint32_t)&ept->trans_buf[ept->trans_count]);
    3210:	6829      	ldr	r1, [r5, #0]
    3212:	440b      	add	r3, r1
	bank->ADDR.reg          = addr;
    3214:	4a2a      	ldr	r2, [pc, #168]	; (32c0 <_usb_d_dev_in_next+0x178>)
    3216:	eb02 1244 	add.w	r2, r2, r4, lsl #5
    321a:	6113      	str	r3, [r2, #16]
    321c:	e7d4      	b.n	31c8 <_usb_d_dev_in_next+0x80>
	} else if (ept->flags.bits.need_zlp) {
    321e:	7ceb      	ldrb	r3, [r5, #19]
    3220:	f013 0f10 	tst.w	r3, #16
    3224:	d00f      	beq.n	3246 <_usb_d_dev_in_next+0xfe>
		ept->flags.bits.need_zlp = 0;
    3226:	7ceb      	ldrb	r3, [r5, #19]
    3228:	f36f 1304 	bfc	r3, #4, #1
    322c:	74eb      	strb	r3, [r5, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    322e:	4b24      	ldr	r3, [pc, #144]	; (32c0 <_usb_d_dev_in_next+0x178>)
    3230:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    3234:	695a      	ldr	r2, [r3, #20]
    3236:	f36f 020d 	bfc	r2, #0, #14
    323a:	615a      	str	r2, [r3, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    323c:	695a      	ldr	r2, [r3, #20]
    323e:	f36f 329b 	bfc	r2, #14, #14
    3242:	615a      	str	r2, [r3, #20]
    3244:	e7cb      	b.n	31de <_usb_d_dev_in_next+0x96>
	if (is_ctrl) {
    3246:	2f01      	cmp	r7, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    3248:	ea4f 1444 	mov.w	r4, r4, lsl #5
    324c:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    3250:	bf0c      	ite	eq
    3252:	234b      	moveq	r3, #75	; 0x4b
    3254:	234a      	movne	r3, #74	; 0x4a
    3256:	f884 3108 	strb.w	r3, [r4, #264]	; 0x108
	if (last_pkt == ept->size) {
    325a:	8a2a      	ldrh	r2, [r5, #16]
    325c:	ea00 030e 	and.w	r3, r0, lr
    3260:	429a      	cmp	r2, r3
    3262:	d005      	beq.n	3270 <_usb_d_dev_in_next+0x128>
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    3264:	2100      	movs	r1, #0
    3266:	4628      	mov	r0, r5
    3268:	4b17      	ldr	r3, [pc, #92]	; (32c8 <_usb_d_dev_in_next+0x180>)
    326a:	4798      	blx	r3
	return;
    326c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ept->flags.bits.is_busy = 0;
    3270:	7ceb      	ldrb	r3, [r5, #19]
    3272:	f36f 1386 	bfc	r3, #6, #1
    3276:	74eb      	strb	r3, [r5, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    3278:	4b11      	ldr	r3, [pc, #68]	; (32c0 <_usb_d_dev_in_next+0x178>)
    327a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    327c:	68a9      	ldr	r1, [r5, #8]
    327e:	7ca8      	ldrb	r0, [r5, #18]
    3280:	4798      	blx	r3
    3282:	b9d0      	cbnz	r0, 32ba <_usb_d_dev_in_next+0x172>
		ept->flags.bits.is_busy = 1;
    3284:	7ceb      	ldrb	r3, [r5, #19]
    3286:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    328a:	74eb      	strb	r3, [r5, #19]
    328c:	e7ea      	b.n	3264 <_usb_d_dev_in_next+0x11c>
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    328e:	7cef      	ldrb	r7, [r5, #19]
    3290:	f007 0707 	and.w	r7, r7, #7
    3294:	f240 30ff 	movw	r0, #1023	; 0x3ff
    3298:	e774      	b.n	3184 <_usb_d_dev_in_next+0x3c>
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    329a:	8a03      	ldrh	r3, [r0, #16]
    329c:	f240 32ff 	movw	r2, #1023	; 0x3ff
    32a0:	4293      	cmp	r3, r2
    32a2:	d107      	bne.n	32b4 <_usb_d_dev_in_next+0x16c>
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    32a4:	7cef      	ldrb	r7, [r5, #19]
    32a6:	f007 0707 	and.w	r7, r7, #7
    32aa:	f04f 0e00 	mov.w	lr, #0
    32ae:	f240 30ff 	movw	r0, #1023	; 0x3ff
    32b2:	e76d      	b.n	3190 <_usb_d_dev_in_next+0x48>
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    32b4:	f04f 0e00 	mov.w	lr, #0
    32b8:	e75c      	b.n	3174 <_usb_d_dev_in_next+0x2c>
    32ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    32be:	bf00      	nop
    32c0:	20001924 	.word	0x20001924
    32c4:	00005cc5 	.word	0x00005cc5
    32c8:	00002f6d 	.word	0x00002f6d

000032cc <_usb_d_dev_out_next>:
{
    32cc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    32d0:	4604      	mov	r4, r0
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    32d2:	7c85      	ldrb	r5, [r0, #18]
    32d4:	f005 050f 	and.w	r5, r5, #15
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    32d8:	4689      	mov	r9, r1
    32da:	2900      	cmp	r1, #0
    32dc:	d056      	beq.n	338c <_usb_d_dev_out_next+0xc0>
    32de:	4b74      	ldr	r3, [pc, #464]	; (34b0 <_usb_d_dev_out_next+0x1e4>)
    32e0:	eb03 1345 	add.w	r3, r3, r5, lsl #5
    32e4:	685a      	ldr	r2, [r3, #4]
    32e6:	f3c2 3a8d 	ubfx	sl, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    32ea:	685f      	ldr	r7, [r3, #4]
    32ec:	f3c7 070d 	ubfx	r7, r7, #0, #14
    32f0:	46bb      	mov	fp, r7
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    32f2:	8a06      	ldrh	r6, [r0, #16]
    32f4:	f240 33ff 	movw	r3, #1023	; 0x3ff
    32f8:	429e      	cmp	r6, r3
    32fa:	f000 80ba 	beq.w	3472 <_usb_d_dev_out_next+0x1a6>
    32fe:	3e01      	subs	r6, #1
    3300:	b2b6      	uxth	r6, r6
	uint16_t           last_pkt   = last_trans & size_mask;
    3302:	ea06 070b 	and.w	r7, r6, fp
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    3306:	f894 8013 	ldrb.w	r8, [r4, #19]
    330a:	f008 0807 	and.w	r8, r8, #7
	if (isr) {
    330e:	f1b9 0f00 	cmp.w	r9, #0
    3312:	d005      	beq.n	3320 <_usb_d_dev_out_next+0x54>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    3314:	016b      	lsls	r3, r5, #5
    3316:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    331a:	2201      	movs	r2, #1
    331c:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    3320:	7ce3      	ldrb	r3, [r4, #19]
    3322:	f013 0f20 	tst.w	r3, #32
    3326:	d00d      	beq.n	3344 <_usb_d_dev_out_next+0x78>
    3328:	6862      	ldr	r2, [r4, #4]
    332a:	2a00      	cmp	r2, #0
    332c:	d037      	beq.n	339e <_usb_d_dev_out_next+0xd2>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    332e:	68a0      	ldr	r0, [r4, #8]
    3330:	1a12      	subs	r2, r2, r0
    3332:	b292      	uxth	r2, r2
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    3334:	6823      	ldr	r3, [r4, #0]
    3336:	42ba      	cmp	r2, r7
    3338:	bf28      	it	cs
    333a:	463a      	movcs	r2, r7
    333c:	68e1      	ldr	r1, [r4, #12]
    333e:	4418      	add	r0, r3
    3340:	4b5c      	ldr	r3, [pc, #368]	; (34b4 <_usb_d_dev_out_next+0x1e8>)
    3342:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    3344:	6863      	ldr	r3, [r4, #4]
    3346:	b353      	cbz	r3, 339e <_usb_d_dev_out_next+0xd2>
	} else if (isr && last_pkt < ept->size) {
    3348:	f1b9 0f00 	cmp.w	r9, #0
    334c:	d040      	beq.n	33d0 <_usb_d_dev_out_next+0x104>
    334e:	8a22      	ldrh	r2, [r4, #16]
    3350:	42ba      	cmp	r2, r7
    3352:	d93d      	bls.n	33d0 <_usb_d_dev_out_next+0x104>
		ept->flags.bits.need_zlp = 0;
    3354:	7ce3      	ldrb	r3, [r4, #19]
    3356:	f36f 1304 	bfc	r3, #4, #1
    335a:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    335c:	68a3      	ldr	r3, [r4, #8]
    335e:	445b      	add	r3, fp
    3360:	60a3      	str	r3, [r4, #8]
	if (is_ctrl) {
    3362:	f1b8 0f01 	cmp.w	r8, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    3366:	ea4f 1345 	mov.w	r3, r5, lsl #5
    336a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    336e:	bf0c      	ite	eq
    3370:	222d      	moveq	r2, #45	; 0x2d
    3372:	2225      	movne	r2, #37	; 0x25
    3374:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	if (0 == epn) {
    3378:	b915      	cbnz	r5, 3380 <_usb_d_dev_out_next+0xb4>
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    337a:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    337c:	4b4c      	ldr	r3, [pc, #304]	; (34b0 <_usb_d_dev_out_next+0x1e4>)
    337e:	601a      	str	r2, [r3, #0]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    3380:	2100      	movs	r1, #0
    3382:	4620      	mov	r0, r4
    3384:	4b4c      	ldr	r3, [pc, #304]	; (34b8 <_usb_d_dev_out_next+0x1ec>)
    3386:	4798      	blx	r3
	return;
    3388:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    338c:	8a06      	ldrh	r6, [r0, #16]
    338e:	f240 33ff 	movw	r3, #1023	; 0x3ff
    3392:	429e      	cmp	r6, r3
    3394:	d07b      	beq.n	348e <_usb_d_dev_out_next+0x1c2>
    3396:	f04f 0b00 	mov.w	fp, #0
    339a:	46da      	mov	sl, fp
    339c:	e7af      	b.n	32fe <_usb_d_dev_out_next+0x32>
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    339e:	7ce3      	ldrb	r3, [r4, #19]
    33a0:	f013 0f10 	tst.w	r3, #16
    33a4:	d06c      	beq.n	3480 <_usb_d_dev_out_next+0x1b4>
		ept->flags.bits.need_zlp  = 0;
    33a6:	7ce3      	ldrb	r3, [r4, #19]
		ept->flags.bits.use_cache = 1;
    33a8:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    33ac:	f043 0320 	orr.w	r3, r3, #32
    33b0:	74e3      	strb	r3, [r4, #19]
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    33b2:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    33b4:	493e      	ldr	r1, [pc, #248]	; (34b0 <_usb_d_dev_out_next+0x1e4>)
    33b6:	016a      	lsls	r2, r5, #5
    33b8:	188b      	adds	r3, r1, r2
    33ba:	5088      	str	r0, [r1, r2]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    33bc:	8a21      	ldrh	r1, [r4, #16]
    33be:	685a      	ldr	r2, [r3, #4]
    33c0:	f361 329b 	bfi	r2, r1, #14, #14
    33c4:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    33c6:	685a      	ldr	r2, [r3, #4]
    33c8:	f36f 020d 	bfc	r2, #0, #14
    33cc:	605a      	str	r2, [r3, #4]
    33ce:	e01d      	b.n	340c <_usb_d_dev_out_next+0x140>
		ept->trans_count += trans_size;
    33d0:	68a2      	ldr	r2, [r4, #8]
    33d2:	4452      	add	r2, sl
    33d4:	60a2      	str	r2, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    33d6:	4293      	cmp	r3, r2
    33d8:	d9c3      	bls.n	3362 <_usb_d_dev_out_next+0x96>
			trans_next = ept->trans_size - ept->trans_count;
    33da:	1a9b      	subs	r3, r3, r2
    33dc:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    33de:	7ce1      	ldrb	r1, [r4, #19]
    33e0:	f011 0f20 	tst.w	r1, #32
    33e4:	d026      	beq.n	3434 <_usb_d_dev_out_next+0x168>
    33e6:	8a22      	ldrh	r2, [r4, #16]
    33e8:	4293      	cmp	r3, r2
    33ea:	bf28      	it	cs
    33ec:	4613      	movcs	r3, r2
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    33ee:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    33f0:	016a      	lsls	r2, r5, #5
    33f2:	492f      	ldr	r1, [pc, #188]	; (34b0 <_usb_d_dev_out_next+0x1e4>)
    33f4:	5088      	str	r0, [r1, r2]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    33f6:	4a2e      	ldr	r2, [pc, #184]	; (34b0 <_usb_d_dev_out_next+0x1e4>)
    33f8:	eb02 1245 	add.w	r2, r2, r5, lsl #5
    33fc:	6851      	ldr	r1, [r2, #4]
    33fe:	f363 319b 	bfi	r1, r3, #14, #14
    3402:	6051      	str	r1, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    3404:	6853      	ldr	r3, [r2, #4]
    3406:	f36f 030d 	bfc	r3, #0, #14
    340a:	6053      	str	r3, [r2, #4]
	if (!isr) {
    340c:	f1b9 0f00 	cmp.w	r9, #0
    3410:	d108      	bne.n	3424 <_usb_d_dev_out_next+0x158>
		if (is_ctrl) {
    3412:	f1b8 0f01 	cmp.w	r8, #1
    3416:	d025      	beq.n	3464 <_usb_d_dev_out_next+0x198>
			inten = USB_D_BANK0_INT_FLAGS;
    3418:	2225      	movs	r2, #37	; 0x25
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    341a:	016b      	lsls	r3, r5, #5
    341c:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    3420:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    3424:	016d      	lsls	r5, r5, #5
    3426:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    342a:	2340      	movs	r3, #64	; 0x40
    342c:	f885 3104 	strb.w	r3, [r5, #260]	; 0x104
    3430:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (trans_next > ept->size) {
    3434:	8a21      	ldrh	r1, [r4, #16]
    3436:	428b      	cmp	r3, r1
    3438:	d90a      	bls.n	3450 <_usb_d_dev_out_next+0x184>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    343a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    343e:	d80e      	bhi.n	345e <_usb_d_dev_out_next+0x192>
    3440:	ea23 0306 	bic.w	r3, r3, r6
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    3444:	6821      	ldr	r1, [r4, #0]
    3446:	440a      	add	r2, r1
	bank->ADDR.reg          = addr;
    3448:	0169      	lsls	r1, r5, #5
    344a:	4819      	ldr	r0, [pc, #100]	; (34b0 <_usb_d_dev_out_next+0x1e4>)
    344c:	5042      	str	r2, [r0, r1]
    344e:	e7d2      	b.n	33f6 <_usb_d_dev_out_next+0x12a>
				} else if (trans_next < ept->size) {
    3450:	428b      	cmp	r3, r1
    3452:	d2f7      	bcs.n	3444 <_usb_d_dev_out_next+0x178>
					ept->flags.bits.use_cache = 1;
    3454:	7ce1      	ldrb	r1, [r4, #19]
    3456:	f041 0120 	orr.w	r1, r1, #32
    345a:	74e1      	strb	r1, [r4, #19]
    345c:	e7f2      	b.n	3444 <_usb_d_dev_out_next+0x178>
						trans_next = USB_D_DEV_TRANS_MAX;
    345e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    3462:	e7ef      	b.n	3444 <_usb_d_dev_out_next+0x178>
	bank->STATUS_BK.reg     = 0;
    3464:	4b12      	ldr	r3, [pc, #72]	; (34b0 <_usb_d_dev_out_next+0x1e4>)
    3466:	eb03 1345 	add.w	r3, r3, r5, lsl #5
    346a:	2200      	movs	r2, #0
    346c:	769a      	strb	r2, [r3, #26]
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    346e:	222d      	movs	r2, #45	; 0x2d
    3470:	e7d3      	b.n	341a <_usb_d_dev_out_next+0x14e>
	uint16_t           last_pkt   = last_trans & size_mask;
    3472:	f3c7 0709 	ubfx	r7, r7, #0, #10
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    3476:	f890 8013 	ldrb.w	r8, [r0, #19]
    347a:	f008 0807 	and.w	r8, r8, #7
    347e:	e749      	b.n	3314 <_usb_d_dev_out_next+0x48>
	} else if (isr && last_pkt < ept->size) {
    3480:	f1b9 0f00 	cmp.w	r9, #0
    3484:	d10b      	bne.n	349e <_usb_d_dev_out_next+0x1d2>
		ept->trans_count += trans_size;
    3486:	68a3      	ldr	r3, [r4, #8]
    3488:	4453      	add	r3, sl
    348a:	60a3      	str	r3, [r4, #8]
    348c:	e769      	b.n	3362 <_usb_d_dev_out_next+0x96>
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    348e:	f890 8013 	ldrb.w	r8, [r0, #19]
    3492:	f008 0807 	and.w	r8, r8, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    3496:	2700      	movs	r7, #0
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    3498:	46bb      	mov	fp, r7
    349a:	46ba      	mov	sl, r7
    349c:	e740      	b.n	3320 <_usb_d_dev_out_next+0x54>
	} else if (isr && last_pkt < ept->size) {
    349e:	8a23      	ldrh	r3, [r4, #16]
    34a0:	42bb      	cmp	r3, r7
    34a2:	f63f af57 	bhi.w	3354 <_usb_d_dev_out_next+0x88>
		ept->trans_count += trans_size;
    34a6:	68a3      	ldr	r3, [r4, #8]
    34a8:	4453      	add	r3, sl
    34aa:	60a3      	str	r3, [r4, #8]
    34ac:	e759      	b.n	3362 <_usb_d_dev_out_next+0x96>
    34ae:	bf00      	nop
    34b0:	20001924 	.word	0x20001924
    34b4:	00005cc5 	.word	0x00005cc5
    34b8:	00002f6d 	.word	0x00002f6d

000034bc <_usb_d_dev_handler>:
{
    34bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    34c0:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    34c4:	8c1e      	ldrh	r6, [r3, #32]
    34c6:	b2b6      	uxth	r6, r6
	if (0 == epint) {
    34c8:	b146      	cbz	r6, 34dc <_usb_d_dev_handler+0x20>
    34ca:	4d91      	ldr	r5, [pc, #580]	; (3710 <_usb_d_dev_handler+0x254>)
	uint32_t lpm_variable = 0;
    34cc:	2400      	movs	r4, #0
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    34ce:	f1a5 0774 	sub.w	r7, r5, #116	; 0x74
			_usb_d_dev_handle_setup(ept);
    34d2:	f8df 9258 	ldr.w	r9, [pc, #600]	; 372c <_usb_d_dev_handler+0x270>
			_usb_d_dev_handle_trfail(ept, 1);
    34d6:	f8df 8258 	ldr.w	r8, [pc, #600]	; 3730 <_usb_d_dev_handler+0x274>
    34da:	e0d3      	b.n	3684 <_usb_d_dev_handler+0x1c8>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    34dc:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    34de:	8b1b      	ldrh	r3, [r3, #24]
    34e0:	b29b      	uxth	r3, r3
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    34e2:	400b      	ands	r3, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    34e4:	f013 0f04 	tst.w	r3, #4
    34e8:	d11d      	bne.n	3526 <_usb_d_dev_handler+0x6a>
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    34ea:	f413 7f00 	tst.w	r3, #512	; 0x200
    34ee:	d123      	bne.n	3538 <_usb_d_dev_handler+0x7c>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    34f0:	f013 0f80 	tst.w	r3, #128	; 0x80
    34f4:	d147      	bne.n	3586 <_usb_d_dev_handler+0xca>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    34f6:	f013 0f70 	tst.w	r3, #112	; 0x70
    34fa:	d14f      	bne.n	359c <_usb_d_dev_handler+0xe0>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    34fc:	f013 0f08 	tst.w	r3, #8
    3500:	d16e      	bne.n	35e0 <_usb_d_dev_handler+0x124>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    3502:	f013 0f01 	tst.w	r3, #1
    3506:	d0e0      	beq.n	34ca <_usb_d_dev_handler+0xe>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    3508:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    350c:	f240 2201 	movw	r2, #513	; 0x201
    3510:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    3512:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    3514:	2270      	movs	r2, #112	; 0x70
    3516:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    3518:	4b7e      	ldr	r3, [pc, #504]	; (3714 <_usb_d_dev_handler+0x258>)
    351a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    351c:	2100      	movs	r1, #0
    351e:	2004      	movs	r0, #4
    3520:	4798      	blx	r3
    3522:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    3526:	2204      	movs	r2, #4
    3528:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    352c:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    352e:	4b79      	ldr	r3, [pc, #484]	; (3714 <_usb_d_dev_handler+0x258>)
    3530:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3532:	4798      	blx	r3
    3534:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3538:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    353c:	f240 2201 	movw	r2, #513	; 0x201
    3540:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    3542:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    3544:	2270      	movs	r2, #112	; 0x70
    3546:	831a      	strh	r2, [r3, #24]
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    3548:	4b72      	ldr	r3, [pc, #456]	; (3714 <_usb_d_dev_handler+0x258>)
    354a:	891b      	ldrh	r3, [r3, #8]
    354c:	f003 030f 	and.w	r3, r3, #15
    3550:	2b03      	cmp	r3, #3
    3552:	d00e      	beq.n	3572 <_usb_d_dev_handler+0xb6>
    3554:	4b6f      	ldr	r3, [pc, #444]	; (3714 <_usb_d_dev_handler+0x258>)
    3556:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    3558:	f003 030f 	and.w	r3, r3, #15
    355c:	2b03      	cmp	r3, #3
		UsbDeviceDescBank *bank = &prvt_inst.desc_table[i].DeviceDescBank[0];
    355e:	bf08      	it	eq
    3560:	2201      	moveq	r2, #1
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    3562:	d007      	beq.n	3574 <_usb_d_dev_handler+0xb8>
	uint32_t lpm_variable = 0;
    3564:	2100      	movs	r1, #0
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    3566:	4b6b      	ldr	r3, [pc, #428]	; (3714 <_usb_d_dev_handler+0x258>)
    3568:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    356a:	2003      	movs	r0, #3
    356c:	4798      	blx	r3
    356e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		UsbDeviceDescBank *bank = &prvt_inst.desc_table[i].DeviceDescBank[0];
    3572:	2200      	movs	r2, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    3574:	4b67      	ldr	r3, [pc, #412]	; (3714 <_usb_d_dev_handler+0x258>)
    3576:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    357a:	8919      	ldrh	r1, [r3, #8]
    357c:	f3c1 110a 	ubfx	r1, r1, #4, #11
			bank->EXTREG.reg = 0;
    3580:	2200      	movs	r2, #0
    3582:	811a      	strh	r2, [r3, #8]
    3584:	e7ef      	b.n	3566 <_usb_d_dev_handler+0xaa>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    3586:	2280      	movs	r2, #128	; 0x80
    3588:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    358c:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    358e:	4b61      	ldr	r3, [pc, #388]	; (3714 <_usb_d_dev_handler+0x258>)
    3590:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    3592:	2100      	movs	r1, #0
    3594:	2005      	movs	r0, #5
    3596:	4798      	blx	r3
    3598:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    359c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    35a0:	2270      	movs	r2, #112	; 0x70
    35a2:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    35a4:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    35a6:	f240 2201 	movw	r2, #513	; 0x201
    35aa:	831a      	strh	r2, [r3, #24]
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    35ac:	4b5a      	ldr	r3, [pc, #360]	; (3718 <_usb_d_dev_handler+0x25c>)
    35ae:	f893 3020 	ldrb.w	r3, [r3, #32]
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    35b2:	f013 0f01 	tst.w	r3, #1
    35b6:	d00d      	beq.n	35d4 <_usb_d_dev_handler+0x118>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    35b8:	4a57      	ldr	r2, [pc, #348]	; (3718 <_usb_d_dev_handler+0x25c>)
    35ba:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    35bc:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    35c0:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    35c4:	d1f9      	bne.n	35ba <_usb_d_dev_handler+0xfe>
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    35c6:	4b53      	ldr	r3, [pc, #332]	; (3714 <_usb_d_dev_handler+0x258>)
    35c8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    35ca:	2100      	movs	r1, #0
    35cc:	2002      	movs	r0, #2
    35ce:	4798      	blx	r3
    35d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    35d4:	4a50      	ldr	r2, [pc, #320]	; (3718 <_usb_d_dev_handler+0x25c>)
    35d6:	6913      	ldr	r3, [r2, #16]
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    35d8:	f413 7f80 	tst.w	r3, #256	; 0x100
    35dc:	d0fb      	beq.n	35d6 <_usb_d_dev_handler+0x11a>
    35de:	e7f2      	b.n	35c6 <_usb_d_dev_handler+0x10a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    35e0:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    35e4:	2400      	movs	r4, #0
    35e6:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    35ea:	2208      	movs	r2, #8
    35ec:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    35ee:	2270      	movs	r2, #112	; 0x70
    35f0:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    35f2:	f240 2201 	movw	r2, #513	; 0x201
    35f6:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    35f8:	4b48      	ldr	r3, [pc, #288]	; (371c <_usb_d_dev_handler+0x260>)
    35fa:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    35fc:	4b45      	ldr	r3, [pc, #276]	; (3714 <_usb_d_dev_handler+0x258>)
    35fe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    3600:	4621      	mov	r1, r4
    3602:	2001      	movs	r0, #1
    3604:	4798      	blx	r3
    3606:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    360a:	f011 0f10 	tst.w	r1, #16
    360e:	d109      	bne.n	3624 <_usb_d_dev_handler+0x168>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    3610:	f011 0f40 	tst.w	r1, #64	; 0x40
    3614:	d108      	bne.n	3628 <_usb_d_dev_handler+0x16c>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    3616:	f011 0f20 	tst.w	r1, #32
    361a:	d02f      	beq.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 0);
    361c:	2100      	movs	r1, #0
    361e:	4b40      	ldr	r3, [pc, #256]	; (3720 <_usb_d_dev_handler+0x264>)
    3620:	4798      	blx	r3
    3622:	e02b      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_setup(ept);
    3624:	47c8      	blx	r9
    3626:	e029      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 1);
    3628:	2101      	movs	r1, #1
    362a:	4b3d      	ldr	r3, [pc, #244]	; (3720 <_usb_d_dev_handler+0x264>)
    362c:	4798      	blx	r3
    362e:	e025      	b.n	367c <_usb_d_dev_handler+0x1c0>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    3630:	f011 0f40 	tst.w	r1, #64	; 0x40
    3634:	d111      	bne.n	365a <_usb_d_dev_handler+0x19e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    3636:	f011 0f08 	tst.w	r1, #8
    363a:	d112      	bne.n	3662 <_usb_d_dev_handler+0x1a6>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    363c:	f011 0f02 	tst.w	r1, #2
    3640:	d112      	bne.n	3668 <_usb_d_dev_handler+0x1ac>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    3642:	f003 0307 	and.w	r3, r3, #7
    3646:	2b01      	cmp	r3, #1
    3648:	d118      	bne.n	367c <_usb_d_dev_handler+0x1c0>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    364a:	f011 0f04 	tst.w	r1, #4
    364e:	d10f      	bne.n	3670 <_usb_d_dev_handler+0x1b4>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    3650:	f011 0f10 	tst.w	r1, #16
    3654:	d012      	beq.n	367c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_setup(ept);
    3656:	47c8      	blx	r9
    3658:	e010      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 1);
    365a:	2101      	movs	r1, #1
    365c:	4b30      	ldr	r3, [pc, #192]	; (3720 <_usb_d_dev_handler+0x264>)
    365e:	4798      	blx	r3
    3660:	e00c      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_trfail(ept, 1);
    3662:	2101      	movs	r1, #1
    3664:	47c0      	blx	r8
    3666:	e009      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_in_next(ept, true);
    3668:	2101      	movs	r1, #1
    366a:	4b2e      	ldr	r3, [pc, #184]	; (3724 <_usb_d_dev_handler+0x268>)
    366c:	4798      	blx	r3
    366e:	e005      	b.n	367c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_trfail(ept, 0);
    3670:	2100      	movs	r1, #0
    3672:	47c0      	blx	r8
    3674:	e002      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 0);
    3676:	2100      	movs	r1, #0
    3678:	4b29      	ldr	r3, [pc, #164]	; (3720 <_usb_d_dev_handler+0x264>)
    367a:	4798      	blx	r3
    367c:	3401      	adds	r4, #1
    367e:	3514      	adds	r5, #20
	for (i = 0; i < USB_D_N_EP; i++) {
    3680:	2c09      	cmp	r4, #9
    3682:	d042      	beq.n	370a <_usb_d_dev_handler+0x24e>
    3684:	4628      	mov	r0, r5
		if (ept->ep == 0xFF) {
    3686:	7cab      	ldrb	r3, [r5, #18]
    3688:	2bff      	cmp	r3, #255	; 0xff
    368a:	d0f7      	beq.n	367c <_usb_d_dev_handler+0x1c0>
	if (!(epint & (1u << epn))) {
    368c:	f003 030f 	and.w	r3, r3, #15
    3690:	2101      	movs	r1, #1
    3692:	4099      	lsls	r1, r3
    3694:	4231      	tst	r1, r6
    3696:	d0f1      	beq.n	367c <_usb_d_dev_handler+0x1c0>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    3698:	0159      	lsls	r1, r3, #5
    369a:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    369e:	f501 7180 	add.w	r1, r1, #256	; 0x100
    36a2:	79c9      	ldrb	r1, [r1, #7]
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    36a4:	015b      	lsls	r3, r3, #5
    36a6:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    36aa:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
	if (flags) {
    36ae:	4019      	ands	r1, r3
    36b0:	d0e4      	beq.n	367c <_usb_d_dev_handler+0x1c0>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    36b2:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    36b6:	eb07 0282 	add.w	r2, r7, r2, lsl #2
    36ba:	f892 3087 	ldrb.w	r3, [r2, #135]	; 0x87
    36be:	f003 0247 	and.w	r2, r3, #71	; 0x47
    36c2:	2a01      	cmp	r2, #1
    36c4:	d0a1      	beq.n	360a <_usb_d_dev_handler+0x14e>
		} else if (_usb_d_dev_ep_is_in(ept)) {
    36c6:	f013 0f80 	tst.w	r3, #128	; 0x80
    36ca:	d1b1      	bne.n	3630 <_usb_d_dev_handler+0x174>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    36cc:	f011 0f20 	tst.w	r1, #32
    36d0:	d1d1      	bne.n	3676 <_usb_d_dev_handler+0x1ba>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    36d2:	f011 0f04 	tst.w	r1, #4
    36d6:	d10e      	bne.n	36f6 <_usb_d_dev_handler+0x23a>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    36d8:	f011 0f01 	tst.w	r1, #1
    36dc:	d10e      	bne.n	36fc <_usb_d_dev_handler+0x240>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    36de:	f003 0307 	and.w	r3, r3, #7
    36e2:	2b01      	cmp	r3, #1
    36e4:	d1ca      	bne.n	367c <_usb_d_dev_handler+0x1c0>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    36e6:	f011 0f08 	tst.w	r1, #8
    36ea:	d10b      	bne.n	3704 <_usb_d_dev_handler+0x248>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    36ec:	f011 0f10 	tst.w	r1, #16
    36f0:	d0c4      	beq.n	367c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_setup(ept);
    36f2:	47c8      	blx	r9
    36f4:	e7c2      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_trfail(ept, 0);
    36f6:	2100      	movs	r1, #0
    36f8:	47c0      	blx	r8
    36fa:	e7bf      	b.n	367c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_out_next(ept, true);
    36fc:	2101      	movs	r1, #1
    36fe:	4b0a      	ldr	r3, [pc, #40]	; (3728 <_usb_d_dev_handler+0x26c>)
    3700:	4798      	blx	r3
    3702:	e7bb      	b.n	367c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_trfail(ept, 1);
    3704:	2101      	movs	r1, #1
    3706:	47c0      	blx	r8
    3708:	e7b8      	b.n	367c <_usb_d_dev_handler+0x1c0>
    370a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    370e:	bf00      	nop
    3710:	20001998 	.word	0x20001998
    3714:	20001924 	.word	0x20001924
    3718:	40001000 	.word	0x40001000
    371c:	00003105 	.word	0x00003105
    3720:	00002f41 	.word	0x00002f41
    3724:	00003149 	.word	0x00003149
    3728:	000032cd 	.word	0x000032cd
    372c:	00002ec5 	.word	0x00002ec5
    3730:	00003005 	.word	0x00003005

00003734 <_usb_d_dev_init>:
{
    3734:	b508      	push	{r3, lr}
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    3736:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    373a:	789b      	ldrb	r3, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    373c:	f013 0f01 	tst.w	r3, #1
    3740:	d124      	bne.n	378c <_usb_d_dev_init+0x58>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    3742:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    3746:	7893      	ldrb	r3, [r2, #2]
    3748:	f013 0f03 	tst.w	r3, #3
    374c:	d1fb      	bne.n	3746 <_usb_d_dev_init+0x12>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    374e:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    3752:	781b      	ldrb	r3, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    3754:	f013 0f02 	tst.w	r3, #2
    3758:	d00f      	beq.n	377a <_usb_d_dev_init+0x46>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    375a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    375e:	7813      	ldrb	r3, [r2, #0]
    3760:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    3764:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    3766:	7893      	ldrb	r3, [r2, #2]
    3768:	f013 0f03 	tst.w	r3, #3
    376c:	d1fb      	bne.n	3766 <_usb_d_dev_init+0x32>
    376e:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    3772:	7893      	ldrb	r3, [r2, #2]
    3774:	f013 0f02 	tst.w	r3, #2
    3778:	d1fb      	bne.n	3772 <_usb_d_dev_init+0x3e>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    377a:	2201      	movs	r2, #1
    377c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    3780:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    3782:	461a      	mov	r2, r3
    3784:	7893      	ldrb	r3, [r2, #2]
    3786:	f013 0f03 	tst.w	r3, #3
    378a:	d1fb      	bne.n	3784 <_usb_d_dev_init+0x50>
    378c:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    3790:	7893      	ldrb	r3, [r2, #2]
    3792:	f013 0f01 	tst.w	r3, #1
    3796:	d1fb      	bne.n	3790 <_usb_d_dev_init+0x5c>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    3798:	4b21      	ldr	r3, [pc, #132]	; (3820 <_usb_d_dev_init+0xec>)
    379a:	4a22      	ldr	r2, [pc, #136]	; (3824 <_usb_d_dev_init+0xf0>)
    379c:	661a      	str	r2, [r3, #96]	; 0x60
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    379e:	665a      	str	r2, [r3, #100]	; 0x64
	dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)_dummy_func_no_return;
    37a0:	669a      	str	r2, [r3, #104]	; 0x68
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    37a2:	66da      	str	r2, [r3, #108]	; 0x6c
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    37a4:	671a      	str	r2, [r3, #112]	; 0x70
	_usb_d_dev_reset_epts();
    37a6:	4b20      	ldr	r3, [pc, #128]	; (3828 <_usb_d_dev_init+0xf4>)
    37a8:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    37aa:	4b20      	ldr	r3, [pc, #128]	; (382c <_usb_d_dev_init+0xf8>)
    37ac:	6819      	ldr	r1, [r3, #0]
	uint32_t pad_transp
    37ae:	f3c1 1344 	ubfx	r3, r1, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    37b2:	f3c1 2282 	ubfx	r2, r1, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    37b6:	f011 011f 	ands.w	r1, r1, #31
    37ba:	d02b      	beq.n	3814 <_usb_d_dev_init+0xe0>
		pad_transn = 9;
    37bc:	291f      	cmp	r1, #31
    37be:	bf08      	it	eq
    37c0:	2109      	moveq	r1, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    37c2:	b34b      	cbz	r3, 3818 <_usb_d_dev_init+0xe4>
		pad_transp = 25;
    37c4:	2b1f      	cmp	r3, #31
    37c6:	bf08      	it	eq
    37c8:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    37ca:	b33a      	cbz	r2, 381c <_usb_d_dev_init+0xe8>
		pad_trim = 6;
    37cc:	2a07      	cmp	r2, #7
    37ce:	bf08      	it	eq
    37d0:	2206      	moveq	r2, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    37d2:	f003 031f 	and.w	r3, r3, #31
    37d6:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
    37da:	0312      	lsls	r2, r2, #12
    37dc:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
    37e0:	4313      	orrs	r3, r2
    37e2:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    37e6:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    37e8:	78d3      	ldrb	r3, [r2, #3]
    37ea:	f043 0303 	orr.w	r3, r3, #3
    37ee:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    37f0:	78d3      	ldrb	r3, [r2, #3]
    37f2:	f043 030c 	orr.w	r3, r3, #12
    37f6:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->HOST.CTRLA.reg = data;
    37f8:	2304      	movs	r3, #4
    37fa:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    37fc:	7893      	ldrb	r3, [r2, #2]
    37fe:	f013 0f03 	tst.w	r3, #3
    3802:	d1fb      	bne.n	37fc <_usb_d_dev_init+0xc8>
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    3804:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    3808:	4a05      	ldr	r2, [pc, #20]	; (3820 <_usb_d_dev_init+0xec>)
    380a:	625a      	str	r2, [r3, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    380c:	2201      	movs	r2, #1
    380e:	811a      	strh	r2, [r3, #8]
}
    3810:	2000      	movs	r0, #0
    3812:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    3814:	2109      	movs	r1, #9
    3816:	e7d4      	b.n	37c2 <_usb_d_dev_init+0x8e>
		pad_transp = 25;
    3818:	2319      	movs	r3, #25
    381a:	e7d6      	b.n	37ca <_usb_d_dev_init+0x96>
		pad_trim = 6;
    381c:	2206      	movs	r2, #6
    381e:	e7d8      	b.n	37d2 <_usb_d_dev_init+0x9e>
    3820:	20001924 	.word	0x20001924
    3824:	00002ec1 	.word	0x00002ec1
    3828:	00003105 	.word	0x00003105
    382c:	00800084 	.word	0x00800084

00003830 <_usb_d_dev_ep_stall>:
{
    3830:	b470      	push	{r4, r5, r6}
    3832:	b243      	sxtb	r3, r0
	bool                  dir = USB_EP_GET_DIR(ep);
    3834:	0fdc      	lsrs	r4, r3, #31
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    3836:	f010 000f 	ands.w	r0, r0, #15
    383a:	d008      	beq.n	384e <_usb_d_dev_ep_stall+0x1e>
    383c:	2b00      	cmp	r3, #0
    383e:	bfb4      	ite	lt
    3840:	1c83      	addlt	r3, r0, #2
    3842:	4603      	movge	r3, r0
	if (epn > CONF_USB_D_MAX_EP_N) {
    3844:	2802      	cmp	r0, #2
    3846:	d903      	bls.n	3850 <_usb_d_dev_ep_stall+0x20>
		return -USB_ERR_PARAM;
    3848:	f06f 0011 	mvn.w	r0, #17
    384c:	e018      	b.n	3880 <_usb_d_dev_ep_stall+0x50>
	return &dev_inst.ep[ep_index];
    384e:	2300      	movs	r3, #0
	if (USB_EP_STALL_SET == ctrl) {
    3850:	2901      	cmp	r1, #1
    3852:	d017      	beq.n	3884 <_usb_d_dev_ep_stall+0x54>
	} else if (USB_EP_STALL_CLR == ctrl) {
    3854:	2900      	cmp	r1, #0
    3856:	d03a      	beq.n	38ce <_usb_d_dev_ep_stall+0x9e>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    3858:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    385c:	4a45      	ldr	r2, [pc, #276]	; (3974 <_usb_d_dev_ep_stall+0x144>)
    385e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3862:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    3866:	f003 030f 	and.w	r3, r3, #15
    386a:	015b      	lsls	r3, r3, #5
    386c:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    3870:	f893 2106 	ldrb.w	r2, [r3, #262]	; 0x106
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    3874:	2310      	movs	r3, #16
    3876:	40a3      	lsls	r3, r4
    3878:	421a      	tst	r2, r3
    387a:	bf14      	ite	ne
    387c:	2001      	movne	r0, #1
    387e:	2000      	moveq	r0, #0
}
    3880:	bc70      	pop	{r4, r5, r6}
    3882:	4770      	bx	lr
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    3884:	2510      	movs	r5, #16
    3886:	40a5      	lsls	r5, r4
    3888:	b2ed      	uxtb	r5, r5
	uint8_t epn = USB_EP_GET_N(ept->ep);
    388a:	493a      	ldr	r1, [pc, #232]	; (3974 <_usb_d_dev_ep_stall+0x144>)
    388c:	009e      	lsls	r6, r3, #2
    388e:	18f2      	adds	r2, r6, r3
    3890:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    3894:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    3898:	f002 020f 	and.w	r2, r2, #15
    389c:	0150      	lsls	r0, r2, #5
    389e:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    38a2:	f880 5105 	strb.w	r5, [r0, #261]	; 0x105
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    38a6:	2020      	movs	r0, #32
    38a8:	fa00 f404 	lsl.w	r4, r0, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    38ac:	b2e4      	uxtb	r4, r4
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    38ae:	0152      	lsls	r2, r2, #5
    38b0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    38b4:	f882 4109 	strb.w	r4, [r2, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    38b8:	4433      	add	r3, r6
    38ba:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    38be:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
    38c2:	f042 0208 	orr.w	r2, r2, #8
    38c6:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
		rc = _usb_d_dev_ep_stall_set(ept, dir);
    38ca:	2000      	movs	r0, #0
    38cc:	e7d8      	b.n	3880 <_usb_d_dev_ep_stall+0x50>
	uint8_t epn        = USB_EP_GET_N(ept->ep);
    38ce:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    38d2:	4928      	ldr	r1, [pc, #160]	; (3974 <_usb_d_dev_ep_stall+0x144>)
    38d4:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    38d8:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
    38dc:	f002 020f 	and.w	r2, r2, #15
    38e0:	0151      	lsls	r1, r2, #5
    38e2:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    38e6:	f891 5106 	ldrb.w	r5, [r1, #262]	; 0x106
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    38ea:	2010      	movs	r0, #16
    38ec:	40a0      	lsls	r0, r4
	if (!is_stalled) {
    38ee:	4205      	tst	r5, r0
    38f0:	d03c      	beq.n	396c <_usb_d_dev_ep_stall+0x13c>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    38f2:	b2c0      	uxtb	r0, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    38f4:	f881 0104 	strb.w	r0, [r1, #260]	; 0x104
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    38f8:	2020      	movs	r0, #32
    38fa:	40a0      	lsls	r0, r4
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    38fc:	b2c5      	uxtb	r5, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    38fe:	f881 5108 	strb.w	r5, [r1, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    3902:	f891 2107 	ldrb.w	r2, [r1, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    3906:	4202      	tst	r2, r0
    3908:	d007      	beq.n	391a <_usb_d_dev_ep_stall+0xea>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    390a:	f881 5107 	strb.w	r5, [r1, #263]	; 0x107
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    390e:	2201      	movs	r2, #1
    3910:	fa02 f404 	lsl.w	r4, r2, r4
    3914:	b2e4      	uxtb	r4, r4
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    3916:	f881 4104 	strb.w	r4, [r1, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    391a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    391e:	4815      	ldr	r0, [pc, #84]	; (3974 <_usb_d_dev_ep_stall+0x144>)
    3920:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    3924:	f892 2087 	ldrb.w	r2, [r2, #135]	; 0x87
    3928:	f002 0207 	and.w	r2, r2, #7
    392c:	2a01      	cmp	r2, #1
    392e:	d00c      	beq.n	394a <_usb_d_dev_ep_stall+0x11a>
		ept->flags.bits.is_stalled = 0;
    3930:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    3934:	4a0f      	ldr	r2, [pc, #60]	; (3974 <_usb_d_dev_ep_stall+0x144>)
    3936:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    393a:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
    393e:	f36f 02c3 	bfc	r2, #3, #1
    3942:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    3946:	2000      	movs	r0, #0
    3948:	e79a      	b.n	3880 <_usb_d_dev_ep_stall+0x50>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    394a:	f891 2106 	ldrb.w	r2, [r1, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    394e:	f012 0f30 	tst.w	r2, #48	; 0x30
    3952:	d10d      	bne.n	3970 <_usb_d_dev_ep_stall+0x140>
			ept->flags.bits.is_stalled = 0;
    3954:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    3958:	eb00 0382 	add.w	r3, r0, r2, lsl #2
    395c:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
    3960:	f36f 02c3 	bfc	r2, #3, #1
    3964:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    3968:	2000      	movs	r0, #0
    396a:	e789      	b.n	3880 <_usb_d_dev_ep_stall+0x50>
    396c:	2000      	movs	r0, #0
    396e:	e787      	b.n	3880 <_usb_d_dev_ep_stall+0x50>
    3970:	2000      	movs	r0, #0
    3972:	e785      	b.n	3880 <_usb_d_dev_ep_stall+0x50>
    3974:	20001924 	.word	0x20001924

00003978 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    3978:	b430      	push	{r4, r5}
	uint8_t            epn   = USB_EP_GET_N(ep);
    397a:	f000 040f 	and.w	r4, r0, #15
    397e:	0163      	lsls	r3, r4, #5
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    3980:	4a14      	ldr	r2, [pc, #80]	; (39d4 <_usb_d_dev_ep_read_req+0x5c>)
    3982:	18d0      	adds	r0, r2, r3
	uint32_t           addr  = bank[0].ADDR.reg;
    3984:	58d5      	ldr	r5, [r2, r3]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    3986:	6840      	ldr	r0, [r0, #4]
    3988:	f3c0 000d 	ubfx	r0, r0, #0, #14

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    398c:	2c02      	cmp	r4, #2
    398e:	d817      	bhi.n	39c0 <_usb_d_dev_ep_read_req+0x48>
    3990:	b1c9      	cbz	r1, 39c6 <_usb_d_dev_ep_read_req+0x4e>
    3992:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    3996:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
    399a:	b2d2      	uxtb	r2, r2
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    399c:	2a11      	cmp	r2, #17
    399e:	d115      	bne.n	39cc <_usb_d_dev_ep_read_req+0x54>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    39a0:	f893 2107 	ldrb.w	r2, [r3, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    39a4:	f012 0f10 	tst.w	r2, #16
    39a8:	d102      	bne.n	39b0 <_usb_d_dev_ep_read_req+0x38>
		return ERR_NONE;
    39aa:	2000      	movs	r0, #0
	}
	memcpy(req_buf, (void *)addr, 8);
	_usbd_ep_ack_setup(epn);

	return bytes;
}
    39ac:	bc30      	pop	{r4, r5}
    39ae:	4770      	bx	lr
	memcpy(req_buf, (void *)addr, 8);
    39b0:	682c      	ldr	r4, [r5, #0]
    39b2:	686a      	ldr	r2, [r5, #4]
    39b4:	600c      	str	r4, [r1, #0]
    39b6:	604a      	str	r2, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    39b8:	2210      	movs	r2, #16
    39ba:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
	return bytes;
    39be:	e7f5      	b.n	39ac <_usb_d_dev_ep_read_req+0x34>
		return -USB_ERR_PARAM;
    39c0:	f06f 0011 	mvn.w	r0, #17
    39c4:	e7f2      	b.n	39ac <_usb_d_dev_ep_read_req+0x34>
    39c6:	f06f 0011 	mvn.w	r0, #17
    39ca:	e7ef      	b.n	39ac <_usb_d_dev_ep_read_req+0x34>
		return -USB_ERR_FUNC;
    39cc:	f06f 0012 	mvn.w	r0, #18
    39d0:	e7ec      	b.n	39ac <_usb_d_dev_ep_read_req+0x34>
    39d2:	bf00      	nop
    39d4:	20001924 	.word	0x20001924

000039d8 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    39d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    39dc:	b083      	sub	sp, #12
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    39de:	7a03      	ldrb	r3, [r0, #8]
    39e0:	b25e      	sxtb	r6, r3
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    39e2:	f013 030f 	ands.w	r3, r3, #15
    39e6:	f000 80c2 	beq.w	3b6e <_usb_d_dev_ep_trans+0x196>
    39ea:	2e00      	cmp	r6, #0
    39ec:	bfb4      	ite	lt
    39ee:	1c9a      	addlt	r2, r3, #2
    39f0:	461a      	movge	r2, r3
	return &dev_inst.ep[ep_index];
    39f2:	4614      	mov	r4, r2
    39f4:	4969      	ldr	r1, [pc, #420]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    39f6:	f101 0760 	add.w	r7, r1, #96	; 0x60
    39fa:	1c55      	adds	r5, r2, #1
    39fc:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    3a00:	eb07 0785 	add.w	r7, r7, r5, lsl #2
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    3a04:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    3a08:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    3a0c:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
    3a10:	f240 31ff 	movw	r1, #1023	; 0x3ff
    3a14:	428a      	cmp	r2, r1
    3a16:	d025      	beq.n	3a64 <_usb_d_dev_ep_trans+0x8c>
    3a18:	1e55      	subs	r5, r2, #1
    3a1a:	b2ad      	uxth	r5, r5
	bool     size_n_aligned = (trans->size & size_mask);
    3a1c:	6841      	ldr	r1, [r0, #4]
    3a1e:	400d      	ands	r5, r1

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    3a20:	2b02      	cmp	r3, #2
    3a22:	f200 8092 	bhi.w	3b4a <_usb_d_dev_ep_trans+0x172>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    3a26:	6803      	ldr	r3, [r0, #0]
    3a28:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    3a2c:	d31c      	bcc.n	3a68 <_usb_d_dev_ep_trans+0x90>
    3a2e:	eb03 0c01 	add.w	ip, r3, r1
    3a32:	f8df e180 	ldr.w	lr, [pc, #384]	; 3bb4 <_usb_d_dev_ep_trans+0x1dc>
    3a36:	45f4      	cmp	ip, lr
    3a38:	d816      	bhi.n	3a68 <_usb_d_dev_ep_trans+0x90>
    3a3a:	f013 0f03 	tst.w	r3, #3
    3a3e:	d113      	bne.n	3a68 <_usb_d_dev_ep_trans+0x90>
	    || (!dir && (trans->size < ept->size))) {
    3a40:	2e00      	cmp	r6, #0
    3a42:	db2a      	blt.n	3a9a <_usb_d_dev_ep_trans+0xc2>
    3a44:	428a      	cmp	r2, r1
    3a46:	f200 809c 	bhi.w	3b82 <_usb_d_dev_ep_trans+0x1aa>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
	}
	if (!dir && size_n_aligned) {
    3a4a:	b34d      	cbz	r5, 3aa0 <_usb_d_dev_ep_trans+0xc8>
		if (!ept->cache) {
    3a4c:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    3a50:	4a52      	ldr	r2, [pc, #328]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3a52:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3a56:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    3a5a:	2b00      	cmp	r3, #0
    3a5c:	d07b      	beq.n	3b56 <_usb_d_dev_ep_trans+0x17e>
	bool use_cache = false;
    3a5e:	f04f 0800 	mov.w	r8, #0
    3a62:	e00c      	b.n	3a7e <_usb_d_dev_ep_trans+0xa6>
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    3a64:	4615      	mov	r5, r2
    3a66:	e7d9      	b.n	3a1c <_usb_d_dev_ep_trans+0x44>
		if (!ept->cache) {
    3a68:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    3a6c:	4a4b      	ldr	r2, [pc, #300]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3a6e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3a72:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    3a76:	2b00      	cmp	r3, #0
    3a78:	d06a      	beq.n	3b50 <_usb_d_dev_ep_trans+0x178>
		use_cache = true;
    3a7a:	f04f 0801 	mov.w	r8, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    3a7e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    3a82:	4a46      	ldr	r2, [pc, #280]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3a84:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3a88:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
    3a8c:	f013 0f08 	tst.w	r3, #8
    3a90:	d009      	beq.n	3aa6 <_usb_d_dev_ep_trans+0xce>
		return USB_HALTED;
    3a92:	2002      	movs	r0, #2
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    3a94:	b003      	add	sp, #12
    3a96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bool use_cache = false;
    3a9a:	f04f 0800 	mov.w	r8, #0
    3a9e:	e7ee      	b.n	3a7e <_usb_d_dev_ep_trans+0xa6>
    3aa0:	f04f 0800 	mov.w	r8, #0
    3aa4:	e7eb      	b.n	3a7e <_usb_d_dev_ep_trans+0xa6>
    3aa6:	4682      	mov	sl, r0
	atomic_enter_critical(&flags);
    3aa8:	a801      	add	r0, sp, #4
    3aaa:	4b3d      	ldr	r3, [pc, #244]	; (3ba0 <_usb_d_dev_ep_trans+0x1c8>)
    3aac:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    3aae:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    3ab2:	4a3a      	ldr	r2, [pc, #232]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3ab4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3ab8:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
    3abc:	f013 0f40 	tst.w	r3, #64	; 0x40
    3ac0:	d13c      	bne.n	3b3c <_usb_d_dev_ep_trans+0x164>
	ept->flags.bits.is_busy = 1;
    3ac2:	eb04 0984 	add.w	r9, r4, r4, lsl #2
    3ac6:	4b35      	ldr	r3, [pc, #212]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3ac8:	eb03 0989 	add.w	r9, r3, r9, lsl #2
    3acc:	f899 3087 	ldrb.w	r3, [r9, #135]	; 0x87
    3ad0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3ad4:	f889 3087 	strb.w	r3, [r9, #135]	; 0x87
	atomic_leave_critical(&flags);
    3ad8:	a801      	add	r0, sp, #4
    3ada:	4b32      	ldr	r3, [pc, #200]	; (3ba4 <_usb_d_dev_ep_trans+0x1cc>)
    3adc:	4798      	blx	r3
	ept->trans_buf   = trans->buf;
    3ade:	f8da 3000 	ldr.w	r3, [sl]
    3ae2:	f8c9 3074 	str.w	r3, [r9, #116]	; 0x74
	ept->trans_size  = trans->size;
    3ae6:	f8da 3004 	ldr.w	r3, [sl, #4]
    3aea:	f8c9 3078 	str.w	r3, [r9, #120]	; 0x78
	ept->trans_count = 0;
    3aee:	2300      	movs	r3, #0
    3af0:	f8c9 307c 	str.w	r3, [r9, #124]	; 0x7c
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    3af4:	0ff2      	lsrs	r2, r6, #31
	ept->flags.bits.dir       = dir;
    3af6:	f899 3087 	ldrb.w	r3, [r9, #135]	; 0x87
    3afa:	f362 13c7 	bfi	r3, r2, #7, #1
	ept->flags.bits.use_cache = use_cache;
    3afe:	f368 1345 	bfi	r3, r8, #5, #1
    3b02:	f889 3087 	strb.w	r3, [r9, #135]	; 0x87
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    3b06:	f89a 3009 	ldrb.w	r3, [sl, #9]
    3b0a:	b1e3      	cbz	r3, 3b46 <_usb_d_dev_ep_trans+0x16e>
    3b0c:	fab5 f585 	clz	r5, r5
    3b10:	096d      	lsrs	r5, r5, #5
    3b12:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    3b16:	4b21      	ldr	r3, [pc, #132]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3b18:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    3b1c:	f894 3087 	ldrb.w	r3, [r4, #135]	; 0x87
    3b20:	f365 1304 	bfi	r3, r5, #4, #1
    3b24:	f884 3087 	strb.w	r3, [r4, #135]	; 0x87
	if (dir) {
    3b28:	2e00      	cmp	r6, #0
		_usb_d_dev_in_next(ept, false);
    3b2a:	f04f 0100 	mov.w	r1, #0
    3b2e:	4638      	mov	r0, r7
    3b30:	bfb4      	ite	lt
    3b32:	4b1d      	ldrlt	r3, [pc, #116]	; (3ba8 <_usb_d_dev_ep_trans+0x1d0>)
		_usb_d_dev_out_next(ept, false);
    3b34:	4b1d      	ldrge	r3, [pc, #116]	; (3bac <_usb_d_dev_ep_trans+0x1d4>)
    3b36:	4798      	blx	r3
	return ERR_NONE;
    3b38:	2000      	movs	r0, #0
    3b3a:	e7ab      	b.n	3a94 <_usb_d_dev_ep_trans+0xbc>
		atomic_leave_critical(&flags);
    3b3c:	a801      	add	r0, sp, #4
    3b3e:	4b19      	ldr	r3, [pc, #100]	; (3ba4 <_usb_d_dev_ep_trans+0x1cc>)
    3b40:	4798      	blx	r3
		return USB_BUSY;
    3b42:	2001      	movs	r0, #1
    3b44:	e7a6      	b.n	3a94 <_usb_d_dev_ep_trans+0xbc>
    3b46:	2500      	movs	r5, #0
    3b48:	e7e3      	b.n	3b12 <_usb_d_dev_ep_trans+0x13a>
		return -USB_ERR_PARAM;
    3b4a:	f06f 0011 	mvn.w	r0, #17
    3b4e:	e7a1      	b.n	3a94 <_usb_d_dev_ep_trans+0xbc>
			return -USB_ERR_FUNC;
    3b50:	f06f 0012 	mvn.w	r0, #18
    3b54:	e79e      	b.n	3a94 <_usb_d_dev_ep_trans+0xbc>
			return -USB_ERR_PARAM;
    3b56:	f06f 0011 	mvn.w	r0, #17
    3b5a:	e79b      	b.n	3a94 <_usb_d_dev_ep_trans+0xbc>
			return -USB_ERR_FUNC;
    3b5c:	f06f 0012 	mvn.w	r0, #18
    3b60:	e798      	b.n	3a94 <_usb_d_dev_ep_trans+0xbc>
	bool     size_n_aligned = (trans->size & size_mask);
    3b62:	6841      	ldr	r1, [r0, #4]
    3b64:	f3c1 0509 	ubfx	r5, r1, #0, #10
	return &dev_inst.ep[ep_index];
    3b68:	4f11      	ldr	r7, [pc, #68]	; (3bb0 <_usb_d_dev_ep_trans+0x1d8>)
    3b6a:	2400      	movs	r4, #0
    3b6c:	e75b      	b.n	3a26 <_usb_d_dev_ep_trans+0x4e>
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    3b6e:	4a0b      	ldr	r2, [pc, #44]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3b70:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
    3b74:	f240 31ff 	movw	r1, #1023	; 0x3ff
    3b78:	428a      	cmp	r2, r1
    3b7a:	d0f2      	beq.n	3b62 <_usb_d_dev_ep_trans+0x18a>
	return &dev_inst.ep[ep_index];
    3b7c:	4f0c      	ldr	r7, [pc, #48]	; (3bb0 <_usb_d_dev_ep_trans+0x1d8>)
    3b7e:	2400      	movs	r4, #0
    3b80:	e74a      	b.n	3a18 <_usb_d_dev_ep_trans+0x40>
		if (!ept->cache) {
    3b82:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    3b86:	4a05      	ldr	r2, [pc, #20]	; (3b9c <_usb_d_dev_ep_trans+0x1c4>)
    3b88:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3b8c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    3b90:	2b00      	cmp	r3, #0
    3b92:	d0e3      	beq.n	3b5c <_usb_d_dev_ep_trans+0x184>
    3b94:	f04f 0801 	mov.w	r8, #1
    3b98:	e771      	b.n	3a7e <_usb_d_dev_ep_trans+0xa6>
    3b9a:	bf00      	nop
    3b9c:	20001924 	.word	0x20001924
    3ba0:	00000f81 	.word	0x00000f81
    3ba4:	00000f8f 	.word	0x00000f8f
    3ba8:	00003149 	.word	0x00003149
    3bac:	000032cd 	.word	0x000032cd
    3bb0:	20001998 	.word	0x20001998
    3bb4:	20041fff 	.word	0x20041fff

00003bb8 <_usb_d_dev_register_ep_callback>:
	}
}

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    3bb8:	4b09      	ldr	r3, [pc, #36]	; (3be0 <_usb_d_dev_register_ep_callback+0x28>)
    3bba:	2900      	cmp	r1, #0
    3bbc:	bf08      	it	eq
    3bbe:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    3bc0:	4603      	mov	r3, r0
    3bc2:	b130      	cbz	r0, 3bd2 <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    3bc4:	2801      	cmp	r0, #1
    3bc6:	d007      	beq.n	3bd8 <_usb_d_dev_register_ep_callback+0x20>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    3bc8:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    3bca:	bf04      	itt	eq
    3bcc:	4b05      	ldreq	r3, [pc, #20]	; (3be4 <_usb_d_dev_register_ep_callback+0x2c>)
    3bce:	6719      	streq	r1, [r3, #112]	; 0x70
    3bd0:	4770      	bx	lr
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    3bd2:	4b04      	ldr	r3, [pc, #16]	; (3be4 <_usb_d_dev_register_ep_callback+0x2c>)
    3bd4:	6699      	str	r1, [r3, #104]	; 0x68
    3bd6:	4770      	bx	lr
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    3bd8:	4b02      	ldr	r3, [pc, #8]	; (3be4 <_usb_d_dev_register_ep_callback+0x2c>)
    3bda:	66d9      	str	r1, [r3, #108]	; 0x6c
    3bdc:	4770      	bx	lr
    3bde:	bf00      	nop
    3be0:	00002ec1 	.word	0x00002ec1
    3be4:	20001924 	.word	0x20001924

00003be8 <USB_0_Handler>:

/**
 * \brief USB interrupt handler
 */
void USB_0_Handler(void)
{
    3be8:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    3bea:	4b01      	ldr	r3, [pc, #4]	; (3bf0 <USB_0_Handler+0x8>)
    3bec:	4798      	blx	r3
    3bee:	bd08      	pop	{r3, pc}
    3bf0:	000034bd 	.word	0x000034bd

00003bf4 <USB_1_Handler>:
}
/**
 * \brief USB interrupt handler
 */
void USB_1_Handler(void)
{
    3bf4:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    3bf6:	4b01      	ldr	r3, [pc, #4]	; (3bfc <USB_1_Handler+0x8>)
    3bf8:	4798      	blx	r3
    3bfa:	bd08      	pop	{r3, pc}
    3bfc:	000034bd 	.word	0x000034bd

00003c00 <USB_2_Handler>:
}
/**
 * \brief USB interrupt handler
 */
void USB_2_Handler(void)
{
    3c00:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    3c02:	4b01      	ldr	r3, [pc, #4]	; (3c08 <USB_2_Handler+0x8>)
    3c04:	4798      	blx	r3
    3c06:	bd08      	pop	{r3, pc}
    3c08:	000034bd 	.word	0x000034bd

00003c0c <USB_3_Handler>:
}
/**
 * \brief USB interrupt handler
 */
void USB_3_Handler(void)
{
    3c0c:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    3c0e:	4b01      	ldr	r3, [pc, #4]	; (3c14 <USB_3_Handler+0x8>)
    3c10:	4798      	blx	r3
    3c12:	bd08      	pop	{r3, pc}
    3c14:	000034bd 	.word	0x000034bd

00003c18 <uart_mutex_take>:
		}
	}
}

static bool uart_mutex_take(void)
{
    3c18:	b510      	push	{r4, lr}
	return xSemaphoreTake(uart_mutex, ~0);
    3c1a:	2300      	movs	r3, #0
    3c1c:	f04f 32ff 	mov.w	r2, #4294967295
    3c20:	4619      	mov	r1, r3
    3c22:	4804      	ldr	r0, [pc, #16]	; (3c34 <uart_mutex_take+0x1c>)
    3c24:	6800      	ldr	r0, [r0, #0]
    3c26:	4c04      	ldr	r4, [pc, #16]	; (3c38 <uart_mutex_take+0x20>)
    3c28:	47a0      	blx	r4
}
    3c2a:	3000      	adds	r0, #0
    3c2c:	bf18      	it	ne
    3c2e:	2001      	movne	r0, #1
    3c30:	bd10      	pop	{r4, pc}
    3c32:	bf00      	nop
    3c34:	20001b0c 	.word	0x20001b0c
    3c38:	00004c3d 	.word	0x00004c3d

00003c3c <uart_mutex_give>:

static void uart_mutex_give(void)
{
    3c3c:	b510      	push	{r4, lr}
	xSemaphoreGive(uart_mutex);
    3c3e:	2300      	movs	r3, #0
    3c40:	461a      	mov	r2, r3
    3c42:	4619      	mov	r1, r3
    3c44:	4802      	ldr	r0, [pc, #8]	; (3c50 <uart_mutex_give+0x14>)
    3c46:	6800      	ldr	r0, [r0, #0]
    3c48:	4c02      	ldr	r4, [pc, #8]	; (3c54 <uart_mutex_give+0x18>)
    3c4a:	47a0      	blx	r4
    3c4c:	bd10      	pop	{r4, pc}
    3c4e:	bf00      	nop
    3c50:	20001b0c 	.word	0x20001b0c
    3c54:	00004845 	.word	0x00004845

00003c58 <task_adc>:
}

//OS task for ADC
 
static void task_adc(void *p)
{
    3c58:	b580      	push	{r7, lr}
    3c5a:	b082      	sub	sp, #8
	
	uint8_t buffer[2];
	adc_sync_enable_channel(&ADC_0, 0);
    3c5c:	2100      	movs	r1, #0
    3c5e:	480f      	ldr	r0, [pc, #60]	; (3c9c <task_adc+0x44>)
    3c60:	4b0f      	ldr	r3, [pc, #60]	; (3ca0 <task_adc+0x48>)
    3c62:	4798      	blx	r3
	printf("dac channel enabled\n\r");
    3c64:	480f      	ldr	r0, [pc, #60]	; (3ca4 <task_adc+0x4c>)
    3c66:	4b10      	ldr	r3, [pc, #64]	; (3ca8 <task_adc+0x50>)
    3c68:	4798      	blx	r3
	//usart_sync_get_io_descriptor(&USART_1, &io);
	//usart_sync_enable(&USART_1);
	//printf("rs485 enabled\n\r");
	
	for (;;) {
		adc_sync_read_channel(&ADC_0, 0, buffer, 2);
    3c6a:	4e0c      	ldr	r6, [pc, #48]	; (3c9c <task_adc+0x44>)
    3c6c:	4d0f      	ldr	r5, [pc, #60]	; (3cac <task_adc+0x54>)
		if (uart_mutex_take()) {
    3c6e:	4c10      	ldr	r4, [pc, #64]	; (3cb0 <task_adc+0x58>)
		adc_sync_read_channel(&ADC_0, 0, buffer, 2);
    3c70:	2302      	movs	r3, #2
    3c72:	aa01      	add	r2, sp, #4
    3c74:	2100      	movs	r1, #0
    3c76:	4630      	mov	r0, r6
    3c78:	47a8      	blx	r5
		if (uart_mutex_take()) {
    3c7a:	47a0      	blx	r4
    3c7c:	2800      	cmp	r0, #0
    3c7e:	d0f7      	beq.n	3c70 <task_adc+0x18>
			printf("ADC is working\n\r");
    3c80:	480c      	ldr	r0, [pc, #48]	; (3cb4 <task_adc+0x5c>)
    3c82:	4f09      	ldr	r7, [pc, #36]	; (3ca8 <task_adc+0x50>)
    3c84:	47b8      	blx	r7
			printf("%d\n\r", *buffer);
    3c86:	f89d 1004 	ldrb.w	r1, [sp, #4]
    3c8a:	480b      	ldr	r0, [pc, #44]	; (3cb8 <task_adc+0x60>)
    3c8c:	47b8      	blx	r7
			uart_mutex_give();
    3c8e:	4b0b      	ldr	r3, [pc, #44]	; (3cbc <task_adc+0x64>)
    3c90:	4798      	blx	r3
			os_sleep(500);
    3c92:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    3c96:	4b0a      	ldr	r3, [pc, #40]	; (3cc0 <task_adc+0x68>)
    3c98:	4798      	blx	r3
    3c9a:	e7e9      	b.n	3c70 <task_adc+0x18>
    3c9c:	2000e624 	.word	0x2000e624
    3ca0:	00000eb5 	.word	0x00000eb5
    3ca4:	00007094 	.word	0x00007094
    3ca8:	00005ced 	.word	0x00005ced
    3cac:	00000ee1 	.word	0x00000ee1
    3cb0:	00003c19 	.word	0x00003c19
    3cb4:	000070ac 	.word	0x000070ac
    3cb8:	000070fc 	.word	0x000070fc
    3cbc:	00003c3d 	.word	0x00003c3d
    3cc0:	00005395 	.word	0x00005395

00003cc4 <task_dac>:
}

//OS task for DAC

static void task_dac(void *p)
{
    3cc4:	b500      	push	{lr}
    3cc6:	b083      	sub	sp, #12
	
	uint16_t i = 0;
    3cc8:	2100      	movs	r1, #0
    3cca:	f8ad 1006 	strh.w	r1, [sp, #6]
	
	dac_sync_enable_channel(&DAC_0, 0);
    3cce:	4814      	ldr	r0, [pc, #80]	; (3d20 <task_dac+0x5c>)
    3cd0:	4b14      	ldr	r3, [pc, #80]	; (3d24 <task_dac+0x60>)
    3cd2:	4798      	blx	r3
	printf("dac channel enabled\n\r");
    3cd4:	4814      	ldr	r0, [pc, #80]	; (3d28 <task_dac+0x64>)
    3cd6:	4b15      	ldr	r3, [pc, #84]	; (3d2c <task_dac+0x68>)
    3cd8:	4798      	blx	r3
	//usart_sync_get_io_descriptor(&USART_1, &io);
	//usart_sync_enable(&USART_1);
	//printf("rs485 enabled\n\r");
	
	for (;;) {
		dac_sync_write(&DAC_0, 0, &i, 1);
    3cda:	4e11      	ldr	r6, [pc, #68]	; (3d20 <task_dac+0x5c>)
    3cdc:	4d14      	ldr	r5, [pc, #80]	; (3d30 <task_dac+0x6c>)
		i = (i + 1) % 1024;
		
		if (uart_mutex_take()) {
    3cde:	4c15      	ldr	r4, [pc, #84]	; (3d34 <task_dac+0x70>)
		dac_sync_write(&DAC_0, 0, &i, 1);
    3ce0:	2301      	movs	r3, #1
    3ce2:	f10d 0206 	add.w	r2, sp, #6
    3ce6:	2100      	movs	r1, #0
    3ce8:	4630      	mov	r0, r6
    3cea:	47a8      	blx	r5
		i = (i + 1) % 1024;
    3cec:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    3cf0:	3301      	adds	r3, #1
    3cf2:	425a      	negs	r2, r3
    3cf4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    3cf8:	f3c2 0209 	ubfx	r2, r2, #0, #10
    3cfc:	bf58      	it	pl
    3cfe:	4253      	negpl	r3, r2
    3d00:	f8ad 3006 	strh.w	r3, [sp, #6]
		if (uart_mutex_take()) {
    3d04:	47a0      	blx	r4
    3d06:	2800      	cmp	r0, #0
    3d08:	d0ea      	beq.n	3ce0 <task_dac+0x1c>
			printf("DAC is working\n\r");
    3d0a:	480b      	ldr	r0, [pc, #44]	; (3d38 <task_dac+0x74>)
    3d0c:	4b07      	ldr	r3, [pc, #28]	; (3d2c <task_dac+0x68>)
    3d0e:	4798      	blx	r3
			uart_mutex_give();
    3d10:	4b0a      	ldr	r3, [pc, #40]	; (3d3c <task_dac+0x78>)
    3d12:	4798      	blx	r3
			os_sleep(500);
    3d14:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    3d18:	4b09      	ldr	r3, [pc, #36]	; (3d40 <task_dac+0x7c>)
    3d1a:	4798      	blx	r3
    3d1c:	e7e0      	b.n	3ce0 <task_dac+0x1c>
    3d1e:	bf00      	nop
    3d20:	2000e628 	.word	0x2000e628
    3d24:	00000fdd 	.word	0x00000fdd
    3d28:	00007094 	.word	0x00007094
    3d2c:	00005ced 	.word	0x00005ced
    3d30:	00001011 	.word	0x00001011
    3d34:	00003c19 	.word	0x00003c19
    3d38:	000070c0 	.word	0x000070c0
    3d3c:	00003c3d 	.word	0x00003c3d
    3d40:	00005395 	.word	0x00005395

00003d44 <main>:
		
	//}
//}

int main(void)
{
    3d44:	b510      	push	{r4, lr}
    3d46:	b084      	sub	sp, #16
	atmel_start_init();
    3d48:	4b16      	ldr	r3, [pc, #88]	; (3da4 <main+0x60>)
    3d4a:	4798      	blx	r3
	uart_mutex = xSemaphoreCreateMutex();
    3d4c:	2001      	movs	r0, #1
    3d4e:	4b16      	ldr	r3, [pc, #88]	; (3da8 <main+0x64>)
    3d50:	4798      	blx	r3
    3d52:	4b16      	ldr	r3, [pc, #88]	; (3dac <main+0x68>)
    3d54:	6018      	str	r0, [r3, #0]
	if (uart_mutex == NULL) {
    3d56:	b178      	cbz	r0, 3d78 <main+0x34>
		//}
	//}

	//#else
	uart_mutex_create();
	if (xTaskCreate(task_dac, "DAC", TASK_DAC_STACK_SIZE, NULL, TASK_DAC_STACK_PRIORITY, &xCreatedDACTask) != pdPASS) {while (1);}
    3d58:	2300      	movs	r3, #0
    3d5a:	9303      	str	r3, [sp, #12]
    3d5c:	9302      	str	r3, [sp, #8]
    3d5e:	4a14      	ldr	r2, [pc, #80]	; (3db0 <main+0x6c>)
    3d60:	9201      	str	r2, [sp, #4]
    3d62:	2201      	movs	r2, #1
    3d64:	9200      	str	r2, [sp, #0]
    3d66:	f44f 7280 	mov.w	r2, #256	; 0x100
    3d6a:	4912      	ldr	r1, [pc, #72]	; (3db4 <main+0x70>)
    3d6c:	4812      	ldr	r0, [pc, #72]	; (3db8 <main+0x74>)
    3d6e:	4c13      	ldr	r4, [pc, #76]	; (3dbc <main+0x78>)
    3d70:	47a0      	blx	r4
    3d72:	2801      	cmp	r0, #1
    3d74:	d001      	beq.n	3d7a <main+0x36>
    3d76:	e7fe      	b.n	3d76 <main+0x32>
    3d78:	e7fe      	b.n	3d78 <main+0x34>
	if (xTaskCreate(task_adc, "ADC", TASK_ADC_STACK_SIZE, NULL, TASK_ADC_STACK_PRIORITY, &xCreatedADCTask) != pdPASS) {while (1);}
    3d7a:	2300      	movs	r3, #0
    3d7c:	9303      	str	r3, [sp, #12]
    3d7e:	9302      	str	r3, [sp, #8]
    3d80:	4a0f      	ldr	r2, [pc, #60]	; (3dc0 <main+0x7c>)
    3d82:	9201      	str	r2, [sp, #4]
    3d84:	2202      	movs	r2, #2
    3d86:	9200      	str	r2, [sp, #0]
    3d88:	f44f 7280 	mov.w	r2, #256	; 0x100
    3d8c:	490d      	ldr	r1, [pc, #52]	; (3dc4 <main+0x80>)
    3d8e:	480e      	ldr	r0, [pc, #56]	; (3dc8 <main+0x84>)
    3d90:	4c0a      	ldr	r4, [pc, #40]	; (3dbc <main+0x78>)
    3d92:	47a0      	blx	r4
    3d94:	2801      	cmp	r0, #1
    3d96:	d000      	beq.n	3d9a <main+0x56>
    3d98:	e7fe      	b.n	3d98 <main+0x54>
	//#endif
	vTaskStartScheduler();
    3d9a:	4b0c      	ldr	r3, [pc, #48]	; (3dcc <main+0x88>)
    3d9c:	4798      	blx	r3

	return 0;
}
    3d9e:	2000      	movs	r0, #0
    3da0:	b004      	add	sp, #16
    3da2:	bd10      	pop	{r4, pc}
    3da4:	000002d1 	.word	0x000002d1
    3da8:	00004a15 	.word	0x00004a15
    3dac:	20001b0c 	.word	0x20001b0c
    3db0:	20002958 	.word	0x20002958
    3db4:	00007140 	.word	0x00007140
    3db8:	00003cc5 	.word	0x00003cc5
    3dbc:	00004ed9 	.word	0x00004ed9
    3dc0:	2000295c 	.word	0x2000295c
    3dc4:	00007144 	.word	0x00007144
    3dc8:	00003c59 	.word	0x00003c59
    3dcc:	000050dd 	.word	0x000050dd

00003dd0 <com_putchar>:
unsigned long com_tbuflen (void) { return (t_in-t_out); }
unsigned long com_rbuflen (void) { return (r_in-r_out); }

int com_putchar(unsigned char c)
{
 tbuf [t_in & (TBUF_SIZE-1)]=c;	t_in++;
    3dd0:	4a08      	ldr	r2, [pc, #32]	; (3df4 <com_putchar+0x24>)
    3dd2:	6893      	ldr	r3, [r2, #8]
    3dd4:	f003 010f 	and.w	r1, r3, #15
    3dd8:	4411      	add	r1, r2
    3dda:	f881 0218 	strb.w	r0, [r1, #536]	; 0x218
    3dde:	1c58      	adds	r0, r3, #1
    3de0:	6090      	str	r0, [r2, #8]
 if (t_in - t_out >= TBUF_SIZE)  return(-1);
    3de2:	6853      	ldr	r3, [r2, #4]
    3de4:	1ac0      	subs	r0, r0, r3
// if (t_in!=t_out) TX_interrupt_enable();
 return 0; 
}
    3de6:	280f      	cmp	r0, #15
    3de8:	f04f 30ff 	mov.w	r0, #4294967295
    3dec:	bf98      	it	ls
    3dee:	2000      	movls	r0, #0
    3df0:	4770      	bx	lr
    3df2:	bf00      	nop
    3df4:	20002960 	.word	0x20002960

00003df8 <RX_int>:
{
    3df8:	b510      	push	{r4, lr}
    3dfa:	4604      	mov	r4, r0
  if ((ma_sl_flag == 0) && (echo_flag == 1) && (ti_restart == 1)) com_putchar(temp);//SendByte(temp);
    3dfc:	4b29      	ldr	r3, [pc, #164]	; (3ea4 <RX_int+0xac>)
    3dfe:	781b      	ldrb	r3, [r3, #0]
    3e00:	b91b      	cbnz	r3, 3e0a <RX_int+0x12>
    3e02:	4b28      	ldr	r3, [pc, #160]	; (3ea4 <RX_int+0xac>)
    3e04:	785b      	ldrb	r3, [r3, #1]
    3e06:	2b01      	cmp	r3, #1
    3e08:	d006      	beq.n	3e18 <RX_int+0x20>
  if (temp == V_START)
    3e0a:	2caa      	cmp	r4, #170	; 0xaa
    3e0c:	d00b      	beq.n	3e26 <RX_int+0x2e>
   if (START_flag == 1)		// пока старт не придёт, ничего не делать 
    3e0e:	4b26      	ldr	r3, [pc, #152]	; (3ea8 <RX_int+0xb0>)
    3e10:	7b1b      	ldrb	r3, [r3, #12]
    3e12:	2b01      	cmp	r3, #1
    3e14:	d022      	beq.n	3e5c <RX_int+0x64>
    3e16:	bd10      	pop	{r4, pc}
  if ((ma_sl_flag == 0) && (echo_flag == 1) && (ti_restart == 1)) com_putchar(temp);//SendByte(temp);
    3e18:	4b23      	ldr	r3, [pc, #140]	; (3ea8 <RX_int+0xb0>)
    3e1a:	781b      	ldrb	r3, [r3, #0]
    3e1c:	2b01      	cmp	r3, #1
    3e1e:	d1f4      	bne.n	3e0a <RX_int+0x12>
    3e20:	4b22      	ldr	r3, [pc, #136]	; (3eac <RX_int+0xb4>)
    3e22:	4798      	blx	r3
    3e24:	e7f1      	b.n	3e0a <RX_int+0x12>
     r_in=0; 
    3e26:	4a20      	ldr	r2, [pc, #128]	; (3ea8 <RX_int+0xb0>)
    3e28:	2300      	movs	r3, #0
     r_out=0; 
    3e2a:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
     START_flag=1; 
    3e2e:	2101      	movs	r1, #1
    3e30:	7311      	strb	r1, [r2, #12]
     STOP_echo_flag=0;
    3e32:	7353      	strb	r3, [r2, #13]
     STOP_flag=0;
    3e34:	7393      	strb	r3, [r2, #14]
       rbuf[r_in & (RBUF_SIZE-1)]=temp;	//укладываем байты
    3e36:	f3c3 0208 	ubfx	r2, r3, #0, #9
    3e3a:	491b      	ldr	r1, [pc, #108]	; (3ea8 <RX_int+0xb0>)
    3e3c:	440a      	add	r2, r1
    3e3e:	7514      	strb	r4, [r2, #20]
       r_in++;
    3e40:	3301      	adds	r3, #1
    3e42:	610b      	str	r3, [r1, #16]
     if (temp == V_STOP)		// уложенный байт мог оказаться последним
    3e44:	2cab      	cmp	r4, #171	; 0xab
    3e46:	d1e6      	bne.n	3e16 <RX_int+0x1e>
       if ((ma_sl_flag==1) && (echo_flag==1)) //если контроллер в режиме мастера
    3e48:	4b16      	ldr	r3, [pc, #88]	; (3ea4 <RX_int+0xac>)
    3e4a:	781b      	ldrb	r3, [r3, #0]
    3e4c:	2b01      	cmp	r3, #1
    3e4e:	d011      	beq.n	3e74 <RX_int+0x7c>
        START_flag=0;		// просто конец приёма
    3e50:	4b15      	ldr	r3, [pc, #84]	; (3ea8 <RX_int+0xb0>)
    3e52:	2200      	movs	r2, #0
    3e54:	731a      	strb	r2, [r3, #12]
        STOP_flag=1;
    3e56:	2201      	movs	r2, #1
    3e58:	739a      	strb	r2, [r3, #14]
}
    3e5a:	e7dc      	b.n	3e16 <RX_int+0x1e>
     if (((r_in-r_out) & ~(RBUF_SIZE-1)) == 0)
    3e5c:	4a12      	ldr	r2, [pc, #72]	; (3ea8 <RX_int+0xb0>)
    3e5e:	6913      	ldr	r3, [r2, #16]
    3e60:	f8d2 2214 	ldr.w	r2, [r2, #532]	; 0x214
    3e64:	1a9a      	subs	r2, r3, r2
    3e66:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
    3e6a:	f022 0201 	bic.w	r2, r2, #1
    3e6e:	2a00      	cmp	r2, #0
    3e70:	d1e8      	bne.n	3e44 <RX_int+0x4c>
    3e72:	e7e0      	b.n	3e36 <RX_int+0x3e>
       if ((ma_sl_flag==1) && (echo_flag==1)) //если контроллер в режиме мастера
    3e74:	4b0b      	ldr	r3, [pc, #44]	; (3ea4 <RX_int+0xac>)
    3e76:	785b      	ldrb	r3, [r3, #1]
    3e78:	2b01      	cmp	r3, #1
    3e7a:	d1e9      	bne.n	3e50 <RX_int+0x58>
         if (STOP_echo_flag == 1) 
    3e7c:	4b0a      	ldr	r3, [pc, #40]	; (3ea8 <RX_int+0xb0>)
    3e7e:	7b5b      	ldrb	r3, [r3, #13]
    3e80:	2b01      	cmp	r3, #1
    3e82:	d007      	beq.n	3e94 <RX_int+0x9c>
           r_in=0;
    3e84:	4b08      	ldr	r3, [pc, #32]	; (3ea8 <RX_int+0xb0>)
    3e86:	2200      	movs	r2, #0
    3e88:	611a      	str	r2, [r3, #16]
           r_out=0;
    3e8a:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
           STOP_echo_flag=1;
    3e8e:	2201      	movs	r2, #1
    3e90:	735a      	strb	r2, [r3, #13]
    3e92:	bd10      	pop	{r4, pc}
           START_flag=0;
    3e94:	4b04      	ldr	r3, [pc, #16]	; (3ea8 <RX_int+0xb0>)
    3e96:	2200      	movs	r2, #0
    3e98:	731a      	strb	r2, [r3, #12]
           STOP_echo_flag=0;
    3e9a:	735a      	strb	r2, [r3, #13]
           STOP_flag=1;
    3e9c:	2201      	movs	r2, #1
    3e9e:	739a      	strb	r2, [r3, #14]
    3ea0:	bd10      	pop	{r4, pc}
    3ea2:	bf00      	nop
    3ea4:	20000000 	.word	0x20000000
    3ea8:	20002960 	.word	0x20002960
    3eac:	00003dd1 	.word	0x00003dd1

00003eb0 <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
    3eb0:	b940      	cbnz	r0, 3ec4 <_read+0x14>
{
    3eb2:	b508      	push	{r3, lr}
    3eb4:	460b      	mov	r3, r1
    3eb6:	4611      	mov	r1, r2
    3eb8:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    3eba:	4b04      	ldr	r3, [pc, #16]	; (3ecc <_read+0x1c>)
    3ebc:	4798      	blx	r3
    3ebe:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    3ec2:	bd08      	pop	{r3, pc}
		return -1;
    3ec4:	f04f 30ff 	mov.w	r0, #4294967295
    3ec8:	4770      	bx	lr
    3eca:	bf00      	nop
    3ecc:	00003f21 	.word	0x00003f21

00003ed0 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    3ed0:	3801      	subs	r0, #1
    3ed2:	2802      	cmp	r0, #2
    3ed4:	d808      	bhi.n	3ee8 <_write+0x18>
{
    3ed6:	b508      	push	{r3, lr}
    3ed8:	460b      	mov	r3, r1
    3eda:	4611      	mov	r1, r2
    3edc:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    3ede:	4b04      	ldr	r3, [pc, #16]	; (3ef0 <_write+0x20>)
    3ee0:	4798      	blx	r3
    3ee2:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    3ee6:	bd08      	pop	{r3, pc}
		return -1;
    3ee8:	f04f 30ff 	mov.w	r0, #4294967295
    3eec:	4770      	bx	lr
    3eee:	bf00      	nop
    3ef0:	00003f45 	.word	0x00003f45

00003ef4 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    3ef4:	b570      	push	{r4, r5, r6, lr}
    3ef6:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    3ef8:	4d06      	ldr	r5, [pc, #24]	; (3f14 <stdio_io_init+0x20>)
    3efa:	682b      	ldr	r3, [r5, #0]
    3efc:	2100      	movs	r1, #0
    3efe:	6898      	ldr	r0, [r3, #8]
    3f00:	4c05      	ldr	r4, [pc, #20]	; (3f18 <stdio_io_init+0x24>)
    3f02:	47a0      	blx	r4
	setbuf(stdin, NULL);
    3f04:	682b      	ldr	r3, [r5, #0]
    3f06:	2100      	movs	r1, #0
    3f08:	6858      	ldr	r0, [r3, #4]
    3f0a:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    3f0c:	4b03      	ldr	r3, [pc, #12]	; (3f1c <stdio_io_init+0x28>)
    3f0e:	601e      	str	r6, [r3, #0]
    3f10:	bd70      	pop	{r4, r5, r6, pc}
    3f12:	bf00      	nop
    3f14:	2000000c 	.word	0x2000000c
    3f18:	00005d1d 	.word	0x00005d1d
    3f1c:	20002b8c 	.word	0x20002b8c

00003f20 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
    3f20:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    3f22:	4b06      	ldr	r3, [pc, #24]	; (3f3c <stdio_io_read+0x1c>)
    3f24:	681b      	ldr	r3, [r3, #0]
    3f26:	b133      	cbz	r3, 3f36 <stdio_io_read+0x16>
    3f28:	460a      	mov	r2, r1
    3f2a:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
    3f2c:	b292      	uxth	r2, r2
    3f2e:	4618      	mov	r0, r3
    3f30:	4b03      	ldr	r3, [pc, #12]	; (3f40 <stdio_io_read+0x20>)
    3f32:	4798      	blx	r3
    3f34:	bd08      	pop	{r3, pc}
		return 0;
    3f36:	2000      	movs	r0, #0
}
    3f38:	bd08      	pop	{r3, pc}
    3f3a:	bf00      	nop
    3f3c:	20002b8c 	.word	0x20002b8c
    3f40:	000011f1 	.word	0x000011f1

00003f44 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
    3f44:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    3f46:	4b06      	ldr	r3, [pc, #24]	; (3f60 <stdio_io_write+0x1c>)
    3f48:	681b      	ldr	r3, [r3, #0]
    3f4a:	b133      	cbz	r3, 3f5a <stdio_io_write+0x16>
    3f4c:	460a      	mov	r2, r1
    3f4e:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
    3f50:	b292      	uxth	r2, r2
    3f52:	4618      	mov	r0, r3
    3f54:	4b03      	ldr	r3, [pc, #12]	; (3f64 <stdio_io_write+0x20>)
    3f56:	4798      	blx	r3
    3f58:	bd08      	pop	{r3, pc}
		return 0;
    3f5a:	2000      	movs	r0, #0
}
    3f5c:	bd08      	pop	{r3, pc}
    3f5e:	bf00      	nop
    3f60:	20002b8c 	.word	0x20002b8c
    3f64:	000011c1 	.word	0x000011c1

00003f68 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    3f68:	b510      	push	{r4, lr}

	usart_sync_enable(&USART_1);
    3f6a:	4c04      	ldr	r4, [pc, #16]	; (3f7c <stdio_redirect_init+0x14>)
    3f6c:	4620      	mov	r0, r4
    3f6e:	4b04      	ldr	r3, [pc, #16]	; (3f80 <stdio_redirect_init+0x18>)
    3f70:	4798      	blx	r3
	stdio_io_init(&USART_1.io);
    3f72:	4620      	mov	r0, r4
    3f74:	4b03      	ldr	r3, [pc, #12]	; (3f84 <stdio_redirect_init+0x1c>)
    3f76:	4798      	blx	r3
    3f78:	bd10      	pop	{r4, pc}
    3f7a:	bf00      	nop
    3f7c:	2000e6cc 	.word	0x2000e6cc
    3f80:	00001715 	.word	0x00001715
    3f84:	00003ef5 	.word	0x00003ef5

00003f88 <sem_init>:

/**
 * \brief Semaphore initialization
 */
int32_t sem_init(sem_t *sem, uint32_t count)
{
    3f88:	b538      	push	{r3, r4, r5, lr}
    3f8a:	4605      	mov	r5, r0
    3f8c:	460c      	mov	r4, r1
	ASSERT(count <= SEMAPHORE_MAX_COUNT);
    3f8e:	222b      	movs	r2, #43	; 0x2b
    3f90:	4908      	ldr	r1, [pc, #32]	; (3fb4 <sem_init+0x2c>)
    3f92:	2c01      	cmp	r4, #1
    3f94:	bf8c      	ite	hi
    3f96:	2000      	movhi	r0, #0
    3f98:	2001      	movls	r0, #1
    3f9a:	4b07      	ldr	r3, [pc, #28]	; (3fb8 <sem_init+0x30>)
    3f9c:	4798      	blx	r3

	*sem = xSemaphoreCreateCounting((uint32_t)SEMAPHORE_MAX_COUNT, count);
    3f9e:	4621      	mov	r1, r4
    3fa0:	2001      	movs	r0, #1
    3fa2:	4b06      	ldr	r3, [pc, #24]	; (3fbc <sem_init+0x34>)
    3fa4:	4798      	blx	r3
    3fa6:	6028      	str	r0, [r5, #0]

	return *sem ? ERR_NONE : ERR_NOT_INITIALIZED;
    3fa8:	2800      	cmp	r0, #0
}
    3faa:	bf14      	ite	ne
    3fac:	2000      	movne	r0, #0
    3fae:	f06f 0013 	mvneq.w	r0, #19
    3fb2:	bd38      	pop	{r3, r4, r5, pc}
    3fb4:	00007148 	.word	0x00007148
    3fb8:	000019fd 	.word	0x000019fd
    3fbc:	000047f1 	.word	0x000047f1

00003fc0 <sem_up>:

/**
 * \brief Semaphore up
 */
int32_t sem_up(sem_t *sem)
{
    3fc0:	b510      	push	{r4, lr}
 * \brief Check if it's in ISR handling
 * \return \c true if it's in ISR
 */
static inline bool _is_in_isr(void)
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
    3fc2:	4b0d      	ldr	r3, [pc, #52]	; (3ff8 <sem_up+0x38>)
    3fc4:	685b      	ldr	r3, [r3, #4]
    3fc6:	f3c3 0308 	ubfx	r3, r3, #0, #9
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
    3fca:	b14b      	cbz	r3, 3fe0 <sem_up+0x20>
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
    3fcc:	2100      	movs	r1, #0
    3fce:	6800      	ldr	r0, [r0, #0]
    3fd0:	4b0a      	ldr	r3, [pc, #40]	; (3ffc <sem_up+0x3c>)
    3fd2:	4798      	blx	r3
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
    3fd4:	2800      	cmp	r0, #0
    3fd6:	bf14      	ite	ne
    3fd8:	2000      	movne	r0, #0
    3fda:	f06f 0002 	mvneq.w	r0, #2
    3fde:	bd10      	pop	{r4, pc}
    3fe0:	2300      	movs	r3, #0
    3fe2:	461a      	mov	r2, r3
    3fe4:	4619      	mov	r1, r3
    3fe6:	6800      	ldr	r0, [r0, #0]
    3fe8:	4c05      	ldr	r4, [pc, #20]	; (4000 <sem_up+0x40>)
    3fea:	47a0      	blx	r4
    3fec:	2800      	cmp	r0, #0
    3fee:	bf14      	ite	ne
    3ff0:	2000      	movne	r0, #0
    3ff2:	f06f 0002 	mvneq.w	r0, #2
}
    3ff6:	bd10      	pop	{r4, pc}
    3ff8:	e000ed00 	.word	0xe000ed00
    3ffc:	00004b65 	.word	0x00004b65
    4000:	00004845 	.word	0x00004845

00004004 <sem_down>:

/**
 * \brief Semaphore down, may suspend the caller thread
 */
int32_t sem_down(sem_t *sem, uint32_t timeout)
{
    4004:	b510      	push	{r4, lr}
	return xSemaphoreTake(*sem, timeout) ? ERR_NONE : ERR_TIMEOUT;
    4006:	2300      	movs	r3, #0
    4008:	460a      	mov	r2, r1
    400a:	4619      	mov	r1, r3
    400c:	6800      	ldr	r0, [r0, #0]
    400e:	4c04      	ldr	r4, [pc, #16]	; (4020 <sem_down+0x1c>)
    4010:	47a0      	blx	r4
    4012:	2800      	cmp	r0, #0
}
    4014:	bf14      	ite	ne
    4016:	2000      	movne	r0, #0
    4018:	f06f 0007 	mvneq.w	r0, #7
    401c:	bd10      	pop	{r4, pc}
    401e:	bf00      	nop
    4020:	00004c3d 	.word	0x00004c3d

00004024 <sem_deinit>:
/**
 * \brief Semaphore deinitialization
 */
int32_t sem_deinit(sem_t *sem)
{
	if (*sem != NULL) {
    4024:	6803      	ldr	r3, [r0, #0]
    4026:	b143      	cbz	r3, 403a <sem_deinit+0x16>
{
    4028:	b510      	push	{r4, lr}
    402a:	4604      	mov	r4, r0
		vSemaphoreDelete(*sem);
    402c:	4618      	mov	r0, r3
    402e:	4b04      	ldr	r3, [pc, #16]	; (4040 <sem_deinit+0x1c>)
    4030:	4798      	blx	r3
		*sem = NULL;
    4032:	2300      	movs	r3, #0
    4034:	6023      	str	r3, [r4, #0]
	}

	return ERR_NONE;
}
    4036:	2000      	movs	r0, #0
    4038:	bd10      	pop	{r4, pc}
    403a:	2000      	movs	r0, #0
    403c:	4770      	bx	lr
    403e:	bf00      	nop
    4040:	00004e01 	.word	0x00004e01

00004044 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    4044:	f100 0308 	add.w	r3, r0, #8
    4048:	6043      	str	r3, [r0, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    404a:	f04f 32ff 	mov.w	r2, #4294967295
    404e:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    4050:	60c3      	str	r3, [r0, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    4052:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    4054:	2300      	movs	r3, #0
    4056:	6003      	str	r3, [r0, #0]
    4058:	4770      	bx	lr

0000405a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    405a:	2300      	movs	r3, #0
    405c:	6103      	str	r3, [r0, #16]
    405e:	4770      	bx	lr

00004060 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    4060:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    4062:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    4064:	689a      	ldr	r2, [r3, #8]
    4066:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    4068:	689a      	ldr	r2, [r3, #8]
    406a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    406c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
    406e:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
    4070:	6803      	ldr	r3, [r0, #0]
    4072:	3301      	adds	r3, #1
    4074:	6003      	str	r3, [r0, #0]
    4076:	4770      	bx	lr

00004078 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    4078:	b430      	push	{r4, r5}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    407a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    407c:	f1b5 3fff 	cmp.w	r5, #4294967295
    4080:	d002      	beq.n	4088 <vListInsert+0x10>
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    4082:	f100 0208 	add.w	r2, r0, #8
    4086:	e002      	b.n	408e <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
    4088:	6902      	ldr	r2, [r0, #16]
    408a:	e004      	b.n	4096 <vListInsert+0x1e>
		     pxIterator
		     = pxIterator
    408c:	461a      	mov	r2, r3
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    408e:	6853      	ldr	r3, [r2, #4]
    4090:	681c      	ldr	r4, [r3, #0]
    4092:	42a5      	cmp	r5, r4
    4094:	d2fa      	bcs.n	408c <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    4096:	6853      	ldr	r3, [r2, #4]
    4098:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    409a:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    409c:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    409e:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
    40a0:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
    40a2:	6803      	ldr	r3, [r0, #0]
    40a4:	3301      	adds	r3, #1
    40a6:	6003      	str	r3, [r0, #0]
}
    40a8:	bc30      	pop	{r4, r5}
    40aa:	4770      	bx	lr

000040ac <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    40ac:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    40ae:	6842      	ldr	r2, [r0, #4]
    40b0:	6881      	ldr	r1, [r0, #8]
    40b2:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    40b4:	6882      	ldr	r2, [r0, #8]
    40b6:	6841      	ldr	r1, [r0, #4]
    40b8:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    40ba:	685a      	ldr	r2, [r3, #4]
    40bc:	4290      	cmp	r0, r2
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    40be:	bf04      	itt	eq
    40c0:	6882      	ldreq	r2, [r0, #8]
    40c2:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    40c4:	2200      	movs	r2, #0
    40c6:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    40c8:	6818      	ldr	r0, [r3, #0]
    40ca:	3801      	subs	r0, #1
    40cc:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
    40ce:	4770      	bx	lr

000040d0 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
    40d0:	4b0b      	ldr	r3, [pc, #44]	; (4100 <prvTaskExitError+0x30>)
    40d2:	681b      	ldr	r3, [r3, #0]
    40d4:	f1b3 3fff 	cmp.w	r3, #4294967295
    40d8:	d008      	beq.n	40ec <prvTaskExitError+0x1c>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    40da:	f04f 0380 	mov.w	r3, #128	; 0x80
    40de:	f383 8811 	msr	BASEPRI, r3
    40e2:	f3bf 8f6f 	isb	sy
    40e6:	f3bf 8f4f 	dsb	sy
    40ea:	e7fe      	b.n	40ea <prvTaskExitError+0x1a>
    40ec:	f04f 0380 	mov.w	r3, #128	; 0x80
    40f0:	f383 8811 	msr	BASEPRI, r3
    40f4:	f3bf 8f6f 	isb	sy
    40f8:	f3bf 8f4f 	dsb	sy
    40fc:	e7fe      	b.n	40fc <prvTaskExitError+0x2c>
    40fe:	bf00      	nop
    4100:	20000004 	.word	0x20000004

00004104 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask(void)
{
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    4104:	4806      	ldr	r0, [pc, #24]	; (4120 <prvPortStartFirstTask+0x1c>)
    4106:	6800      	ldr	r0, [r0, #0]
    4108:	6800      	ldr	r0, [r0, #0]
    410a:	f380 8808 	msr	MSP, r0
    410e:	b662      	cpsie	i
    4110:	b661      	cpsie	f
    4112:	f3bf 8f4f 	dsb	sy
    4116:	f3bf 8f6f 	isb	sy
    411a:	df00      	svc	0
    411c:	bf00      	nop
    411e:	0000      	.short	0x0000
    4120:	e000ed08 	.word	0xe000ed08

00004124 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    4124:	f8df 000c 	ldr.w	r0, [pc, #12]	; 4134 <vPortEnableVFP+0x10>
    4128:	6801      	ldr	r1, [r0, #0]
    412a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    412e:	6001      	str	r1, [r0, #0]
    4130:	4770      	bx	lr
    4132:	0000      	.short	0x0000
    4134:	e000ed88 	.word	0xe000ed88

00004138 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    4138:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    413c:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
    4140:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    4144:	4b05      	ldr	r3, [pc, #20]	; (415c <pxPortInitialiseStack+0x24>)
    4146:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    414a:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    414e:	f06f 0302 	mvn.w	r3, #2
    4152:	f840 3c24 	str.w	r3, [r0, #-36]
}
    4156:	3844      	subs	r0, #68	; 0x44
    4158:	4770      	bx	lr
    415a:	bf00      	nop
    415c:	000040d1 	.word	0x000040d1

00004160 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    4160:	4b06      	ldr	r3, [pc, #24]	; (417c <pxCurrentTCBConst2>)
    4162:	6819      	ldr	r1, [r3, #0]
    4164:	6808      	ldr	r0, [r1, #0]
    4166:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    416a:	f380 8809 	msr	PSP, r0
    416e:	f3bf 8f6f 	isb	sy
    4172:	f04f 0000 	mov.w	r0, #0
    4176:	f380 8811 	msr	BASEPRI, r0
    417a:	4770      	bx	lr

0000417c <pxCurrentTCBConst2>:
    417c:	2000e3dc 	.word	0x2000e3dc

00004180 <vPortEnterCritical>:
    4180:	f04f 0380 	mov.w	r3, #128	; 0x80
    4184:	f383 8811 	msr	BASEPRI, r3
    4188:	f3bf 8f6f 	isb	sy
    418c:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    4190:	4a0a      	ldr	r2, [pc, #40]	; (41bc <vPortEnterCritical+0x3c>)
    4192:	6813      	ldr	r3, [r2, #0]
    4194:	3301      	adds	r3, #1
    4196:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    4198:	2b01      	cmp	r3, #1
    419a:	d10d      	bne.n	41b8 <vPortEnterCritical+0x38>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    419c:	4b08      	ldr	r3, [pc, #32]	; (41c0 <vPortEnterCritical+0x40>)
    419e:	681b      	ldr	r3, [r3, #0]
    41a0:	f013 0fff 	tst.w	r3, #255	; 0xff
    41a4:	d008      	beq.n	41b8 <vPortEnterCritical+0x38>
    41a6:	f04f 0380 	mov.w	r3, #128	; 0x80
    41aa:	f383 8811 	msr	BASEPRI, r3
    41ae:	f3bf 8f6f 	isb	sy
    41b2:	f3bf 8f4f 	dsb	sy
    41b6:	e7fe      	b.n	41b6 <vPortEnterCritical+0x36>
    41b8:	4770      	bx	lr
    41ba:	bf00      	nop
    41bc:	20000004 	.word	0x20000004
    41c0:	e000ed04 	.word	0xe000ed04

000041c4 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    41c4:	4b09      	ldr	r3, [pc, #36]	; (41ec <vPortExitCritical+0x28>)
    41c6:	681b      	ldr	r3, [r3, #0]
    41c8:	b943      	cbnz	r3, 41dc <vPortExitCritical+0x18>
    41ca:	f04f 0380 	mov.w	r3, #128	; 0x80
    41ce:	f383 8811 	msr	BASEPRI, r3
    41d2:	f3bf 8f6f 	isb	sy
    41d6:	f3bf 8f4f 	dsb	sy
    41da:	e7fe      	b.n	41da <vPortExitCritical+0x16>
	uxCriticalNesting--;
    41dc:	3b01      	subs	r3, #1
    41de:	4a03      	ldr	r2, [pc, #12]	; (41ec <vPortExitCritical+0x28>)
    41e0:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    41e2:	b90b      	cbnz	r3, 41e8 <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    41e4:	f383 8811 	msr	BASEPRI, r3
    41e8:	4770      	bx	lr
    41ea:	bf00      	nop
    41ec:	20000004 	.word	0x20000004

000041f0 <PendSV_Handler>:
	__asm volatile(
    41f0:	f3ef 8009 	mrs	r0, PSP
    41f4:	f3bf 8f6f 	isb	sy
    41f8:	4b14      	ldr	r3, [pc, #80]	; (424c <pxCurrentTCBConst>)
    41fa:	681a      	ldr	r2, [r3, #0]
    41fc:	f01e 0f10 	tst.w	lr, #16
    4200:	bf08      	it	eq
    4202:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    4206:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    420a:	6010      	str	r0, [r2, #0]
    420c:	f84d 3d04 	str.w	r3, [sp, #-4]!
    4210:	f04f 0080 	mov.w	r0, #128	; 0x80
    4214:	f380 8811 	msr	BASEPRI, r0
    4218:	f3bf 8f4f 	dsb	sy
    421c:	f3bf 8f6f 	isb	sy
    4220:	f001 f934 	bl	548c <vTaskSwitchContext>
    4224:	f04f 0000 	mov.w	r0, #0
    4228:	f380 8811 	msr	BASEPRI, r0
    422c:	bc08      	pop	{r3}
    422e:	6819      	ldr	r1, [r3, #0]
    4230:	6808      	ldr	r0, [r1, #0]
    4232:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4236:	f01e 0f10 	tst.w	lr, #16
    423a:	bf08      	it	eq
    423c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    4240:	f380 8809 	msr	PSP, r0
    4244:	f3bf 8f6f 	isb	sy
    4248:	4770      	bx	lr
    424a:	bf00      	nop

0000424c <pxCurrentTCBConst>:
    424c:	2000e3dc 	.word	0x2000e3dc

00004250 <SysTick_Handler>:
{
    4250:	b508      	push	{r3, lr}
	__asm volatile("	mrs %0, basepri											\n"
    4252:	f3ef 8311 	mrs	r3, BASEPRI
    4256:	f04f 0280 	mov.w	r2, #128	; 0x80
    425a:	f382 8811 	msr	BASEPRI, r2
    425e:	f3bf 8f6f 	isb	sy
    4262:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    4266:	4b05      	ldr	r3, [pc, #20]	; (427c <SysTick_Handler+0x2c>)
    4268:	4798      	blx	r3
    426a:	b118      	cbz	r0, 4274 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    426c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    4270:	4b03      	ldr	r3, [pc, #12]	; (4280 <SysTick_Handler+0x30>)
    4272:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    4274:	2300      	movs	r3, #0
    4276:	f383 8811 	msr	BASEPRI, r3
    427a:	bd08      	pop	{r3, pc}
    427c:	00005179 	.word	0x00005179
    4280:	e000ed04 	.word	0xe000ed04

00004284 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    4284:	4a03      	ldr	r2, [pc, #12]	; (4294 <vPortSetupTimerInterrupt+0x10>)
    4286:	4b04      	ldr	r3, [pc, #16]	; (4298 <vPortSetupTimerInterrupt+0x14>)
    4288:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    428a:	2207      	movs	r2, #7
    428c:	3b04      	subs	r3, #4
    428e:	601a      	str	r2, [r3, #0]
    4290:	4770      	bx	lr
    4292:	bf00      	nop
    4294:	0001d4bd 	.word	0x0001d4bd
    4298:	e000e014 	.word	0xe000e014

0000429c <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    429c:	4b34      	ldr	r3, [pc, #208]	; (4370 <xPortStartScheduler+0xd4>)
    429e:	681a      	ldr	r2, [r3, #0]
    42a0:	4b34      	ldr	r3, [pc, #208]	; (4374 <xPortStartScheduler+0xd8>)
    42a2:	429a      	cmp	r2, r3
    42a4:	d01f      	beq.n	42e6 <xPortStartScheduler+0x4a>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    42a6:	4b32      	ldr	r3, [pc, #200]	; (4370 <xPortStartScheduler+0xd4>)
    42a8:	681a      	ldr	r2, [r3, #0]
    42aa:	4b33      	ldr	r3, [pc, #204]	; (4378 <xPortStartScheduler+0xdc>)
    42ac:	429a      	cmp	r2, r3
    42ae:	d023      	beq.n	42f8 <xPortStartScheduler+0x5c>
{
    42b0:	b500      	push	{lr}
    42b2:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    42b4:	4b31      	ldr	r3, [pc, #196]	; (437c <xPortStartScheduler+0xe0>)
    42b6:	781a      	ldrb	r2, [r3, #0]
    42b8:	b2d2      	uxtb	r2, r2
    42ba:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    42bc:	22ff      	movs	r2, #255	; 0xff
    42be:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    42c0:	781b      	ldrb	r3, [r3, #0]
    42c2:	b2db      	uxtb	r3, r3
    42c4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    42c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    42cc:	4a2c      	ldr	r2, [pc, #176]	; (4380 <xPortStartScheduler+0xe4>)
    42ce:	f003 0380 	and.w	r3, r3, #128	; 0x80
    42d2:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    42d4:	2307      	movs	r3, #7
    42d6:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    42d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    42dc:	f013 0f80 	tst.w	r3, #128	; 0x80
    42e0:	d022      	beq.n	4328 <xPortStartScheduler+0x8c>
    42e2:	2206      	movs	r2, #6
    42e4:	e012      	b.n	430c <xPortStartScheduler+0x70>
	__asm volatile("	mov %0, %1												\n"
    42e6:	f04f 0380 	mov.w	r3, #128	; 0x80
    42ea:	f383 8811 	msr	BASEPRI, r3
    42ee:	f3bf 8f6f 	isb	sy
    42f2:	f3bf 8f4f 	dsb	sy
    42f6:	e7fe      	b.n	42f6 <xPortStartScheduler+0x5a>
    42f8:	f04f 0380 	mov.w	r3, #128	; 0x80
    42fc:	f383 8811 	msr	BASEPRI, r3
    4300:	f3bf 8f6f 	isb	sy
    4304:	f3bf 8f4f 	dsb	sy
    4308:	e7fe      	b.n	4308 <xPortStartScheduler+0x6c>
    430a:	460a      	mov	r2, r1
			ucMaxPriorityValue <<= (uint8_t)0x01;
    430c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    4310:	005b      	lsls	r3, r3, #1
    4312:	b2db      	uxtb	r3, r3
    4314:	f88d 3003 	strb.w	r3, [sp, #3]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    4318:	f89d 3003 	ldrb.w	r3, [sp, #3]
    431c:	1e51      	subs	r1, r2, #1
    431e:	f013 0f80 	tst.w	r3, #128	; 0x80
    4322:	d1f2      	bne.n	430a <xPortStartScheduler+0x6e>
    4324:	4b16      	ldr	r3, [pc, #88]	; (4380 <xPortStartScheduler+0xe4>)
    4326:	605a      	str	r2, [r3, #4]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    4328:	4a15      	ldr	r2, [pc, #84]	; (4380 <xPortStartScheduler+0xe4>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    432a:	6853      	ldr	r3, [r2, #4]
    432c:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    432e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4332:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    4334:	9b01      	ldr	r3, [sp, #4]
    4336:	b2db      	uxtb	r3, r3
    4338:	4a10      	ldr	r2, [pc, #64]	; (437c <xPortStartScheduler+0xe0>)
    433a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    433c:	4b11      	ldr	r3, [pc, #68]	; (4384 <xPortStartScheduler+0xe8>)
    433e:	681a      	ldr	r2, [r3, #0]
    4340:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
    4344:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    4346:	681a      	ldr	r2, [r3, #0]
    4348:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
    434c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    434e:	4b0e      	ldr	r3, [pc, #56]	; (4388 <xPortStartScheduler+0xec>)
    4350:	4798      	blx	r3
	uxCriticalNesting = 0;
    4352:	2200      	movs	r2, #0
    4354:	4b0d      	ldr	r3, [pc, #52]	; (438c <xPortStartScheduler+0xf0>)
    4356:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
    4358:	4b0d      	ldr	r3, [pc, #52]	; (4390 <xPortStartScheduler+0xf4>)
    435a:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    435c:	4a0d      	ldr	r2, [pc, #52]	; (4394 <xPortStartScheduler+0xf8>)
    435e:	6813      	ldr	r3, [r2, #0]
    4360:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    4364:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    4366:	4b0c      	ldr	r3, [pc, #48]	; (4398 <xPortStartScheduler+0xfc>)
    4368:	4798      	blx	r3
	prvTaskExitError();
    436a:	4b0c      	ldr	r3, [pc, #48]	; (439c <xPortStartScheduler+0x100>)
    436c:	4798      	blx	r3
    436e:	bf00      	nop
    4370:	e000ed00 	.word	0xe000ed00
    4374:	410fc271 	.word	0x410fc271
    4378:	410fc270 	.word	0x410fc270
    437c:	e000e400 	.word	0xe000e400
    4380:	20002b90 	.word	0x20002b90
    4384:	e000ed20 	.word	0xe000ed20
    4388:	00004285 	.word	0x00004285
    438c:	20000004 	.word	0x20000004
    4390:	00004125 	.word	0x00004125
    4394:	e000ef34 	.word	0xe000ef34
    4398:	00004105 	.word	0x00004105
    439c:	000040d1 	.word	0x000040d1

000043a0 <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt));
    43a0:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    43a4:	2b0f      	cmp	r3, #15
    43a6:	d90f      	bls.n	43c8 <vPortValidateInterruptPriority+0x28>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    43a8:	4a10      	ldr	r2, [pc, #64]	; (43ec <vPortValidateInterruptPriority+0x4c>)
    43aa:	5c9b      	ldrb	r3, [r3, r2]
    43ac:	b2db      	uxtb	r3, r3
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    43ae:	4a10      	ldr	r2, [pc, #64]	; (43f0 <vPortValidateInterruptPriority+0x50>)
    43b0:	7812      	ldrb	r2, [r2, #0]
    43b2:	429a      	cmp	r2, r3
    43b4:	d908      	bls.n	43c8 <vPortValidateInterruptPriority+0x28>
    43b6:	f04f 0380 	mov.w	r3, #128	; 0x80
    43ba:	f383 8811 	msr	BASEPRI, r3
    43be:	f3bf 8f6f 	isb	sy
    43c2:	f3bf 8f4f 	dsb	sy
    43c6:	e7fe      	b.n	43c6 <vPortValidateInterruptPriority+0x26>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredicable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    43c8:	4b0a      	ldr	r3, [pc, #40]	; (43f4 <vPortValidateInterruptPriority+0x54>)
    43ca:	681b      	ldr	r3, [r3, #0]
    43cc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    43d0:	4a07      	ldr	r2, [pc, #28]	; (43f0 <vPortValidateInterruptPriority+0x50>)
    43d2:	6852      	ldr	r2, [r2, #4]
    43d4:	4293      	cmp	r3, r2
    43d6:	d908      	bls.n	43ea <vPortValidateInterruptPriority+0x4a>
    43d8:	f04f 0380 	mov.w	r3, #128	; 0x80
    43dc:	f383 8811 	msr	BASEPRI, r3
    43e0:	f3bf 8f6f 	isb	sy
    43e4:	f3bf 8f4f 	dsb	sy
    43e8:	e7fe      	b.n	43e8 <vPortValidateInterruptPriority+0x48>
    43ea:	4770      	bx	lr
    43ec:	e000e3f0 	.word	0xe000e3f0
    43f0:	20002b90 	.word	0x20002b90
    43f4:	e000ed0c 	.word	0xe000ed0c

000043f8 <pvPortMalloc>:
		pxIterator->pxNextFreeBlock      = pxBlockToInsert;                                                            \
	}
/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    43f8:	b570      	push	{r4, r5, r6, lr}
    43fa:	4604      	mov	r4, r0
	BlockLink_t *     pxBlock, *pxPreviousBlock, *pxNewBlockLink;
	static BaseType_t xHeapHasBeenInitialised = pdFALSE;
	void *            pvReturn                = NULL;

	vTaskSuspendAll();
    43fc:	4b2d      	ldr	r3, [pc, #180]	; (44b4 <pvPortMalloc+0xbc>)
    43fe:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if (xHeapHasBeenInitialised == pdFALSE) {
    4400:	4b2d      	ldr	r3, [pc, #180]	; (44b8 <pvPortMalloc+0xc0>)
    4402:	689b      	ldr	r3, [r3, #8]
    4404:	b183      	cbz	r3, 4428 <pvPortMalloc+0x30>
			xHeapHasBeenInitialised = pdTRUE;
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if (xWantedSize > 0) {
    4406:	2c00      	cmp	r4, #0
    4408:	d04d      	beq.n	44a6 <pvPortMalloc+0xae>
			xWantedSize += heapSTRUCT_SIZE;
    440a:	3408      	adds	r4, #8

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0) {
    440c:	f014 0f07 	tst.w	r4, #7
				/* Byte alignment required. */
				xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    4410:	bf1c      	itt	ne
    4412:	f024 0407 	bicne.w	r4, r4, #7
    4416:	3408      	addne	r4, #8
			}
		}

		if ((xWantedSize > 0) && (xWantedSize < configADJUSTED_HEAP_SIZE)) {
    4418:	1e62      	subs	r2, r4, #1
    441a:	f24b 73f6 	movw	r3, #47094	; 0xb7f6
    441e:	429a      	cmp	r2, r3
    4420:	d843      	bhi.n	44aa <pvPortMalloc+0xb2>
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock         = xStart.pxNextFreeBlock;
    4422:	4925      	ldr	r1, [pc, #148]	; (44b8 <pvPortMalloc+0xc0>)
    4424:	680b      	ldr	r3, [r1, #0]
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    4426:	e017      	b.n	4458 <pvPortMalloc+0x60>
{
	BlockLink_t *pxFirstFreeBlock;
	uint8_t *    pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    4428:	4923      	ldr	r1, [pc, #140]	; (44b8 <pvPortMalloc+0xc0>)
    442a:	f101 0314 	add.w	r3, r1, #20
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    442e:	f023 0307 	bic.w	r3, r3, #7

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
    4432:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize      = (size_t)0;
    4434:	2500      	movs	r5, #0
    4436:	604d      	str	r5, [r1, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    4438:	4a20      	ldr	r2, [pc, #128]	; (44bc <pvPortMalloc+0xc4>)
    443a:	f24b 70f8 	movw	r0, #47096	; 0xb7f8
    443e:	f8c2 0e60 	str.w	r0, [r2, #3680]	; 0xe60
	xEnd.pxNextFreeBlock = NULL;
    4442:	f8c2 5e5c 	str.w	r5, [r2, #3676]	; 0xe5c

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock                  = (void *)pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize      = configADJUSTED_HEAP_SIZE;
    4446:	6058      	str	r0, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    4448:	f602 625c 	addw	r2, r2, #3676	; 0xe5c
    444c:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
    444e:	2301      	movs	r3, #1
    4450:	608b      	str	r3, [r1, #8]
    4452:	e7d8      	b.n	4406 <pvPortMalloc+0xe>
    4454:	4619      	mov	r1, r3
				pxBlock         = pxBlock->pxNextFreeBlock;
    4456:	4613      	mov	r3, r2
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    4458:	685a      	ldr	r2, [r3, #4]
    445a:	4294      	cmp	r4, r2
    445c:	d902      	bls.n	4464 <pvPortMalloc+0x6c>
    445e:	681a      	ldr	r2, [r3, #0]
    4460:	2a00      	cmp	r2, #0
    4462:	d1f7      	bne.n	4454 <pvPortMalloc+0x5c>
			if (pxBlock != &xEnd) {
    4464:	4a16      	ldr	r2, [pc, #88]	; (44c0 <pvPortMalloc+0xc8>)
    4466:	4293      	cmp	r3, r2
    4468:	d021      	beq.n	44ae <pvPortMalloc+0xb6>
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    446a:	680d      	ldr	r5, [r1, #0]
    446c:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    446e:	681a      	ldr	r2, [r3, #0]
    4470:	600a      	str	r2, [r1, #0]
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    4472:	685a      	ldr	r2, [r3, #4]
    4474:	1b12      	subs	r2, r2, r4
    4476:	2a10      	cmp	r2, #16
    4478:	d90c      	bls.n	4494 <pvPortMalloc+0x9c>
					pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    447a:	191e      	adds	r6, r3, r4
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    447c:	6072      	str	r2, [r6, #4]
					pxBlock->xBlockSize        = xWantedSize;
    447e:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    4480:	6874      	ldr	r4, [r6, #4]
    4482:	490d      	ldr	r1, [pc, #52]	; (44b8 <pvPortMalloc+0xc0>)
    4484:	e000      	b.n	4488 <pvPortMalloc+0x90>
    4486:	4611      	mov	r1, r2
    4488:	680a      	ldr	r2, [r1, #0]
    448a:	6850      	ldr	r0, [r2, #4]
    448c:	4284      	cmp	r4, r0
    448e:	d8fa      	bhi.n	4486 <pvPortMalloc+0x8e>
    4490:	6032      	str	r2, [r6, #0]
    4492:	600e      	str	r6, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    4494:	490b      	ldr	r1, [pc, #44]	; (44c4 <pvPortMalloc+0xcc>)
    4496:	680a      	ldr	r2, [r1, #0]
    4498:	685b      	ldr	r3, [r3, #4]
    449a:	1ad2      	subs	r2, r2, r3
    449c:	600a      	str	r2, [r1, #0]
	(void)xTaskResumeAll();
    449e:	4b0a      	ldr	r3, [pc, #40]	; (44c8 <pvPortMalloc+0xd0>)
    44a0:	4798      	blx	r3
}
    44a2:	4628      	mov	r0, r5
    44a4:	bd70      	pop	{r4, r5, r6, pc}
	void *            pvReturn                = NULL;
    44a6:	2500      	movs	r5, #0
    44a8:	e7f9      	b.n	449e <pvPortMalloc+0xa6>
    44aa:	2500      	movs	r5, #0
    44ac:	e7f7      	b.n	449e <pvPortMalloc+0xa6>
    44ae:	2500      	movs	r5, #0
    44b0:	e7f5      	b.n	449e <pvPortMalloc+0xa6>
    44b2:	bf00      	nop
    44b4:	00005159 	.word	0x00005159
    44b8:	20002b98 	.word	0x20002b98
    44bc:	2000d548 	.word	0x2000d548
    44c0:	2000e3a4 	.word	0x2000e3a4
    44c4:	20000008 	.word	0x20000008
    44c8:	00005285 	.word	0x00005285

000044cc <vPortFree>:
	if (pv != NULL) {
    44cc:	b1d0      	cbz	r0, 4504 <vPortFree+0x38>
{
    44ce:	b570      	push	{r4, r5, r6, lr}
    44d0:	4605      	mov	r5, r0
		puc -= heapSTRUCT_SIZE;
    44d2:	f1a0 0608 	sub.w	r6, r0, #8
		vTaskSuspendAll();
    44d6:	4b0c      	ldr	r3, [pc, #48]	; (4508 <vPortFree+0x3c>)
    44d8:	4798      	blx	r3
			prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    44da:	f855 4c04 	ldr.w	r4, [r5, #-4]
    44de:	4a0b      	ldr	r2, [pc, #44]	; (450c <vPortFree+0x40>)
    44e0:	e000      	b.n	44e4 <vPortFree+0x18>
    44e2:	461a      	mov	r2, r3
    44e4:	6813      	ldr	r3, [r2, #0]
    44e6:	6859      	ldr	r1, [r3, #4]
    44e8:	428c      	cmp	r4, r1
    44ea:	d8fa      	bhi.n	44e2 <vPortFree+0x16>
    44ec:	f845 3c08 	str.w	r3, [r5, #-8]
    44f0:	6016      	str	r6, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
    44f2:	4a07      	ldr	r2, [pc, #28]	; (4510 <vPortFree+0x44>)
    44f4:	f855 3c04 	ldr.w	r3, [r5, #-4]
    44f8:	6811      	ldr	r1, [r2, #0]
    44fa:	440b      	add	r3, r1
    44fc:	6013      	str	r3, [r2, #0]
		(void)xTaskResumeAll();
    44fe:	4b05      	ldr	r3, [pc, #20]	; (4514 <vPortFree+0x48>)
    4500:	4798      	blx	r3
    4502:	bd70      	pop	{r4, r5, r6, pc}
    4504:	4770      	bx	lr
    4506:	bf00      	nop
    4508:	00005159 	.word	0x00005159
    450c:	20002b98 	.word	0x20002b98
    4510:	20000008 	.word	0x20000008
    4514:	00005285 	.word	0x00005285

00004518 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue(Queue_t *const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition)
{
    4518:	b538      	push	{r3, r4, r5, lr}
    451a:	4604      	mov	r4, r0
    451c:	4615      	mov	r5, r2
	BaseType_t xReturn = pdFALSE;

	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    451e:	6c02      	ldr	r2, [r0, #64]	; 0x40
    4520:	b95a      	cbnz	r2, 453a <prvCopyDataToQueue+0x22>
#if (configUSE_MUTEXES == 1)
		{
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    4522:	6803      	ldr	r3, [r0, #0]
    4524:	2b00      	cmp	r3, #0
    4526:	d12e      	bne.n	4586 <prvCopyDataToQueue+0x6e>
				/* The mutex is no longer being held. */
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    4528:	6840      	ldr	r0, [r0, #4]
    452a:	4b1b      	ldr	r3, [pc, #108]	; (4598 <prvCopyDataToQueue+0x80>)
    452c:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    452e:	2300      	movs	r3, #0
    4530:	6063      	str	r3, [r4, #4]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++(pxQueue->uxMessagesWaiting);
    4532:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4534:	3301      	adds	r3, #1
    4536:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
    4538:	bd38      	pop	{r3, r4, r5, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    453a:	b96d      	cbnz	r5, 4558 <prvCopyDataToQueue+0x40>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    453c:	6880      	ldr	r0, [r0, #8]
    453e:	4b17      	ldr	r3, [pc, #92]	; (459c <prvCopyDataToQueue+0x84>)
    4540:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4542:	68a3      	ldr	r3, [r4, #8]
    4544:	6c22      	ldr	r2, [r4, #64]	; 0x40
    4546:	4413      	add	r3, r2
    4548:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    454a:	6862      	ldr	r2, [r4, #4]
    454c:	4293      	cmp	r3, r2
    454e:	d31c      	bcc.n	458a <prvCopyDataToQueue+0x72>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4550:	6823      	ldr	r3, [r4, #0]
    4552:	60a3      	str	r3, [r4, #8]
	BaseType_t xReturn = pdFALSE;
    4554:	2000      	movs	r0, #0
    4556:	e7ec      	b.n	4532 <prvCopyDataToQueue+0x1a>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    4558:	68c0      	ldr	r0, [r0, #12]
    455a:	4b10      	ldr	r3, [pc, #64]	; (459c <prvCopyDataToQueue+0x84>)
    455c:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    455e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    4560:	425b      	negs	r3, r3
    4562:	68e2      	ldr	r2, [r4, #12]
    4564:	441a      	add	r2, r3
    4566:	60e2      	str	r2, [r4, #12]
		if (pxQueue->u.pcReadFrom
    4568:	6821      	ldr	r1, [r4, #0]
    456a:	428a      	cmp	r2, r1
    456c:	d202      	bcs.n	4574 <prvCopyDataToQueue+0x5c>
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    456e:	6862      	ldr	r2, [r4, #4]
    4570:	4413      	add	r3, r2
    4572:	60e3      	str	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
    4574:	2d02      	cmp	r5, #2
    4576:	d10a      	bne.n	458e <prvCopyDataToQueue+0x76>
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
    4578:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    457a:	b153      	cbz	r3, 4592 <prvCopyDataToQueue+0x7a>
				--(pxQueue->uxMessagesWaiting);
    457c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    457e:	3b01      	subs	r3, #1
    4580:	63a3      	str	r3, [r4, #56]	; 0x38
	BaseType_t xReturn = pdFALSE;
    4582:	2000      	movs	r0, #0
    4584:	e7d5      	b.n	4532 <prvCopyDataToQueue+0x1a>
    4586:	2000      	movs	r0, #0
    4588:	e7d3      	b.n	4532 <prvCopyDataToQueue+0x1a>
    458a:	2000      	movs	r0, #0
    458c:	e7d1      	b.n	4532 <prvCopyDataToQueue+0x1a>
    458e:	2000      	movs	r0, #0
    4590:	e7cf      	b.n	4532 <prvCopyDataToQueue+0x1a>
    4592:	2000      	movs	r0, #0
    4594:	e7cd      	b.n	4532 <prvCopyDataToQueue+0x1a>
    4596:	bf00      	nop
    4598:	000057e9 	.word	0x000057e9
    459c:	00005cc5 	.word	0x00005cc5

000045a0 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
    45a0:	b530      	push	{r4, r5, lr}
    45a2:	b083      	sub	sp, #12
    45a4:	9001      	str	r0, [sp, #4]
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    45a6:	6d44      	ldr	r4, [r0, #84]	; 0x54
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    45a8:	b164      	cbz	r4, 45c4 <prvNotifyQueueSetContainer+0x24>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    45aa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    45ac:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    45ae:	429a      	cmp	r2, r3
    45b0:	d311      	bcc.n	45d6 <prvNotifyQueueSetContainer+0x36>
    45b2:	f04f 0380 	mov.w	r3, #128	; 0x80
    45b6:	f383 8811 	msr	BASEPRI, r3
    45ba:	f3bf 8f6f 	isb	sy
    45be:	f3bf 8f4f 	dsb	sy
    45c2:	e7fe      	b.n	45c2 <prvNotifyQueueSetContainer+0x22>
    45c4:	f04f 0380 	mov.w	r3, #128	; 0x80
    45c8:	f383 8811 	msr	BASEPRI, r3
    45cc:	f3bf 8f6f 	isb	sy
    45d0:	f3bf 8f4f 	dsb	sy
    45d4:	e7fe      	b.n	45d4 <prvNotifyQueueSetContainer+0x34>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    45d6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    45d8:	4293      	cmp	r3, r2
    45da:	d803      	bhi.n	45e4 <prvNotifyQueueSetContainer+0x44>
	BaseType_t xReturn             = pdFALSE;
    45dc:	2500      	movs	r5, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    45de:	4628      	mov	r0, r5
    45e0:	b003      	add	sp, #12
    45e2:	bd30      	pop	{r4, r5, pc}
    45e4:	460a      	mov	r2, r1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    45e6:	a901      	add	r1, sp, #4
    45e8:	4620      	mov	r0, r4
    45ea:	4b0b      	ldr	r3, [pc, #44]	; (4618 <prvNotifyQueueSetContainer+0x78>)
    45ec:	4798      	blx	r3
    45ee:	4605      	mov	r5, r0
		if (pxQueueSetContainer->xTxLock == queueUNLOCKED) {
    45f0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    45f2:	f1b3 3fff 	cmp.w	r3, #4294967295
    45f6:	d10a      	bne.n	460e <prvNotifyQueueSetContainer+0x6e>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    45f8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    45fa:	2b00      	cmp	r3, #0
    45fc:	d0ef      	beq.n	45de <prvNotifyQueueSetContainer+0x3e>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    45fe:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4602:	4b06      	ldr	r3, [pc, #24]	; (461c <prvNotifyQueueSetContainer+0x7c>)
    4604:	4798      	blx	r3
    4606:	2800      	cmp	r0, #0
					xReturn = pdTRUE;
    4608:	bf18      	it	ne
    460a:	2501      	movne	r5, #1
    460c:	e7e7      	b.n	45de <prvNotifyQueueSetContainer+0x3e>
			(pxQueueSetContainer->xTxLock)++;
    460e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4610:	3301      	adds	r3, #1
    4612:	64a3      	str	r3, [r4, #72]	; 0x48
    4614:	e7e3      	b.n	45de <prvNotifyQueueSetContainer+0x3e>
    4616:	bf00      	nop
    4618:	00004519 	.word	0x00004519
    461c:	000055f1 	.word	0x000055f1

00004620 <prvCopyDataFromQueue>:
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    4620:	6c02      	ldr	r2, [r0, #64]	; 0x40
    4622:	b172      	cbz	r2, 4642 <prvCopyDataFromQueue+0x22>
{
    4624:	b510      	push	{r4, lr}
    4626:	4603      	mov	r3, r0
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4628:	68c4      	ldr	r4, [r0, #12]
    462a:	4414      	add	r4, r2
    462c:	60c4      	str	r4, [r0, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    462e:	6840      	ldr	r0, [r0, #4]
    4630:	4284      	cmp	r4, r0
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4632:	bf24      	itt	cs
    4634:	6818      	ldrcs	r0, [r3, #0]
    4636:	60d8      	strcs	r0, [r3, #12]
    4638:	4608      	mov	r0, r1
		(void)memcpy((void *)pvBuffer,
    463a:	68d9      	ldr	r1, [r3, #12]
    463c:	4b01      	ldr	r3, [pc, #4]	; (4644 <prvCopyDataFromQueue+0x24>)
    463e:	4798      	blx	r3
    4640:	bd10      	pop	{r4, pc}
    4642:	4770      	bx	lr
    4644:	00005cc5 	.word	0x00005cc5

00004648 <prvUnlockQueue>:
{
    4648:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    464a:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    464c:	4b22      	ldr	r3, [pc, #136]	; (46d8 <prvUnlockQueue+0x90>)
    464e:	4798      	blx	r3
		while (pxQueue->xTxLock > queueLOCKED_UNMODIFIED) {
    4650:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4652:	2b00      	cmp	r3, #0
    4654:	dd1b      	ble.n	468e <prvUnlockQueue+0x46>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
    4656:	4d21      	ldr	r5, [pc, #132]	; (46dc <prvUnlockQueue+0x94>)
						vTaskMissedYield();
    4658:	4f21      	ldr	r7, [pc, #132]	; (46e0 <prvUnlockQueue+0x98>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    465a:	4e22      	ldr	r6, [pc, #136]	; (46e4 <prvUnlockQueue+0x9c>)
    465c:	e00b      	b.n	4676 <prvUnlockQueue+0x2e>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    465e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4660:	b1ab      	cbz	r3, 468e <prvUnlockQueue+0x46>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    4662:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4666:	47b0      	blx	r6
    4668:	b978      	cbnz	r0, 468a <prvUnlockQueue+0x42>
			--(pxQueue->xTxLock);
    466a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    466c:	3b01      	subs	r3, #1
    466e:	64a3      	str	r3, [r4, #72]	; 0x48
		while (pxQueue->xTxLock > queueLOCKED_UNMODIFIED) {
    4670:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4672:	2b00      	cmp	r3, #0
    4674:	dd0b      	ble.n	468e <prvUnlockQueue+0x46>
				if (pxQueue->pxQueueSetContainer != NULL) {
    4676:	6d63      	ldr	r3, [r4, #84]	; 0x54
    4678:	2b00      	cmp	r3, #0
    467a:	d0f0      	beq.n	465e <prvUnlockQueue+0x16>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
    467c:	2100      	movs	r1, #0
    467e:	4620      	mov	r0, r4
    4680:	47a8      	blx	r5
    4682:	2801      	cmp	r0, #1
    4684:	d1f1      	bne.n	466a <prvUnlockQueue+0x22>
						vTaskMissedYield();
    4686:	47b8      	blx	r7
    4688:	e7ef      	b.n	466a <prvUnlockQueue+0x22>
							vTaskMissedYield();
    468a:	47b8      	blx	r7
    468c:	e7ed      	b.n	466a <prvUnlockQueue+0x22>
		pxQueue->xTxLock = queueUNLOCKED;
    468e:	f04f 33ff 	mov.w	r3, #4294967295
    4692:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
    4694:	4b14      	ldr	r3, [pc, #80]	; (46e8 <prvUnlockQueue+0xa0>)
    4696:	4798      	blx	r3
	taskENTER_CRITICAL();
    4698:	4b0f      	ldr	r3, [pc, #60]	; (46d8 <prvUnlockQueue+0x90>)
    469a:	4798      	blx	r3
		while (pxQueue->xRxLock > queueLOCKED_UNMODIFIED) {
    469c:	6c63      	ldr	r3, [r4, #68]	; 0x44
    469e:	2b00      	cmp	r3, #0
    46a0:	dd14      	ble.n	46cc <prvUnlockQueue+0x84>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    46a2:	6923      	ldr	r3, [r4, #16]
    46a4:	b193      	cbz	r3, 46cc <prvUnlockQueue+0x84>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    46a6:	f104 0610 	add.w	r6, r4, #16
    46aa:	4d0e      	ldr	r5, [pc, #56]	; (46e4 <prvUnlockQueue+0x9c>)
					vTaskMissedYield();
    46ac:	4f0c      	ldr	r7, [pc, #48]	; (46e0 <prvUnlockQueue+0x98>)
    46ae:	e007      	b.n	46c0 <prvUnlockQueue+0x78>
				--(pxQueue->xRxLock);
    46b0:	6c63      	ldr	r3, [r4, #68]	; 0x44
    46b2:	3b01      	subs	r3, #1
    46b4:	6463      	str	r3, [r4, #68]	; 0x44
		while (pxQueue->xRxLock > queueLOCKED_UNMODIFIED) {
    46b6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    46b8:	2b00      	cmp	r3, #0
    46ba:	dd07      	ble.n	46cc <prvUnlockQueue+0x84>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    46bc:	6923      	ldr	r3, [r4, #16]
    46be:	b12b      	cbz	r3, 46cc <prvUnlockQueue+0x84>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    46c0:	4630      	mov	r0, r6
    46c2:	47a8      	blx	r5
    46c4:	2800      	cmp	r0, #0
    46c6:	d0f3      	beq.n	46b0 <prvUnlockQueue+0x68>
					vTaskMissedYield();
    46c8:	47b8      	blx	r7
    46ca:	e7f1      	b.n	46b0 <prvUnlockQueue+0x68>
		pxQueue->xRxLock = queueUNLOCKED;
    46cc:	f04f 33ff 	mov.w	r3, #4294967295
    46d0:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    46d2:	4b05      	ldr	r3, [pc, #20]	; (46e8 <prvUnlockQueue+0xa0>)
    46d4:	4798      	blx	r3
    46d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    46d8:	00004181 	.word	0x00004181
    46dc:	000045a1 	.word	0x000045a1
    46e0:	00005735 	.word	0x00005735
    46e4:	000055f1 	.word	0x000055f1
    46e8:	000041c5 	.word	0x000041c5

000046ec <xQueueGenericReset>:
{
    46ec:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxQueue);
    46ee:	b308      	cbz	r0, 4734 <xQueueGenericReset+0x48>
    46f0:	4604      	mov	r4, r0
    46f2:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
    46f4:	4b1c      	ldr	r3, [pc, #112]	; (4768 <xQueueGenericReset+0x7c>)
    46f6:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    46f8:	6822      	ldr	r2, [r4, #0]
    46fa:	6c21      	ldr	r1, [r4, #64]	; 0x40
    46fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    46fe:	fb03 f301 	mul.w	r3, r3, r1
    4702:	18d0      	adds	r0, r2, r3
    4704:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    4706:	2000      	movs	r0, #0
    4708:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    470a:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    470c:	1a5b      	subs	r3, r3, r1
    470e:	4413      	add	r3, r2
    4710:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock           = queueUNLOCKED;
    4712:	f04f 33ff 	mov.w	r3, #4294967295
    4716:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock           = queueUNLOCKED;
    4718:	64a3      	str	r3, [r4, #72]	; 0x48
		if (xNewQueue == pdFALSE) {
    471a:	b9ed      	cbnz	r5, 4758 <xQueueGenericReset+0x6c>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    471c:	6923      	ldr	r3, [r4, #16]
    471e:	b12b      	cbz	r3, 472c <xQueueGenericReset+0x40>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
    4720:	f104 0010 	add.w	r0, r4, #16
    4724:	4b11      	ldr	r3, [pc, #68]	; (476c <xQueueGenericReset+0x80>)
    4726:	4798      	blx	r3
    4728:	2801      	cmp	r0, #1
    472a:	d00c      	beq.n	4746 <xQueueGenericReset+0x5a>
	taskEXIT_CRITICAL();
    472c:	4b10      	ldr	r3, [pc, #64]	; (4770 <xQueueGenericReset+0x84>)
    472e:	4798      	blx	r3
}
    4730:	2001      	movs	r0, #1
    4732:	bd38      	pop	{r3, r4, r5, pc}
    4734:	f04f 0380 	mov.w	r3, #128	; 0x80
    4738:	f383 8811 	msr	BASEPRI, r3
    473c:	f3bf 8f6f 	isb	sy
    4740:	f3bf 8f4f 	dsb	sy
    4744:	e7fe      	b.n	4744 <xQueueGenericReset+0x58>
					queueYIELD_IF_USING_PREEMPTION();
    4746:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    474a:	4b0a      	ldr	r3, [pc, #40]	; (4774 <xQueueGenericReset+0x88>)
    474c:	601a      	str	r2, [r3, #0]
    474e:	f3bf 8f4f 	dsb	sy
    4752:	f3bf 8f6f 	isb	sy
    4756:	e7e9      	b.n	472c <xQueueGenericReset+0x40>
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    4758:	f104 0010 	add.w	r0, r4, #16
    475c:	4d06      	ldr	r5, [pc, #24]	; (4778 <xQueueGenericReset+0x8c>)
    475e:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    4760:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4764:	47a8      	blx	r5
    4766:	e7e1      	b.n	472c <xQueueGenericReset+0x40>
    4768:	00004181 	.word	0x00004181
    476c:	000055f1 	.word	0x000055f1
    4770:	000041c5 	.word	0x000041c5
    4774:	e000ed04 	.word	0xe000ed04
    4778:	00004045 	.word	0x00004045

0000477c <xQueueGenericCreate>:
{
    477c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT(uxQueueLength > (UBaseType_t)0);
    477e:	b940      	cbnz	r0, 4792 <xQueueGenericCreate+0x16>
    4780:	f04f 0380 	mov.w	r3, #128	; 0x80
    4784:	f383 8811 	msr	BASEPRI, r3
    4788:	f3bf 8f6f 	isb	sy
    478c:	f3bf 8f4f 	dsb	sy
    4790:	e7fe      	b.n	4790 <xQueueGenericCreate+0x14>
    4792:	4606      	mov	r6, r0
    4794:	4617      	mov	r7, r2
    4796:	460d      	mov	r5, r1
	if (uxItemSize == (UBaseType_t)0) {
    4798:	b179      	cbz	r1, 47ba <xQueueGenericCreate+0x3e>
		xQueueSizeInBytes = (size_t)(uxQueueLength * uxItemSize)
    479a:	fb01 f000 	mul.w	r0, r1, r0
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    479e:	3059      	adds	r0, #89	; 0x59
    47a0:	4b11      	ldr	r3, [pc, #68]	; (47e8 <xQueueGenericCreate+0x6c>)
    47a2:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    47a4:	4604      	mov	r4, r0
    47a6:	b9d8      	cbnz	r0, 47e0 <xQueueGenericCreate+0x64>
    47a8:	f04f 0380 	mov.w	r3, #128	; 0x80
    47ac:	f383 8811 	msr	BASEPRI, r3
    47b0:	f3bf 8f6f 	isb	sy
    47b4:	f3bf 8f4f 	dsb	sy
    47b8:	e7fe      	b.n	47b8 <xQueueGenericCreate+0x3c>
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    47ba:	2058      	movs	r0, #88	; 0x58
    47bc:	4b0a      	ldr	r3, [pc, #40]	; (47e8 <xQueueGenericCreate+0x6c>)
    47be:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    47c0:	4604      	mov	r4, r0
    47c2:	2800      	cmp	r0, #0
    47c4:	d0f0      	beq.n	47a8 <xQueueGenericCreate+0x2c>
			pxNewQueue->pcHead = (int8_t *)pxNewQueue;
    47c6:	6020      	str	r0, [r4, #0]
		pxNewQueue->uxLength   = uxQueueLength;
    47c8:	63e6      	str	r6, [r4, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
    47ca:	6425      	str	r5, [r4, #64]	; 0x40
		(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    47cc:	2101      	movs	r1, #1
    47ce:	4620      	mov	r0, r4
    47d0:	4b06      	ldr	r3, [pc, #24]	; (47ec <xQueueGenericCreate+0x70>)
    47d2:	4798      	blx	r3
			pxNewQueue->ucQueueType = ucQueueType;
    47d4:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
			pxNewQueue->pxQueueSetContainer = NULL;
    47d8:	2300      	movs	r3, #0
    47da:	6563      	str	r3, [r4, #84]	; 0x54
}
    47dc:	4620      	mov	r0, r4
    47de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			pxNewQueue->pcHead = ((int8_t *)pxNewQueue) + sizeof(Queue_t);
    47e0:	f100 0358 	add.w	r3, r0, #88	; 0x58
    47e4:	6003      	str	r3, [r0, #0]
    47e6:	e7ef      	b.n	47c8 <xQueueGenericCreate+0x4c>
    47e8:	000043f9 	.word	0x000043f9
    47ec:	000046ed 	.word	0x000046ed

000047f0 <xQueueCreateCountingSemaphore>:
	configASSERT(uxMaxCount != 0);
    47f0:	b940      	cbnz	r0, 4804 <xQueueCreateCountingSemaphore+0x14>
    47f2:	f04f 0380 	mov.w	r3, #128	; 0x80
    47f6:	f383 8811 	msr	BASEPRI, r3
    47fa:	f3bf 8f6f 	isb	sy
    47fe:	f3bf 8f4f 	dsb	sy
    4802:	e7fe      	b.n	4802 <xQueueCreateCountingSemaphore+0x12>
	configASSERT(uxInitialCount <= uxMaxCount);
    4804:	4288      	cmp	r0, r1
    4806:	d208      	bcs.n	481a <xQueueCreateCountingSemaphore+0x2a>
    4808:	f04f 0380 	mov.w	r3, #128	; 0x80
    480c:	f383 8811 	msr	BASEPRI, r3
    4810:	f3bf 8f6f 	isb	sy
    4814:	f3bf 8f4f 	dsb	sy
    4818:	e7fe      	b.n	4818 <xQueueCreateCountingSemaphore+0x28>
{
    481a:	b510      	push	{r4, lr}
    481c:	460c      	mov	r4, r1
	xHandle = xQueueGenericCreate(uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE);
    481e:	2202      	movs	r2, #2
    4820:	2100      	movs	r1, #0
    4822:	4b07      	ldr	r3, [pc, #28]	; (4840 <xQueueCreateCountingSemaphore+0x50>)
    4824:	4798      	blx	r3
	if (xHandle != NULL) {
    4826:	b108      	cbz	r0, 482c <xQueueCreateCountingSemaphore+0x3c>
		((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;
    4828:	6384      	str	r4, [r0, #56]	; 0x38
}
    482a:	bd10      	pop	{r4, pc}
    482c:	f04f 0380 	mov.w	r3, #128	; 0x80
    4830:	f383 8811 	msr	BASEPRI, r3
    4834:	f3bf 8f6f 	isb	sy
    4838:	f3bf 8f4f 	dsb	sy
    483c:	e7fe      	b.n	483c <xQueueCreateCountingSemaphore+0x4c>
    483e:	bf00      	nop
    4840:	0000477d 	.word	0x0000477d

00004844 <xQueueGenericSend>:
{
    4844:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4848:	b085      	sub	sp, #20
    484a:	9201      	str	r2, [sp, #4]
	configASSERT(pxQueue);
    484c:	b198      	cbz	r0, 4876 <xQueueGenericSend+0x32>
    484e:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    4850:	b1d1      	cbz	r1, 4888 <xQueueGenericSend+0x44>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    4852:	2b02      	cmp	r3, #2
    4854:	d024      	beq.n	48a0 <xQueueGenericSend+0x5c>
    4856:	461d      	mov	r5, r3
    4858:	4688      	mov	r8, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    485a:	4b61      	ldr	r3, [pc, #388]	; (49e0 <xQueueGenericSend+0x19c>)
    485c:	4798      	blx	r3
    485e:	bb58      	cbnz	r0, 48b8 <xQueueGenericSend+0x74>
    4860:	9b01      	ldr	r3, [sp, #4]
    4862:	b383      	cbz	r3, 48c6 <xQueueGenericSend+0x82>
    4864:	f04f 0380 	mov.w	r3, #128	; 0x80
    4868:	f383 8811 	msr	BASEPRI, r3
    486c:	f3bf 8f6f 	isb	sy
    4870:	f3bf 8f4f 	dsb	sy
    4874:	e7fe      	b.n	4874 <xQueueGenericSend+0x30>
    4876:	f04f 0380 	mov.w	r3, #128	; 0x80
    487a:	f383 8811 	msr	BASEPRI, r3
    487e:	f3bf 8f6f 	isb	sy
    4882:	f3bf 8f4f 	dsb	sy
    4886:	e7fe      	b.n	4886 <xQueueGenericSend+0x42>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    4888:	6c02      	ldr	r2, [r0, #64]	; 0x40
    488a:	2a00      	cmp	r2, #0
    488c:	d0e1      	beq.n	4852 <xQueueGenericSend+0xe>
    488e:	f04f 0380 	mov.w	r3, #128	; 0x80
    4892:	f383 8811 	msr	BASEPRI, r3
    4896:	f3bf 8f6f 	isb	sy
    489a:	f3bf 8f4f 	dsb	sy
    489e:	e7fe      	b.n	489e <xQueueGenericSend+0x5a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    48a0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    48a2:	2a01      	cmp	r2, #1
    48a4:	d0d7      	beq.n	4856 <xQueueGenericSend+0x12>
    48a6:	f04f 0380 	mov.w	r3, #128	; 0x80
    48aa:	f383 8811 	msr	BASEPRI, r3
    48ae:	f3bf 8f6f 	isb	sy
    48b2:	f3bf 8f4f 	dsb	sy
    48b6:	e7fe      	b.n	48b6 <xQueueGenericSend+0x72>
    48b8:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
    48ba:	4e4a      	ldr	r6, [pc, #296]	; (49e4 <xQueueGenericSend+0x1a0>)
					vTaskSetTimeOutState(&xTimeOut);
    48bc:	f8df a150 	ldr.w	sl, [pc, #336]	; 4a10 <xQueueGenericSend+0x1cc>
					portYIELD_WITHIN_API();
    48c0:	f8df 912c 	ldr.w	r9, [pc, #300]	; 49f0 <xQueueGenericSend+0x1ac>
    48c4:	e042      	b.n	494c <xQueueGenericSend+0x108>
    48c6:	2700      	movs	r7, #0
    48c8:	e7f7      	b.n	48ba <xQueueGenericSend+0x76>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    48ca:	462a      	mov	r2, r5
    48cc:	4641      	mov	r1, r8
    48ce:	4620      	mov	r0, r4
    48d0:	4b45      	ldr	r3, [pc, #276]	; (49e8 <xQueueGenericSend+0x1a4>)
    48d2:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
    48d4:	6d63      	ldr	r3, [r4, #84]	; 0x54
    48d6:	b19b      	cbz	r3, 4900 <xQueueGenericSend+0xbc>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
    48d8:	4629      	mov	r1, r5
    48da:	4620      	mov	r0, r4
    48dc:	4b43      	ldr	r3, [pc, #268]	; (49ec <xQueueGenericSend+0x1a8>)
    48de:	4798      	blx	r3
    48e0:	2801      	cmp	r0, #1
    48e2:	d107      	bne.n	48f4 <xQueueGenericSend+0xb0>
							queueYIELD_IF_USING_PREEMPTION();
    48e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    48e8:	4b41      	ldr	r3, [pc, #260]	; (49f0 <xQueueGenericSend+0x1ac>)
    48ea:	601a      	str	r2, [r3, #0]
    48ec:	f3bf 8f4f 	dsb	sy
    48f0:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    48f4:	4b3f      	ldr	r3, [pc, #252]	; (49f4 <xQueueGenericSend+0x1b0>)
    48f6:	4798      	blx	r3
				return pdPASS;
    48f8:	2001      	movs	r0, #1
}
    48fa:	b005      	add	sp, #20
    48fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    4900:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4902:	b173      	cbz	r3, 4922 <xQueueGenericSend+0xde>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) == pdTRUE) {
    4904:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4908:	4b3b      	ldr	r3, [pc, #236]	; (49f8 <xQueueGenericSend+0x1b4>)
    490a:	4798      	blx	r3
    490c:	2801      	cmp	r0, #1
    490e:	d1f1      	bne.n	48f4 <xQueueGenericSend+0xb0>
								queueYIELD_IF_USING_PREEMPTION();
    4910:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    4914:	4b36      	ldr	r3, [pc, #216]	; (49f0 <xQueueGenericSend+0x1ac>)
    4916:	601a      	str	r2, [r3, #0]
    4918:	f3bf 8f4f 	dsb	sy
    491c:	f3bf 8f6f 	isb	sy
    4920:	e7e8      	b.n	48f4 <xQueueGenericSend+0xb0>
						} else if (xYieldRequired != pdFALSE) {
    4922:	2800      	cmp	r0, #0
    4924:	d0e6      	beq.n	48f4 <xQueueGenericSend+0xb0>
							queueYIELD_IF_USING_PREEMPTION();
    4926:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    492a:	4b31      	ldr	r3, [pc, #196]	; (49f0 <xQueueGenericSend+0x1ac>)
    492c:	601a      	str	r2, [r3, #0]
    492e:	f3bf 8f4f 	dsb	sy
    4932:	f3bf 8f6f 	isb	sy
    4936:	e7dd      	b.n	48f4 <xQueueGenericSend+0xb0>
					taskEXIT_CRITICAL();
    4938:	4b2e      	ldr	r3, [pc, #184]	; (49f4 <xQueueGenericSend+0x1b0>)
    493a:	4798      	blx	r3
					return errQUEUE_FULL;
    493c:	2000      	movs	r0, #0
    493e:	e7dc      	b.n	48fa <xQueueGenericSend+0xb6>
				prvUnlockQueue(pxQueue);
    4940:	4620      	mov	r0, r4
    4942:	4b2e      	ldr	r3, [pc, #184]	; (49fc <xQueueGenericSend+0x1b8>)
    4944:	4798      	blx	r3
				(void)xTaskResumeAll();
    4946:	4b2e      	ldr	r3, [pc, #184]	; (4a00 <xQueueGenericSend+0x1bc>)
    4948:	4798      	blx	r3
    494a:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
    494c:	47b0      	blx	r6
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    494e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    4950:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    4952:	429a      	cmp	r2, r3
    4954:	d3b9      	bcc.n	48ca <xQueueGenericSend+0x86>
    4956:	2d02      	cmp	r5, #2
    4958:	d0b7      	beq.n	48ca <xQueueGenericSend+0x86>
				if (xTicksToWait == (TickType_t)0) {
    495a:	9b01      	ldr	r3, [sp, #4]
    495c:	2b00      	cmp	r3, #0
    495e:	d0eb      	beq.n	4938 <xQueueGenericSend+0xf4>
				} else if (xEntryTimeSet == pdFALSE) {
    4960:	b90f      	cbnz	r7, 4966 <xQueueGenericSend+0x122>
					vTaskSetTimeOutState(&xTimeOut);
    4962:	a802      	add	r0, sp, #8
    4964:	47d0      	blx	sl
		taskEXIT_CRITICAL();
    4966:	4b23      	ldr	r3, [pc, #140]	; (49f4 <xQueueGenericSend+0x1b0>)
    4968:	4798      	blx	r3
		vTaskSuspendAll();
    496a:	4b26      	ldr	r3, [pc, #152]	; (4a04 <xQueueGenericSend+0x1c0>)
    496c:	4798      	blx	r3
		prvLockQueue(pxQueue);
    496e:	47b0      	blx	r6
    4970:	6c63      	ldr	r3, [r4, #68]	; 0x44
    4972:	f1b3 3fff 	cmp.w	r3, #4294967295
    4976:	bf04      	itt	eq
    4978:	2300      	moveq	r3, #0
    497a:	6463      	streq	r3, [r4, #68]	; 0x44
    497c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    497e:	f1b3 3fff 	cmp.w	r3, #4294967295
    4982:	bf04      	itt	eq
    4984:	2300      	moveq	r3, #0
    4986:	64a3      	streq	r3, [r4, #72]	; 0x48
    4988:	4b1a      	ldr	r3, [pc, #104]	; (49f4 <xQueueGenericSend+0x1b0>)
    498a:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    498c:	a901      	add	r1, sp, #4
    498e:	a802      	add	r0, sp, #8
    4990:	4b1d      	ldr	r3, [pc, #116]	; (4a08 <xQueueGenericSend+0x1c4>)
    4992:	4798      	blx	r3
    4994:	b9e0      	cbnz	r0, 49d0 <xQueueGenericSend+0x18c>
	taskENTER_CRITICAL();
    4996:	47b0      	blx	r6
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    4998:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
    499c:	6be7      	ldr	r7, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
    499e:	4b15      	ldr	r3, [pc, #84]	; (49f4 <xQueueGenericSend+0x1b0>)
    49a0:	4798      	blx	r3
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
    49a2:	45bb      	cmp	fp, r7
    49a4:	d1cc      	bne.n	4940 <xQueueGenericSend+0xfc>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    49a6:	9901      	ldr	r1, [sp, #4]
    49a8:	f104 0010 	add.w	r0, r4, #16
    49ac:	4b17      	ldr	r3, [pc, #92]	; (4a0c <xQueueGenericSend+0x1c8>)
    49ae:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    49b0:	4620      	mov	r0, r4
    49b2:	4b12      	ldr	r3, [pc, #72]	; (49fc <xQueueGenericSend+0x1b8>)
    49b4:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    49b6:	4b12      	ldr	r3, [pc, #72]	; (4a00 <xQueueGenericSend+0x1bc>)
    49b8:	4798      	blx	r3
    49ba:	2800      	cmp	r0, #0
    49bc:	d1c5      	bne.n	494a <xQueueGenericSend+0x106>
					portYIELD_WITHIN_API();
    49be:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    49c2:	f8c9 3000 	str.w	r3, [r9]
    49c6:	f3bf 8f4f 	dsb	sy
    49ca:	f3bf 8f6f 	isb	sy
    49ce:	e7bc      	b.n	494a <xQueueGenericSend+0x106>
			prvUnlockQueue(pxQueue);
    49d0:	4620      	mov	r0, r4
    49d2:	4b0a      	ldr	r3, [pc, #40]	; (49fc <xQueueGenericSend+0x1b8>)
    49d4:	4798      	blx	r3
			(void)xTaskResumeAll();
    49d6:	4b0a      	ldr	r3, [pc, #40]	; (4a00 <xQueueGenericSend+0x1bc>)
    49d8:	4798      	blx	r3
			return errQUEUE_FULL;
    49da:	2000      	movs	r0, #0
    49dc:	e78d      	b.n	48fa <xQueueGenericSend+0xb6>
    49de:	bf00      	nop
    49e0:	00005745 	.word	0x00005745
    49e4:	00004181 	.word	0x00004181
    49e8:	00004519 	.word	0x00004519
    49ec:	000045a1 	.word	0x000045a1
    49f0:	e000ed04 	.word	0xe000ed04
    49f4:	000041c5 	.word	0x000041c5
    49f8:	000055f1 	.word	0x000055f1
    49fc:	00004649 	.word	0x00004649
    4a00:	00005285 	.word	0x00005285
    4a04:	00005159 	.word	0x00005159
    4a08:	000056a9 	.word	0x000056a9
    4a0c:	0000553d 	.word	0x0000553d
    4a10:	00005681 	.word	0x00005681

00004a14 <xQueueCreateMutex>:
{
    4a14:	b570      	push	{r4, r5, r6, lr}
    4a16:	4606      	mov	r6, r0
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t));
    4a18:	2058      	movs	r0, #88	; 0x58
    4a1a:	4b11      	ldr	r3, [pc, #68]	; (4a60 <xQueueCreateMutex+0x4c>)
    4a1c:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    4a1e:	4604      	mov	r4, r0
    4a20:	b1d8      	cbz	r0, 4a5a <xQueueCreateMutex+0x46>
		pxNewQueue->pxMutexHolder = NULL;
    4a22:	2500      	movs	r5, #0
    4a24:	6045      	str	r5, [r0, #4]
		pxNewQueue->uxQueueType   = queueQUEUE_IS_MUTEX;
    4a26:	6005      	str	r5, [r0, #0]
		pxNewQueue->pcWriteTo    = NULL;
    4a28:	6085      	str	r5, [r0, #8]
		pxNewQueue->u.pcReadFrom = NULL;
    4a2a:	60c5      	str	r5, [r0, #12]
		pxNewQueue->uxMessagesWaiting = (UBaseType_t)0U;
    4a2c:	6385      	str	r5, [r0, #56]	; 0x38
		pxNewQueue->uxLength          = (UBaseType_t)1U;
    4a2e:	2301      	movs	r3, #1
    4a30:	63c3      	str	r3, [r0, #60]	; 0x3c
		pxNewQueue->uxItemSize        = (UBaseType_t)0U;
    4a32:	6405      	str	r5, [r0, #64]	; 0x40
		pxNewQueue->xRxLock           = queueUNLOCKED;
    4a34:	f04f 33ff 	mov.w	r3, #4294967295
    4a38:	6443      	str	r3, [r0, #68]	; 0x44
		pxNewQueue->xTxLock           = queueUNLOCKED;
    4a3a:	6483      	str	r3, [r0, #72]	; 0x48
			pxNewQueue->ucQueueType = ucQueueType;
    4a3c:	f880 6050 	strb.w	r6, [r0, #80]	; 0x50
			pxNewQueue->pxQueueSetContainer = NULL;
    4a40:	6545      	str	r5, [r0, #84]	; 0x54
		vListInitialise(&(pxNewQueue->xTasksWaitingToSend));
    4a42:	3010      	adds	r0, #16
    4a44:	4e07      	ldr	r6, [pc, #28]	; (4a64 <xQueueCreateMutex+0x50>)
    4a46:	47b0      	blx	r6
		vListInitialise(&(pxNewQueue->xTasksWaitingToReceive));
    4a48:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4a4c:	47b0      	blx	r6
		(void)xQueueGenericSend(pxNewQueue, NULL, (TickType_t)0U, queueSEND_TO_BACK);
    4a4e:	462b      	mov	r3, r5
    4a50:	462a      	mov	r2, r5
    4a52:	4629      	mov	r1, r5
    4a54:	4620      	mov	r0, r4
    4a56:	4d04      	ldr	r5, [pc, #16]	; (4a68 <xQueueCreateMutex+0x54>)
    4a58:	47a8      	blx	r5
}
    4a5a:	4620      	mov	r0, r4
    4a5c:	bd70      	pop	{r4, r5, r6, pc}
    4a5e:	bf00      	nop
    4a60:	000043f9 	.word	0x000043f9
    4a64:	00004045 	.word	0x00004045
    4a68:	00004845 	.word	0x00004845

00004a6c <xQueueGenericSendFromISR>:
	configASSERT(pxQueue);
    4a6c:	2800      	cmp	r0, #0
    4a6e:	d033      	beq.n	4ad8 <xQueueGenericSendFromISR+0x6c>
{
    4a70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4a74:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    4a76:	2900      	cmp	r1, #0
    4a78:	d037      	beq.n	4aea <xQueueGenericSendFromISR+0x7e>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    4a7a:	2b02      	cmp	r3, #2
    4a7c:	d041      	beq.n	4b02 <xQueueGenericSendFromISR+0x96>
    4a7e:	461e      	mov	r6, r3
    4a80:	4615      	mov	r5, r2
    4a82:	4688      	mov	r8, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    4a84:	4b33      	ldr	r3, [pc, #204]	; (4b54 <xQueueGenericSendFromISR+0xe8>)
    4a86:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    4a88:	f3ef 8711 	mrs	r7, BASEPRI
    4a8c:	f04f 0380 	mov.w	r3, #128	; 0x80
    4a90:	f383 8811 	msr	BASEPRI, r3
    4a94:	f3bf 8f6f 	isb	sy
    4a98:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    4a9c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    4a9e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    4aa0:	429a      	cmp	r2, r3
    4aa2:	d301      	bcc.n	4aa8 <xQueueGenericSendFromISR+0x3c>
    4aa4:	2e02      	cmp	r6, #2
    4aa6:	d148      	bne.n	4b3a <xQueueGenericSendFromISR+0xce>
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    4aa8:	4632      	mov	r2, r6
    4aaa:	4641      	mov	r1, r8
    4aac:	4620      	mov	r0, r4
    4aae:	4b2a      	ldr	r3, [pc, #168]	; (4b58 <xQueueGenericSendFromISR+0xec>)
    4ab0:	4798      	blx	r3
			if (pxQueue->xTxLock == queueUNLOCKED) {
    4ab2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4ab4:	f1b3 3fff 	cmp.w	r3, #4294967295
    4ab8:	d13a      	bne.n	4b30 <xQueueGenericSendFromISR+0xc4>
					if (pxQueue->pxQueueSetContainer != NULL) {
    4aba:	6d63      	ldr	r3, [r4, #84]	; 0x54
    4abc:	b36b      	cbz	r3, 4b1a <xQueueGenericSendFromISR+0xae>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
    4abe:	4631      	mov	r1, r6
    4ac0:	4620      	mov	r0, r4
    4ac2:	4b26      	ldr	r3, [pc, #152]	; (4b5c <xQueueGenericSendFromISR+0xf0>)
    4ac4:	4798      	blx	r3
    4ac6:	2801      	cmp	r0, #1
    4ac8:	d139      	bne.n	4b3e <xQueueGenericSendFromISR+0xd2>
							if (pxHigherPriorityTaskWoken != NULL) {
    4aca:	2d00      	cmp	r5, #0
    4acc:	d039      	beq.n	4b42 <xQueueGenericSendFromISR+0xd6>
								*pxHigherPriorityTaskWoken = pdTRUE;
    4ace:	6028      	str	r0, [r5, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    4ad0:	f387 8811 	msr	BASEPRI, r7
}
    4ad4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm volatile("	mov %0, %1												\n"
    4ad8:	f04f 0380 	mov.w	r3, #128	; 0x80
    4adc:	f383 8811 	msr	BASEPRI, r3
    4ae0:	f3bf 8f6f 	isb	sy
    4ae4:	f3bf 8f4f 	dsb	sy
    4ae8:	e7fe      	b.n	4ae8 <xQueueGenericSendFromISR+0x7c>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    4aea:	6c00      	ldr	r0, [r0, #64]	; 0x40
    4aec:	2800      	cmp	r0, #0
    4aee:	d0c4      	beq.n	4a7a <xQueueGenericSendFromISR+0xe>
    4af0:	f04f 0380 	mov.w	r3, #128	; 0x80
    4af4:	f383 8811 	msr	BASEPRI, r3
    4af8:	f3bf 8f6f 	isb	sy
    4afc:	f3bf 8f4f 	dsb	sy
    4b00:	e7fe      	b.n	4b00 <xQueueGenericSendFromISR+0x94>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    4b02:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    4b04:	2801      	cmp	r0, #1
    4b06:	d0ba      	beq.n	4a7e <xQueueGenericSendFromISR+0x12>
    4b08:	f04f 0380 	mov.w	r3, #128	; 0x80
    4b0c:	f383 8811 	msr	BASEPRI, r3
    4b10:	f3bf 8f6f 	isb	sy
    4b14:	f3bf 8f4f 	dsb	sy
    4b18:	e7fe      	b.n	4b18 <xQueueGenericSendFromISR+0xac>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    4b1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4b1c:	b19b      	cbz	r3, 4b46 <xQueueGenericSendFromISR+0xda>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    4b1e:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4b22:	4b0f      	ldr	r3, [pc, #60]	; (4b60 <xQueueGenericSendFromISR+0xf4>)
    4b24:	4798      	blx	r3
    4b26:	b180      	cbz	r0, 4b4a <xQueueGenericSendFromISR+0xde>
								if (pxHigherPriorityTaskWoken != NULL) {
    4b28:	b18d      	cbz	r5, 4b4e <xQueueGenericSendFromISR+0xe2>
									*pxHigherPriorityTaskWoken = pdTRUE;
    4b2a:	2001      	movs	r0, #1
    4b2c:	6028      	str	r0, [r5, #0]
    4b2e:	e7cf      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
				++(pxQueue->xTxLock);
    4b30:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4b32:	3301      	adds	r3, #1
    4b34:	64a3      	str	r3, [r4, #72]	; 0x48
			xReturn = pdPASS;
    4b36:	2001      	movs	r0, #1
    4b38:	e7ca      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
			xReturn = errQUEUE_FULL;
    4b3a:	2000      	movs	r0, #0
    4b3c:	e7c8      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
			xReturn = pdPASS;
    4b3e:	2001      	movs	r0, #1
    4b40:	e7c6      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
    4b42:	2001      	movs	r0, #1
    4b44:	e7c4      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
    4b46:	2001      	movs	r0, #1
    4b48:	e7c2      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
    4b4a:	2001      	movs	r0, #1
    4b4c:	e7c0      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
    4b4e:	2001      	movs	r0, #1
    4b50:	e7be      	b.n	4ad0 <xQueueGenericSendFromISR+0x64>
    4b52:	bf00      	nop
    4b54:	000043a1 	.word	0x000043a1
    4b58:	00004519 	.word	0x00004519
    4b5c:	000045a1 	.word	0x000045a1
    4b60:	000055f1 	.word	0x000055f1

00004b64 <xQueueGiveFromISR>:
	configASSERT(pxQueue);
    4b64:	b160      	cbz	r0, 4b80 <xQueueGiveFromISR+0x1c>
{
    4b66:	b570      	push	{r4, r5, r6, lr}
    4b68:	4604      	mov	r4, r0
	configASSERT(pxQueue->uxItemSize == 0);
    4b6a:	6c03      	ldr	r3, [r0, #64]	; 0x40
    4b6c:	b18b      	cbz	r3, 4b92 <xQueueGiveFromISR+0x2e>
    4b6e:	f04f 0380 	mov.w	r3, #128	; 0x80
    4b72:	f383 8811 	msr	BASEPRI, r3
    4b76:	f3bf 8f6f 	isb	sy
    4b7a:	f3bf 8f4f 	dsb	sy
    4b7e:	e7fe      	b.n	4b7e <xQueueGiveFromISR+0x1a>
    4b80:	f04f 0380 	mov.w	r3, #128	; 0x80
    4b84:	f383 8811 	msr	BASEPRI, r3
    4b88:	f3bf 8f6f 	isb	sy
    4b8c:	f3bf 8f4f 	dsb	sy
    4b90:	e7fe      	b.n	4b90 <xQueueGiveFromISR+0x2c>
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
    4b92:	6803      	ldr	r3, [r0, #0]
    4b94:	b323      	cbz	r3, 4be0 <xQueueGiveFromISR+0x7c>
    4b96:	460d      	mov	r5, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    4b98:	4b25      	ldr	r3, [pc, #148]	; (4c30 <xQueueGiveFromISR+0xcc>)
    4b9a:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    4b9c:	f3ef 8611 	mrs	r6, BASEPRI
    4ba0:	f04f 0380 	mov.w	r3, #128	; 0x80
    4ba4:	f383 8811 	msr	BASEPRI, r3
    4ba8:	f3bf 8f6f 	isb	sy
    4bac:	f3bf 8f4f 	dsb	sy
		if (pxQueue->uxMessagesWaiting < pxQueue->uxLength) {
    4bb0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    4bb2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    4bb4:	429a      	cmp	r2, r3
    4bb6:	d22f      	bcs.n	4c18 <xQueueGiveFromISR+0xb4>
			++(pxQueue->uxMessagesWaiting);
    4bb8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4bba:	3301      	adds	r3, #1
    4bbc:	63a3      	str	r3, [r4, #56]	; 0x38
			if (pxQueue->xTxLock == queueUNLOCKED) {
    4bbe:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4bc0:	f1b3 3fff 	cmp.w	r3, #4294967295
    4bc4:	d123      	bne.n	4c0e <xQueueGiveFromISR+0xaa>
					if (pxQueue->pxQueueSetContainer != NULL) {
    4bc6:	6d63      	ldr	r3, [r4, #84]	; 0x54
    4bc8:	b1b3      	cbz	r3, 4bf8 <xQueueGiveFromISR+0x94>
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
    4bca:	2100      	movs	r1, #0
    4bcc:	4620      	mov	r0, r4
    4bce:	4b19      	ldr	r3, [pc, #100]	; (4c34 <xQueueGiveFromISR+0xd0>)
    4bd0:	4798      	blx	r3
    4bd2:	2801      	cmp	r0, #1
    4bd4:	d122      	bne.n	4c1c <xQueueGiveFromISR+0xb8>
							if (pxHigherPriorityTaskWoken != NULL) {
    4bd6:	b31d      	cbz	r5, 4c20 <xQueueGiveFromISR+0xbc>
								*pxHigherPriorityTaskWoken = pdTRUE;
    4bd8:	6028      	str	r0, [r5, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    4bda:	f386 8811 	msr	BASEPRI, r6
}
    4bde:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
    4be0:	6843      	ldr	r3, [r0, #4]
    4be2:	2b00      	cmp	r3, #0
    4be4:	d0d7      	beq.n	4b96 <xQueueGiveFromISR+0x32>
	__asm volatile("	mov %0, %1												\n"
    4be6:	f04f 0380 	mov.w	r3, #128	; 0x80
    4bea:	f383 8811 	msr	BASEPRI, r3
    4bee:	f3bf 8f6f 	isb	sy
    4bf2:	f3bf 8f4f 	dsb	sy
    4bf6:	e7fe      	b.n	4bf6 <xQueueGiveFromISR+0x92>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    4bf8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4bfa:	b19b      	cbz	r3, 4c24 <xQueueGiveFromISR+0xc0>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    4bfc:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4c00:	4b0d      	ldr	r3, [pc, #52]	; (4c38 <xQueueGiveFromISR+0xd4>)
    4c02:	4798      	blx	r3
    4c04:	b180      	cbz	r0, 4c28 <xQueueGiveFromISR+0xc4>
								if (pxHigherPriorityTaskWoken != NULL) {
    4c06:	b18d      	cbz	r5, 4c2c <xQueueGiveFromISR+0xc8>
									*pxHigherPriorityTaskWoken = pdTRUE;
    4c08:	2001      	movs	r0, #1
    4c0a:	6028      	str	r0, [r5, #0]
    4c0c:	e7e5      	b.n	4bda <xQueueGiveFromISR+0x76>
				++(pxQueue->xTxLock);
    4c0e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4c10:	3301      	adds	r3, #1
    4c12:	64a3      	str	r3, [r4, #72]	; 0x48
			xReturn = pdPASS;
    4c14:	2001      	movs	r0, #1
    4c16:	e7e0      	b.n	4bda <xQueueGiveFromISR+0x76>
			xReturn = errQUEUE_FULL;
    4c18:	2000      	movs	r0, #0
    4c1a:	e7de      	b.n	4bda <xQueueGiveFromISR+0x76>
			xReturn = pdPASS;
    4c1c:	2001      	movs	r0, #1
    4c1e:	e7dc      	b.n	4bda <xQueueGiveFromISR+0x76>
    4c20:	2001      	movs	r0, #1
    4c22:	e7da      	b.n	4bda <xQueueGiveFromISR+0x76>
    4c24:	2001      	movs	r0, #1
    4c26:	e7d8      	b.n	4bda <xQueueGiveFromISR+0x76>
    4c28:	2001      	movs	r0, #1
    4c2a:	e7d6      	b.n	4bda <xQueueGiveFromISR+0x76>
    4c2c:	2001      	movs	r0, #1
    4c2e:	e7d4      	b.n	4bda <xQueueGiveFromISR+0x76>
    4c30:	000043a1 	.word	0x000043a1
    4c34:	000045a1 	.word	0x000045a1
    4c38:	000055f1 	.word	0x000055f1

00004c3c <xQueueGenericReceive>:
{
    4c3c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4c40:	b084      	sub	sp, #16
    4c42:	9201      	str	r2, [sp, #4]
	configASSERT(pxQueue);
    4c44:	b188      	cbz	r0, 4c6a <xQueueGenericReceive+0x2e>
    4c46:	4604      	mov	r4, r0
	configASSERT(!((pvBuffer == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    4c48:	b1c1      	cbz	r1, 4c7c <xQueueGenericReceive+0x40>
    4c4a:	4698      	mov	r8, r3
    4c4c:	460f      	mov	r7, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    4c4e:	4b5e      	ldr	r3, [pc, #376]	; (4dc8 <xQueueGenericReceive+0x18c>)
    4c50:	4798      	blx	r3
    4c52:	b9f8      	cbnz	r0, 4c94 <xQueueGenericReceive+0x58>
    4c54:	9b01      	ldr	r3, [sp, #4]
    4c56:	b323      	cbz	r3, 4ca2 <xQueueGenericReceive+0x66>
    4c58:	f04f 0380 	mov.w	r3, #128	; 0x80
    4c5c:	f383 8811 	msr	BASEPRI, r3
    4c60:	f3bf 8f6f 	isb	sy
    4c64:	f3bf 8f4f 	dsb	sy
    4c68:	e7fe      	b.n	4c68 <xQueueGenericReceive+0x2c>
    4c6a:	f04f 0380 	mov.w	r3, #128	; 0x80
    4c6e:	f383 8811 	msr	BASEPRI, r3
    4c72:	f3bf 8f6f 	isb	sy
    4c76:	f3bf 8f4f 	dsb	sy
    4c7a:	e7fe      	b.n	4c7a <xQueueGenericReceive+0x3e>
	configASSERT(!((pvBuffer == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    4c7c:	6c02      	ldr	r2, [r0, #64]	; 0x40
    4c7e:	2a00      	cmp	r2, #0
    4c80:	d0e3      	beq.n	4c4a <xQueueGenericReceive+0xe>
    4c82:	f04f 0380 	mov.w	r3, #128	; 0x80
    4c86:	f383 8811 	msr	BASEPRI, r3
    4c8a:	f3bf 8f6f 	isb	sy
    4c8e:	f3bf 8f4f 	dsb	sy
    4c92:	e7fe      	b.n	4c92 <xQueueGenericReceive+0x56>
    4c94:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    4c96:	4d4d      	ldr	r5, [pc, #308]	; (4dcc <xQueueGenericReceive+0x190>)
					vTaskSetTimeOutState(&xTimeOut);
    4c98:	f8df a160 	ldr.w	sl, [pc, #352]	; 4dfc <xQueueGenericReceive+0x1c0>
					portYIELD_WITHIN_API();
    4c9c:	f8df 913c 	ldr.w	r9, [pc, #316]	; 4ddc <xQueueGenericReceive+0x1a0>
    4ca0:	e04b      	b.n	4d3a <xQueueGenericReceive+0xfe>
    4ca2:	2600      	movs	r6, #0
    4ca4:	e7f7      	b.n	4c96 <xQueueGenericReceive+0x5a>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    4ca6:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    4ca8:	4639      	mov	r1, r7
    4caa:	4620      	mov	r0, r4
    4cac:	4b48      	ldr	r3, [pc, #288]	; (4dd0 <xQueueGenericReceive+0x194>)
    4cae:	4798      	blx	r3
				if (xJustPeeking == pdFALSE) {
    4cb0:	f1b8 0f00 	cmp.w	r8, #0
    4cb4:	d11d      	bne.n	4cf2 <xQueueGenericReceive+0xb6>
					--(pxQueue->uxMessagesWaiting);
    4cb6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4cb8:	3b01      	subs	r3, #1
    4cba:	63a3      	str	r3, [r4, #56]	; 0x38
						if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    4cbc:	6823      	ldr	r3, [r4, #0]
    4cbe:	b913      	cbnz	r3, 4cc6 <xQueueGenericReceive+0x8a>
							    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
    4cc0:	4b44      	ldr	r3, [pc, #272]	; (4dd4 <xQueueGenericReceive+0x198>)
    4cc2:	4798      	blx	r3
    4cc4:	6060      	str	r0, [r4, #4]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    4cc6:	6923      	ldr	r3, [r4, #16]
    4cc8:	b16b      	cbz	r3, 4ce6 <xQueueGenericReceive+0xaa>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
    4cca:	f104 0010 	add.w	r0, r4, #16
    4cce:	4b42      	ldr	r3, [pc, #264]	; (4dd8 <xQueueGenericReceive+0x19c>)
    4cd0:	4798      	blx	r3
    4cd2:	2801      	cmp	r0, #1
    4cd4:	d107      	bne.n	4ce6 <xQueueGenericReceive+0xaa>
							queueYIELD_IF_USING_PREEMPTION();
    4cd6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    4cda:	4b40      	ldr	r3, [pc, #256]	; (4ddc <xQueueGenericReceive+0x1a0>)
    4cdc:	601a      	str	r2, [r3, #0]
    4cde:	f3bf 8f4f 	dsb	sy
    4ce2:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    4ce6:	4b3e      	ldr	r3, [pc, #248]	; (4de0 <xQueueGenericReceive+0x1a4>)
    4ce8:	4798      	blx	r3
				return pdPASS;
    4cea:	2001      	movs	r0, #1
}
    4cec:	b004      	add	sp, #16
    4cee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    4cf2:	60e5      	str	r5, [r4, #12]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    4cf4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4cf6:	2b00      	cmp	r3, #0
    4cf8:	d0f5      	beq.n	4ce6 <xQueueGenericReceive+0xaa>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    4cfa:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4cfe:	4b36      	ldr	r3, [pc, #216]	; (4dd8 <xQueueGenericReceive+0x19c>)
    4d00:	4798      	blx	r3
    4d02:	2800      	cmp	r0, #0
    4d04:	d0ef      	beq.n	4ce6 <xQueueGenericReceive+0xaa>
							queueYIELD_IF_USING_PREEMPTION();
    4d06:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    4d0a:	4b34      	ldr	r3, [pc, #208]	; (4ddc <xQueueGenericReceive+0x1a0>)
    4d0c:	601a      	str	r2, [r3, #0]
    4d0e:	f3bf 8f4f 	dsb	sy
    4d12:	f3bf 8f6f 	isb	sy
    4d16:	e7e6      	b.n	4ce6 <xQueueGenericReceive+0xaa>
					taskEXIT_CRITICAL();
    4d18:	4b31      	ldr	r3, [pc, #196]	; (4de0 <xQueueGenericReceive+0x1a4>)
    4d1a:	4798      	blx	r3
					return errQUEUE_EMPTY;
    4d1c:	2000      	movs	r0, #0
    4d1e:	e7e5      	b.n	4cec <xQueueGenericReceive+0xb0>
						taskENTER_CRITICAL();
    4d20:	47a8      	blx	r5
							vTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
    4d22:	6860      	ldr	r0, [r4, #4]
    4d24:	4b2f      	ldr	r3, [pc, #188]	; (4de4 <xQueueGenericReceive+0x1a8>)
    4d26:	4798      	blx	r3
						taskEXIT_CRITICAL();
    4d28:	4b2d      	ldr	r3, [pc, #180]	; (4de0 <xQueueGenericReceive+0x1a4>)
    4d2a:	4798      	blx	r3
    4d2c:	e030      	b.n	4d90 <xQueueGenericReceive+0x154>
				prvUnlockQueue(pxQueue);
    4d2e:	4620      	mov	r0, r4
    4d30:	4b2d      	ldr	r3, [pc, #180]	; (4de8 <xQueueGenericReceive+0x1ac>)
    4d32:	4798      	blx	r3
				(void)xTaskResumeAll();
    4d34:	4b2d      	ldr	r3, [pc, #180]	; (4dec <xQueueGenericReceive+0x1b0>)
    4d36:	4798      	blx	r3
    4d38:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    4d3a:	47a8      	blx	r5
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
    4d3c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4d3e:	2b00      	cmp	r3, #0
    4d40:	d1b1      	bne.n	4ca6 <xQueueGenericReceive+0x6a>
				if (xTicksToWait == (TickType_t)0) {
    4d42:	9b01      	ldr	r3, [sp, #4]
    4d44:	2b00      	cmp	r3, #0
    4d46:	d0e7      	beq.n	4d18 <xQueueGenericReceive+0xdc>
				} else if (xEntryTimeSet == pdFALSE) {
    4d48:	b90e      	cbnz	r6, 4d4e <xQueueGenericReceive+0x112>
					vTaskSetTimeOutState(&xTimeOut);
    4d4a:	a802      	add	r0, sp, #8
    4d4c:	47d0      	blx	sl
		taskEXIT_CRITICAL();
    4d4e:	4b24      	ldr	r3, [pc, #144]	; (4de0 <xQueueGenericReceive+0x1a4>)
    4d50:	4798      	blx	r3
		vTaskSuspendAll();
    4d52:	4b27      	ldr	r3, [pc, #156]	; (4df0 <xQueueGenericReceive+0x1b4>)
    4d54:	4798      	blx	r3
		prvLockQueue(pxQueue);
    4d56:	47a8      	blx	r5
    4d58:	6c63      	ldr	r3, [r4, #68]	; 0x44
    4d5a:	f1b3 3fff 	cmp.w	r3, #4294967295
    4d5e:	bf04      	itt	eq
    4d60:	2300      	moveq	r3, #0
    4d62:	6463      	streq	r3, [r4, #68]	; 0x44
    4d64:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4d66:	f1b3 3fff 	cmp.w	r3, #4294967295
    4d6a:	bf04      	itt	eq
    4d6c:	2300      	moveq	r3, #0
    4d6e:	64a3      	streq	r3, [r4, #72]	; 0x48
    4d70:	4b1b      	ldr	r3, [pc, #108]	; (4de0 <xQueueGenericReceive+0x1a4>)
    4d72:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    4d74:	a901      	add	r1, sp, #4
    4d76:	a802      	add	r0, sp, #8
    4d78:	4b1e      	ldr	r3, [pc, #120]	; (4df4 <xQueueGenericReceive+0x1b8>)
    4d7a:	4798      	blx	r3
    4d7c:	b9e8      	cbnz	r0, 4dba <xQueueGenericReceive+0x17e>
	taskENTER_CRITICAL();
    4d7e:	47a8      	blx	r5
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    4d80:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
    4d82:	4b17      	ldr	r3, [pc, #92]	; (4de0 <xQueueGenericReceive+0x1a4>)
    4d84:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    4d86:	2e00      	cmp	r6, #0
    4d88:	d1d1      	bne.n	4d2e <xQueueGenericReceive+0xf2>
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    4d8a:	6823      	ldr	r3, [r4, #0]
    4d8c:	2b00      	cmp	r3, #0
    4d8e:	d0c7      	beq.n	4d20 <xQueueGenericReceive+0xe4>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    4d90:	9901      	ldr	r1, [sp, #4]
    4d92:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4d96:	4b18      	ldr	r3, [pc, #96]	; (4df8 <xQueueGenericReceive+0x1bc>)
    4d98:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    4d9a:	4620      	mov	r0, r4
    4d9c:	4b12      	ldr	r3, [pc, #72]	; (4de8 <xQueueGenericReceive+0x1ac>)
    4d9e:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    4da0:	4b12      	ldr	r3, [pc, #72]	; (4dec <xQueueGenericReceive+0x1b0>)
    4da2:	4798      	blx	r3
    4da4:	2800      	cmp	r0, #0
    4da6:	d1c7      	bne.n	4d38 <xQueueGenericReceive+0xfc>
					portYIELD_WITHIN_API();
    4da8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    4dac:	f8c9 3000 	str.w	r3, [r9]
    4db0:	f3bf 8f4f 	dsb	sy
    4db4:	f3bf 8f6f 	isb	sy
    4db8:	e7be      	b.n	4d38 <xQueueGenericReceive+0xfc>
			prvUnlockQueue(pxQueue);
    4dba:	4620      	mov	r0, r4
    4dbc:	4b0a      	ldr	r3, [pc, #40]	; (4de8 <xQueueGenericReceive+0x1ac>)
    4dbe:	4798      	blx	r3
			(void)xTaskResumeAll();
    4dc0:	4b0a      	ldr	r3, [pc, #40]	; (4dec <xQueueGenericReceive+0x1b0>)
    4dc2:	4798      	blx	r3
			return errQUEUE_EMPTY;
    4dc4:	2000      	movs	r0, #0
    4dc6:	e791      	b.n	4cec <xQueueGenericReceive+0xb0>
    4dc8:	00005745 	.word	0x00005745
    4dcc:	00004181 	.word	0x00004181
    4dd0:	00004621 	.word	0x00004621
    4dd4:	00005881 	.word	0x00005881
    4dd8:	000055f1 	.word	0x000055f1
    4ddc:	e000ed04 	.word	0xe000ed04
    4de0:	000041c5 	.word	0x000041c5
    4de4:	00005765 	.word	0x00005765
    4de8:	00004649 	.word	0x00004649
    4dec:	00005285 	.word	0x00005285
    4df0:	00005159 	.word	0x00005159
    4df4:	000056a9 	.word	0x000056a9
    4df8:	0000553d 	.word	0x0000553d
    4dfc:	00005681 	.word	0x00005681

00004e00 <vQueueDelete>:
{
    4e00:	b508      	push	{r3, lr}
	configASSERT(pxQueue);
    4e02:	b940      	cbnz	r0, 4e16 <vQueueDelete+0x16>
    4e04:	f04f 0380 	mov.w	r3, #128	; 0x80
    4e08:	f383 8811 	msr	BASEPRI, r3
    4e0c:	f3bf 8f6f 	isb	sy
    4e10:	f3bf 8f4f 	dsb	sy
    4e14:	e7fe      	b.n	4e14 <vQueueDelete+0x14>
	vPortFree(pxQueue);
    4e16:	4b01      	ldr	r3, [pc, #4]	; (4e1c <vQueueDelete+0x1c>)
    4e18:	4798      	blx	r3
    4e1a:	bd08      	pop	{r3, pc}
    4e1c:	000044cd 	.word	0x000044cd

00004e20 <vQueueWaitForMessageRestricted>:
{
    4e20:	b570      	push	{r4, r5, r6, lr}
    4e22:	4604      	mov	r4, r0
    4e24:	460d      	mov	r5, r1
    4e26:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    4e28:	4b0e      	ldr	r3, [pc, #56]	; (4e64 <vQueueWaitForMessageRestricted+0x44>)
    4e2a:	4798      	blx	r3
    4e2c:	6c63      	ldr	r3, [r4, #68]	; 0x44
    4e2e:	f1b3 3fff 	cmp.w	r3, #4294967295
    4e32:	bf04      	itt	eq
    4e34:	2300      	moveq	r3, #0
    4e36:	6463      	streq	r3, [r4, #68]	; 0x44
    4e38:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4e3a:	f1b3 3fff 	cmp.w	r3, #4294967295
    4e3e:	bf04      	itt	eq
    4e40:	2300      	moveq	r3, #0
    4e42:	64a3      	streq	r3, [r4, #72]	; 0x48
    4e44:	4b08      	ldr	r3, [pc, #32]	; (4e68 <vQueueWaitForMessageRestricted+0x48>)
    4e46:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    4e48:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4e4a:	b11b      	cbz	r3, 4e54 <vQueueWaitForMessageRestricted+0x34>
	prvUnlockQueue(pxQueue);
    4e4c:	4620      	mov	r0, r4
    4e4e:	4b07      	ldr	r3, [pc, #28]	; (4e6c <vQueueWaitForMessageRestricted+0x4c>)
    4e50:	4798      	blx	r3
    4e52:	bd70      	pop	{r4, r5, r6, pc}
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    4e54:	4632      	mov	r2, r6
    4e56:	4629      	mov	r1, r5
    4e58:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4e5c:	4b04      	ldr	r3, [pc, #16]	; (4e70 <vQueueWaitForMessageRestricted+0x50>)
    4e5e:	4798      	blx	r3
    4e60:	e7f4      	b.n	4e4c <vQueueWaitForMessageRestricted+0x2c>
    4e62:	bf00      	nop
    4e64:	00004181 	.word	0x00004181
    4e68:	000041c5 	.word	0x000041c5
    4e6c:	00004649 	.word	0x00004649
    4e70:	00005599 	.word	0x00005599

00004e74 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    4e74:	4b07      	ldr	r3, [pc, #28]	; (4e94 <prvResetNextTaskUnblockTime+0x20>)
    4e76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4e78:	681b      	ldr	r3, [r3, #0]
    4e7a:	b133      	cbz	r3, 4e8a <prvResetNextTaskUnblockTime+0x16>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    4e7c:	4b05      	ldr	r3, [pc, #20]	; (4e94 <prvResetNextTaskUnblockTime+0x20>)
    4e7e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    4e80:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    4e82:	68d2      	ldr	r2, [r2, #12]
    4e84:	6852      	ldr	r2, [r2, #4]
    4e86:	62da      	str	r2, [r3, #44]	; 0x2c
    4e88:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    4e8a:	f04f 32ff 	mov.w	r2, #4294967295
    4e8e:	4b01      	ldr	r3, [pc, #4]	; (4e94 <prvResetNextTaskUnblockTime+0x20>)
    4e90:	62da      	str	r2, [r3, #44]	; 0x2c
    4e92:	4770      	bx	lr
    4e94:	2000e3ac 	.word	0x2000e3ac

00004e98 <prvAddCurrentTaskToDelayedList>:
{
    4e98:	b538      	push	{r3, r4, r5, lr}
	listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xGenericListItem), xTimeToWake);
    4e9a:	4b0d      	ldr	r3, [pc, #52]	; (4ed0 <prvAddCurrentTaskToDelayedList+0x38>)
    4e9c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    4e9e:	6050      	str	r0, [r2, #4]
	if (xTimeToWake < xTickCount) {
    4ea0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    4ea2:	4298      	cmp	r0, r3
    4ea4:	d30c      	bcc.n	4ec0 <prvAddCurrentTaskToDelayedList+0x28>
    4ea6:	4604      	mov	r4, r0
		vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    4ea8:	4d09      	ldr	r5, [pc, #36]	; (4ed0 <prvAddCurrentTaskToDelayedList+0x38>)
    4eaa:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    4eac:	6b29      	ldr	r1, [r5, #48]	; 0x30
    4eae:	3104      	adds	r1, #4
    4eb0:	4b08      	ldr	r3, [pc, #32]	; (4ed4 <prvAddCurrentTaskToDelayedList+0x3c>)
    4eb2:	4798      	blx	r3
		if (xTimeToWake < xNextTaskUnblockTime) {
    4eb4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    4eb6:	429c      	cmp	r4, r3
			xNextTaskUnblockTime = xTimeToWake;
    4eb8:	bf3c      	itt	cc
    4eba:	462b      	movcc	r3, r5
    4ebc:	62dc      	strcc	r4, [r3, #44]	; 0x2c
    4ebe:	bd38      	pop	{r3, r4, r5, pc}
		vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    4ec0:	4b03      	ldr	r3, [pc, #12]	; (4ed0 <prvAddCurrentTaskToDelayedList+0x38>)
    4ec2:	6b98      	ldr	r0, [r3, #56]	; 0x38
    4ec4:	6b19      	ldr	r1, [r3, #48]	; 0x30
    4ec6:	3104      	adds	r1, #4
    4ec8:	4b02      	ldr	r3, [pc, #8]	; (4ed4 <prvAddCurrentTaskToDelayedList+0x3c>)
    4eca:	4798      	blx	r3
    4ecc:	bd38      	pop	{r3, r4, r5, pc}
    4ece:	bf00      	nop
    4ed0:	2000e3ac 	.word	0x2000e3ac
    4ed4:	00004079 	.word	0x00004079

00004ed8 <xTaskGenericCreate>:
{
    4ed8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4edc:	b083      	sub	sp, #12
    4ede:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    4ee0:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    4ee4:	9c0e      	ldr	r4, [sp, #56]	; 0x38
	configASSERT(pxTaskCode);
    4ee6:	b150      	cbz	r0, 4efe <xTaskGenericCreate+0x26>
	configASSERT(((uxPriority & (UBaseType_t)(~portPRIVILEGE_BIT)) < (UBaseType_t)configMAX_PRIORITIES));
    4ee8:	2d05      	cmp	r5, #5
    4eea:	d911      	bls.n	4f10 <xTaskGenericCreate+0x38>
    4eec:	f04f 0380 	mov.w	r3, #128	; 0x80
    4ef0:	f383 8811 	msr	BASEPRI, r3
    4ef4:	f3bf 8f6f 	isb	sy
    4ef8:	f3bf 8f4f 	dsb	sy
    4efc:	e7fe      	b.n	4efc <xTaskGenericCreate+0x24>
    4efe:	f04f 0380 	mov.w	r3, #128	; 0x80
    4f02:	f383 8811 	msr	BASEPRI, r3
    4f06:	f3bf 8f6f 	isb	sy
    4f0a:	f3bf 8f4f 	dsb	sy
    4f0e:	e7fe      	b.n	4f0e <xTaskGenericCreate+0x36>
    4f10:	9001      	str	r0, [sp, #4]
    4f12:	4698      	mov	r8, r3
    4f14:	4616      	mov	r6, r2
    4f16:	460f      	mov	r7, r1
		pxStack = (StackType_t *)pvPortMallocAligned(
    4f18:	46a1      	mov	r9, r4
    4f1a:	b93c      	cbnz	r4, 4f2c <xTaskGenericCreate+0x54>
    4f1c:	0090      	lsls	r0, r2, #2
    4f1e:	4b64      	ldr	r3, [pc, #400]	; (50b0 <xTaskGenericCreate+0x1d8>)
    4f20:	4798      	blx	r3
		if (pxStack != NULL) {
    4f22:	4681      	mov	r9, r0
    4f24:	b910      	cbnz	r0, 4f2c <xTaskGenericCreate+0x54>
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4f26:	f04f 30ff 	mov.w	r0, #4294967295
    4f2a:	e099      	b.n	5060 <xTaskGenericCreate+0x188>
			pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));
    4f2c:	2054      	movs	r0, #84	; 0x54
    4f2e:	4b60      	ldr	r3, [pc, #384]	; (50b0 <xTaskGenericCreate+0x1d8>)
    4f30:	4798      	blx	r3
			if (pxNewTCB != NULL) {
    4f32:	4604      	mov	r4, r0
    4f34:	2800      	cmp	r0, #0
    4f36:	f000 8096 	beq.w	5066 <xTaskGenericCreate+0x18e>
				pxNewTCB->pxStack = pxStack;
    4f3a:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
			(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
    4f3e:	00b2      	lsls	r2, r6, #2
    4f40:	21a5      	movs	r1, #165	; 0xa5
    4f42:	4648      	mov	r0, r9
    4f44:	4b5b      	ldr	r3, [pc, #364]	; (50b4 <xTaskGenericCreate+0x1dc>)
    4f46:	4798      	blx	r3
			pxTopOfStack = pxNewTCB->pxStack + (usStackDepth - (uint16_t)1);
    4f48:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
    4f4c:	3e01      	subs	r6, #1
    4f4e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    4f50:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			                      & (~((portPOINTER_SIZE_TYPE)
    4f54:	f026 0607 	bic.w	r6, r6, #7
		pxTCB->pcTaskName[x] = pcName[x];
    4f58:	783b      	ldrb	r3, [r7, #0]
    4f5a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if (pcName[x] == 0x00) {
    4f5e:	783b      	ldrb	r3, [r7, #0]
    4f60:	2b00      	cmp	r3, #0
    4f62:	f040 8084 	bne.w	506e <xTaskGenericCreate+0x196>
	pxTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    4f66:	2700      	movs	r7, #0
    4f68:	f884 703b 	strb.w	r7, [r4, #59]	; 0x3b
	pxTCB->uxPriority = uxPriority;
    4f6c:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxTCB->uxBasePriority = uxPriority;
    4f6e:	6465      	str	r5, [r4, #68]	; 0x44
		pxTCB->uxMutexesHeld  = 0;
    4f70:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    4f72:	f104 0904 	add.w	r9, r4, #4
    4f76:	4648      	mov	r0, r9
    4f78:	f8df b15c 	ldr.w	fp, [pc, #348]	; 50d8 <xTaskGenericCreate+0x200>
    4f7c:	47d8      	blx	fp
	vListInitialiseItem(&(pxTCB->xEventListItem));
    4f7e:	f104 0018 	add.w	r0, r4, #24
    4f82:	47d8      	blx	fp
	listSET_LIST_ITEM_OWNER(&(pxTCB->xGenericListItem), pxTCB);
    4f84:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
    4f86:	f1c5 0306 	rsb	r3, r5, #6
    4f8a:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxTCB->xEventListItem), pxTCB);
    4f8c:	6264      	str	r4, [r4, #36]	; 0x24
		pxTCB->ulNotifiedValue = 0;
    4f8e:	64e7      	str	r7, [r4, #76]	; 0x4c
		pxTCB->eNotifyState    = eNotWaitingNotification;
    4f90:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    4f94:	4642      	mov	r2, r8
    4f96:	9901      	ldr	r1, [sp, #4]
    4f98:	4630      	mov	r0, r6
    4f9a:	4b47      	ldr	r3, [pc, #284]	; (50b8 <xTaskGenericCreate+0x1e0>)
    4f9c:	4798      	blx	r3
    4f9e:	6020      	str	r0, [r4, #0]
		if ((void *)pxCreatedTask != NULL) {
    4fa0:	f1ba 0f00 	cmp.w	sl, #0
    4fa4:	d001      	beq.n	4faa <xTaskGenericCreate+0xd2>
			*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    4fa6:	f8ca 4000 	str.w	r4, [sl]
		taskENTER_CRITICAL();
    4faa:	4b44      	ldr	r3, [pc, #272]	; (50bc <xTaskGenericCreate+0x1e4>)
    4fac:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
    4fae:	4b44      	ldr	r3, [pc, #272]	; (50c0 <xTaskGenericCreate+0x1e8>)
    4fb0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    4fb2:	3201      	adds	r2, #1
    4fb4:	63da      	str	r2, [r3, #60]	; 0x3c
			if (pxCurrentTCB == NULL) {
    4fb6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4fb8:	2b00      	cmp	r3, #0
    4fba:	d168      	bne.n	508e <xTaskGenericCreate+0x1b6>
				pxCurrentTCB = pxNewTCB;
    4fbc:	4b40      	ldr	r3, [pc, #256]	; (50c0 <xTaskGenericCreate+0x1e8>)
    4fbe:	631c      	str	r4, [r3, #48]	; 0x30
				if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    4fc0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4fc2:	2b01      	cmp	r3, #1
    4fc4:	d120      	bne.n	5008 <xTaskGenericCreate+0x130>
    4fc6:	4e3e      	ldr	r6, [pc, #248]	; (50c0 <xTaskGenericCreate+0x1e8>)
    4fc8:	f106 0740 	add.w	r7, r6, #64	; 0x40
    4fcc:	36b8      	adds	r6, #184	; 0xb8
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    4fce:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 50c4 <xTaskGenericCreate+0x1ec>
    4fd2:	4638      	mov	r0, r7
    4fd4:	47c0      	blx	r8
    4fd6:	3714      	adds	r7, #20
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    4fd8:	42b7      	cmp	r7, r6
    4fda:	d1fa      	bne.n	4fd2 <xTaskGenericCreate+0xfa>
	vListInitialise(&xDelayedTaskList1);
    4fdc:	4e38      	ldr	r6, [pc, #224]	; (50c0 <xTaskGenericCreate+0x1e8>)
    4fde:	f106 0ab8 	add.w	sl, r6, #184	; 0xb8
    4fe2:	4650      	mov	r0, sl
    4fe4:	4f37      	ldr	r7, [pc, #220]	; (50c4 <xTaskGenericCreate+0x1ec>)
    4fe6:	47b8      	blx	r7
	vListInitialise(&xDelayedTaskList2);
    4fe8:	f106 08cc 	add.w	r8, r6, #204	; 0xcc
    4fec:	4640      	mov	r0, r8
    4fee:	47b8      	blx	r7
	vListInitialise(&xPendingReadyList);
    4ff0:	f106 0014 	add.w	r0, r6, #20
    4ff4:	47b8      	blx	r7
		vListInitialise(&xTasksWaitingTermination);
    4ff6:	f106 00e0 	add.w	r0, r6, #224	; 0xe0
    4ffa:	47b8      	blx	r7
		vListInitialise(&xSuspendedTaskList);
    4ffc:	4630      	mov	r0, r6
    4ffe:	47b8      	blx	r7
	pxDelayedTaskList         = &xDelayedTaskList1;
    5000:	f8c6 a028 	str.w	sl, [r6, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5004:	f8c6 8038 	str.w	r8, [r6, #56]	; 0x38
			uxTaskNumber++;
    5008:	4a2d      	ldr	r2, [pc, #180]	; (50c0 <xTaskGenericCreate+0x1e8>)
    500a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	; 0xf8
    500e:	3301      	adds	r3, #1
    5010:	f8c2 30f8 	str.w	r3, [r2, #248]	; 0xf8
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    5014:	63e3      	str	r3, [r4, #60]	; 0x3c
			prvAddTaskToReadyList(pxNewTCB);
    5016:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5018:	f8d2 20fc 	ldr.w	r2, [r2, #252]	; 0xfc
    501c:	4293      	cmp	r3, r2
    501e:	bf84      	itt	hi
    5020:	4a27      	ldrhi	r2, [pc, #156]	; (50c0 <xTaskGenericCreate+0x1e8>)
    5022:	f8c2 30fc 	strhi.w	r3, [r2, #252]	; 0xfc
    5026:	4c26      	ldr	r4, [pc, #152]	; (50c0 <xTaskGenericCreate+0x1e8>)
    5028:	f104 0040 	add.w	r0, r4, #64	; 0x40
    502c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    5030:	4649      	mov	r1, r9
    5032:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    5036:	4b24      	ldr	r3, [pc, #144]	; (50c8 <xTaskGenericCreate+0x1f0>)
    5038:	4798      	blx	r3
		taskEXIT_CRITICAL();
    503a:	4b24      	ldr	r3, [pc, #144]	; (50cc <xTaskGenericCreate+0x1f4>)
    503c:	4798      	blx	r3
		if (xSchedulerRunning != pdFALSE) {
    503e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    5042:	2b00      	cmp	r3, #0
    5044:	d030      	beq.n	50a8 <xTaskGenericCreate+0x1d0>
			if (pxCurrentTCB->uxPriority < uxPriority) {
    5046:	6b23      	ldr	r3, [r4, #48]	; 0x30
    5048:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    504a:	429d      	cmp	r5, r3
    504c:	d92e      	bls.n	50ac <xTaskGenericCreate+0x1d4>
				taskYIELD_IF_USING_PREEMPTION();
    504e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    5052:	4b1f      	ldr	r3, [pc, #124]	; (50d0 <xTaskGenericCreate+0x1f8>)
    5054:	601a      	str	r2, [r3, #0]
    5056:	f3bf 8f4f 	dsb	sy
    505a:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    505e:	2001      	movs	r0, #1
}
    5060:	b003      	add	sp, #12
    5062:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				vPortFree(pxStack);
    5066:	4648      	mov	r0, r9
    5068:	4b1a      	ldr	r3, [pc, #104]	; (50d4 <xTaskGenericCreate+0x1fc>)
    506a:	4798      	blx	r3
    506c:	e75b      	b.n	4f26 <xTaskGenericCreate+0x4e>
    506e:	463b      	mov	r3, r7
    5070:	f104 0235 	add.w	r2, r4, #53	; 0x35
    5074:	3707      	adds	r7, #7
    5076:	e002      	b.n	507e <xTaskGenericCreate+0x1a6>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    5078:	42bb      	cmp	r3, r7
    507a:	f43f af74 	beq.w	4f66 <xTaskGenericCreate+0x8e>
		pxTCB->pcTaskName[x] = pcName[x];
    507e:	7859      	ldrb	r1, [r3, #1]
    5080:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
    5084:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    5088:	2900      	cmp	r1, #0
    508a:	d1f5      	bne.n	5078 <xTaskGenericCreate+0x1a0>
    508c:	e76b      	b.n	4f66 <xTaskGenericCreate+0x8e>
				if (xSchedulerRunning == pdFALSE) {
    508e:	4b0c      	ldr	r3, [pc, #48]	; (50c0 <xTaskGenericCreate+0x1e8>)
    5090:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
    5094:	2b00      	cmp	r3, #0
    5096:	d1b7      	bne.n	5008 <xTaskGenericCreate+0x130>
					if (pxCurrentTCB->uxPriority <= uxPriority) {
    5098:	4b09      	ldr	r3, [pc, #36]	; (50c0 <xTaskGenericCreate+0x1e8>)
    509a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    509c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    509e:	429d      	cmp	r5, r3
						pxCurrentTCB = pxNewTCB;
    50a0:	bf24      	itt	cs
    50a2:	4b07      	ldrcs	r3, [pc, #28]	; (50c0 <xTaskGenericCreate+0x1e8>)
    50a4:	631c      	strcs	r4, [r3, #48]	; 0x30
    50a6:	e7af      	b.n	5008 <xTaskGenericCreate+0x130>
			xReturn = pdPASS;
    50a8:	2001      	movs	r0, #1
    50aa:	e7d9      	b.n	5060 <xTaskGenericCreate+0x188>
    50ac:	2001      	movs	r0, #1
	return xReturn;
    50ae:	e7d7      	b.n	5060 <xTaskGenericCreate+0x188>
    50b0:	000043f9 	.word	0x000043f9
    50b4:	00005cdb 	.word	0x00005cdb
    50b8:	00004139 	.word	0x00004139
    50bc:	00004181 	.word	0x00004181
    50c0:	2000e3ac 	.word	0x2000e3ac
    50c4:	00004045 	.word	0x00004045
    50c8:	00004061 	.word	0x00004061
    50cc:	000041c5 	.word	0x000041c5
    50d0:	e000ed04 	.word	0xe000ed04
    50d4:	000044cd 	.word	0x000044cd
    50d8:	0000405b 	.word	0x0000405b

000050dc <vTaskStartScheduler>:
{
    50dc:	b510      	push	{r4, lr}
    50de:	b084      	sub	sp, #16
		xReturn = xTaskCreate(prvIdleTask,
    50e0:	2300      	movs	r3, #0
    50e2:	9303      	str	r3, [sp, #12]
    50e4:	9302      	str	r3, [sp, #8]
    50e6:	9301      	str	r3, [sp, #4]
    50e8:	9300      	str	r3, [sp, #0]
    50ea:	2240      	movs	r2, #64	; 0x40
    50ec:	4914      	ldr	r1, [pc, #80]	; (5140 <vTaskStartScheduler+0x64>)
    50ee:	4815      	ldr	r0, [pc, #84]	; (5144 <vTaskStartScheduler+0x68>)
    50f0:	4c15      	ldr	r4, [pc, #84]	; (5148 <vTaskStartScheduler+0x6c>)
    50f2:	47a0      	blx	r4
		if (xReturn == pdPASS) {
    50f4:	2801      	cmp	r0, #1
    50f6:	d009      	beq.n	510c <vTaskStartScheduler+0x30>
		configASSERT(xReturn);
    50f8:	b9f8      	cbnz	r0, 513a <vTaskStartScheduler+0x5e>
    50fa:	f04f 0380 	mov.w	r3, #128	; 0x80
    50fe:	f383 8811 	msr	BASEPRI, r3
    5102:	f3bf 8f6f 	isb	sy
    5106:	f3bf 8f4f 	dsb	sy
    510a:	e7fe      	b.n	510a <vTaskStartScheduler+0x2e>
			xReturn = xTimerCreateTimerTask();
    510c:	4b0f      	ldr	r3, [pc, #60]	; (514c <vTaskStartScheduler+0x70>)
    510e:	4798      	blx	r3
	if (xReturn == pdPASS) {
    5110:	2801      	cmp	r0, #1
    5112:	d1f1      	bne.n	50f8 <vTaskStartScheduler+0x1c>
    5114:	f04f 0380 	mov.w	r3, #128	; 0x80
    5118:	f383 8811 	msr	BASEPRI, r3
    511c:	f3bf 8f6f 	isb	sy
    5120:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    5124:	4b0a      	ldr	r3, [pc, #40]	; (5150 <vTaskStartScheduler+0x74>)
    5126:	f04f 32ff 	mov.w	r2, #4294967295
    512a:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning    = pdTRUE;
    512c:	2201      	movs	r2, #1
    512e:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
		xTickCount           = (TickType_t)0U;
    5132:	2200      	movs	r2, #0
    5134:	635a      	str	r2, [r3, #52]	; 0x34
		if (xPortStartScheduler() != pdFALSE) {
    5136:	4b07      	ldr	r3, [pc, #28]	; (5154 <vTaskStartScheduler+0x78>)
    5138:	4798      	blx	r3
}
    513a:	b004      	add	sp, #16
    513c:	bd10      	pop	{r4, pc}
    513e:	bf00      	nop
    5140:	00007180 	.word	0x00007180
    5144:	000053fd 	.word	0x000053fd
    5148:	00004ed9 	.word	0x00004ed9
    514c:	00005949 	.word	0x00005949
    5150:	2000e3ac 	.word	0x2000e3ac
    5154:	0000429d 	.word	0x0000429d

00005158 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    5158:	4a03      	ldr	r2, [pc, #12]	; (5168 <vTaskSuspendAll+0x10>)
    515a:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    515e:	3301      	adds	r3, #1
    5160:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
    5164:	4770      	bx	lr
    5166:	bf00      	nop
    5168:	2000e3ac 	.word	0x2000e3ac

0000516c <xTaskGetTickCount>:
		xTicks = xTickCount;
    516c:	4b01      	ldr	r3, [pc, #4]	; (5174 <xTaskGetTickCount+0x8>)
    516e:	6b58      	ldr	r0, [r3, #52]	; 0x34
}
    5170:	4770      	bx	lr
    5172:	bf00      	nop
    5174:	2000e3ac 	.word	0x2000e3ac

00005178 <xTaskIncrementTick>:
{
    5178:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    517c:	4b3d      	ldr	r3, [pc, #244]	; (5274 <xTaskIncrementTick+0xfc>)
    517e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    5182:	2b00      	cmp	r3, #0
    5184:	d166      	bne.n	5254 <xTaskIncrementTick+0xdc>
		++xTickCount;
    5186:	4b3b      	ldr	r3, [pc, #236]	; (5274 <xTaskIncrementTick+0xfc>)
    5188:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    518a:	3201      	adds	r2, #1
    518c:	635a      	str	r2, [r3, #52]	; 0x34
			const TickType_t xConstTickCount = xTickCount;
    518e:	6b5f      	ldr	r7, [r3, #52]	; 0x34
			if (xConstTickCount == (TickType_t)0U) {
    5190:	b9bf      	cbnz	r7, 51c2 <xTaskIncrementTick+0x4a>
				taskSWITCH_DELAYED_LISTS();
    5192:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5194:	681b      	ldr	r3, [r3, #0]
    5196:	b143      	cbz	r3, 51aa <xTaskIncrementTick+0x32>
    5198:	f04f 0380 	mov.w	r3, #128	; 0x80
    519c:	f383 8811 	msr	BASEPRI, r3
    51a0:	f3bf 8f6f 	isb	sy
    51a4:	f3bf 8f4f 	dsb	sy
    51a8:	e7fe      	b.n	51a8 <xTaskIncrementTick+0x30>
    51aa:	4b32      	ldr	r3, [pc, #200]	; (5274 <xTaskIncrementTick+0xfc>)
    51ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    51ae:	6b99      	ldr	r1, [r3, #56]	; 0x38
    51b0:	6299      	str	r1, [r3, #40]	; 0x28
    51b2:	639a      	str	r2, [r3, #56]	; 0x38
    51b4:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    51b8:	3201      	adds	r2, #1
    51ba:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    51be:	4b2e      	ldr	r3, [pc, #184]	; (5278 <xTaskIncrementTick+0x100>)
    51c0:	4798      	blx	r3
			if (xConstTickCount >= xNextTaskUnblockTime) {
    51c2:	4b2c      	ldr	r3, [pc, #176]	; (5274 <xTaskIncrementTick+0xfc>)
    51c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    51c6:	429f      	cmp	r7, r3
    51c8:	d20c      	bcs.n	51e4 <xTaskIncrementTick+0x6c>
	BaseType_t xSwitchRequired = pdFALSE;
    51ca:	2400      	movs	r4, #0
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    51cc:	4b29      	ldr	r3, [pc, #164]	; (5274 <xTaskIncrementTick+0xfc>)
    51ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    51d0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    51d2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    51d6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    51da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
				xSwitchRequired = pdTRUE;
    51dc:	2b02      	cmp	r3, #2
    51de:	bf28      	it	cs
    51e0:	2401      	movcs	r4, #1
    51e2:	e03e      	b.n	5262 <xTaskIncrementTick+0xea>
    51e4:	2400      	movs	r4, #0
					if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    51e6:	4d23      	ldr	r5, [pc, #140]	; (5274 <xTaskIncrementTick+0xfc>)
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    51e8:	f8df 8094 	ldr.w	r8, [pc, #148]	; 5280 <xTaskIncrementTick+0x108>
						prvAddTaskToReadyList(pxTCB);
    51ec:	f105 0a40 	add.w	sl, r5, #64	; 0x40
    51f0:	e01e      	b.n	5230 <xTaskIncrementTick+0xb8>
						xNextTaskUnblockTime = portMAX_DELAY;
    51f2:	f04f 32ff 	mov.w	r2, #4294967295
    51f6:	4b1f      	ldr	r3, [pc, #124]	; (5274 <xTaskIncrementTick+0xfc>)
    51f8:	62da      	str	r2, [r3, #44]	; 0x2c
						break;
    51fa:	e7e7      	b.n	51cc <xTaskIncrementTick+0x54>
							xNextTaskUnblockTime = xItemValue;
    51fc:	4a1d      	ldr	r2, [pc, #116]	; (5274 <xTaskIncrementTick+0xfc>)
    51fe:	62d3      	str	r3, [r2, #44]	; 0x2c
							break;
    5200:	e7e4      	b.n	51cc <xTaskIncrementTick+0x54>
							(void)uxListRemove(&(pxTCB->xEventListItem));
    5202:	f106 0018 	add.w	r0, r6, #24
    5206:	47c0      	blx	r8
						prvAddTaskToReadyList(pxTCB);
    5208:	6af0      	ldr	r0, [r6, #44]	; 0x2c
    520a:	f8d5 30fc 	ldr.w	r3, [r5, #252]	; 0xfc
    520e:	4298      	cmp	r0, r3
    5210:	bf88      	it	hi
    5212:	f8c5 00fc 	strhi.w	r0, [r5, #252]	; 0xfc
    5216:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    521a:	4649      	mov	r1, r9
    521c:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
    5220:	4b16      	ldr	r3, [pc, #88]	; (527c <xTaskIncrementTick+0x104>)
    5222:	4798      	blx	r3
							if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    5224:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    5226:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    5228:	6adb      	ldr	r3, [r3, #44]	; 0x2c
								xSwitchRequired = pdTRUE;
    522a:	429a      	cmp	r2, r3
    522c:	bf28      	it	cs
    522e:	2401      	movcs	r4, #1
					if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    5230:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5232:	681b      	ldr	r3, [r3, #0]
    5234:	2b00      	cmp	r3, #0
    5236:	d0dc      	beq.n	51f2 <xTaskIncrementTick+0x7a>
						pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    5238:	6aab      	ldr	r3, [r5, #40]	; 0x28
    523a:	68db      	ldr	r3, [r3, #12]
    523c:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xGenericListItem));
    523e:	6873      	ldr	r3, [r6, #4]
						if (xConstTickCount < xItemValue) {
    5240:	429f      	cmp	r7, r3
    5242:	d3db      	bcc.n	51fc <xTaskIncrementTick+0x84>
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    5244:	f106 0904 	add.w	r9, r6, #4
    5248:	4648      	mov	r0, r9
    524a:	47c0      	blx	r8
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    524c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    524e:	2b00      	cmp	r3, #0
    5250:	d1d7      	bne.n	5202 <xTaskIncrementTick+0x8a>
    5252:	e7d9      	b.n	5208 <xTaskIncrementTick+0x90>
		++uxPendedTicks;
    5254:	4a07      	ldr	r2, [pc, #28]	; (5274 <xTaskIncrementTick+0xfc>)
    5256:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    525a:	3301      	adds	r3, #1
    525c:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
	BaseType_t xSwitchRequired = pdFALSE;
    5260:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
    5262:	4b04      	ldr	r3, [pc, #16]	; (5274 <xTaskIncrementTick+0xfc>)
    5264:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
			xSwitchRequired = pdTRUE;
    5268:	2b00      	cmp	r3, #0
}
    526a:	bf0c      	ite	eq
    526c:	4620      	moveq	r0, r4
    526e:	2001      	movne	r0, #1
    5270:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5274:	2000e3ac 	.word	0x2000e3ac
    5278:	00004e75 	.word	0x00004e75
    527c:	00004061 	.word	0x00004061
    5280:	000040ad 	.word	0x000040ad

00005284 <xTaskResumeAll>:
{
    5284:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT(uxSchedulerSuspended);
    5288:	4b3b      	ldr	r3, [pc, #236]	; (5378 <xTaskResumeAll+0xf4>)
    528a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    528e:	b943      	cbnz	r3, 52a2 <xTaskResumeAll+0x1e>
    5290:	f04f 0380 	mov.w	r3, #128	; 0x80
    5294:	f383 8811 	msr	BASEPRI, r3
    5298:	f3bf 8f6f 	isb	sy
    529c:	f3bf 8f4f 	dsb	sy
    52a0:	e7fe      	b.n	52a0 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
    52a2:	4b36      	ldr	r3, [pc, #216]	; (537c <xTaskResumeAll+0xf8>)
    52a4:	4798      	blx	r3
		--uxSchedulerSuspended;
    52a6:	4b34      	ldr	r3, [pc, #208]	; (5378 <xTaskResumeAll+0xf4>)
    52a8:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    52ac:	3a01      	subs	r2, #1
    52ae:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    52b2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    52b6:	2b00      	cmp	r3, #0
    52b8:	d15a      	bne.n	5370 <xTaskResumeAll+0xec>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    52ba:	4b2f      	ldr	r3, [pc, #188]	; (5378 <xTaskResumeAll+0xf4>)
    52bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    52be:	2b00      	cmp	r3, #0
    52c0:	d132      	bne.n	5328 <xTaskResumeAll+0xa4>
	BaseType_t xAlreadyYielded = pdFALSE;
    52c2:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    52c4:	4b2e      	ldr	r3, [pc, #184]	; (5380 <xTaskResumeAll+0xfc>)
    52c6:	4798      	blx	r3
}
    52c8:	4620      	mov	r0, r4
    52ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    52ce:	6a23      	ldr	r3, [r4, #32]
    52d0:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    52d2:	f105 0018 	add.w	r0, r5, #24
    52d6:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    52d8:	1d2f      	adds	r7, r5, #4
    52da:	4638      	mov	r0, r7
    52dc:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
    52de:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    52e0:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
    52e4:	4298      	cmp	r0, r3
    52e6:	bf88      	it	hi
    52e8:	f8c4 00fc 	strhi.w	r0, [r4, #252]	; 0xfc
    52ec:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    52f0:	4639      	mov	r1, r7
    52f2:	eb09 0080 	add.w	r0, r9, r0, lsl #2
    52f6:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    52f8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    52fa:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    52fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    52fe:	429a      	cmp	r2, r3
    5300:	d20e      	bcs.n	5320 <xTaskResumeAll+0x9c>
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    5302:	6963      	ldr	r3, [r4, #20]
    5304:	2b00      	cmp	r3, #0
    5306:	d1e2      	bne.n	52ce <xTaskResumeAll+0x4a>
				if (uxPendedTicks > (UBaseType_t)0U) {
    5308:	4b1b      	ldr	r3, [pc, #108]	; (5378 <xTaskResumeAll+0xf4>)
    530a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
    530e:	b303      	cbz	r3, 5352 <xTaskResumeAll+0xce>
					while (uxPendedTicks > (UBaseType_t)0U) {
    5310:	4b19      	ldr	r3, [pc, #100]	; (5378 <xTaskResumeAll+0xf4>)
    5312:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
    5316:	b1e3      	cbz	r3, 5352 <xTaskResumeAll+0xce>
						if (xTaskIncrementTick() != pdFALSE) {
    5318:	4e1a      	ldr	r6, [pc, #104]	; (5384 <xTaskResumeAll+0x100>)
							xYieldPending = pdTRUE;
    531a:	4c17      	ldr	r4, [pc, #92]	; (5378 <xTaskResumeAll+0xf4>)
    531c:	2501      	movs	r5, #1
    531e:	e012      	b.n	5346 <xTaskResumeAll+0xc2>
						xYieldPending = pdTRUE;
    5320:	2301      	movs	r3, #1
    5322:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
    5326:	e7ec      	b.n	5302 <xTaskResumeAll+0x7e>
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    5328:	4c13      	ldr	r4, [pc, #76]	; (5378 <xTaskResumeAll+0xf4>)
					(void)uxListRemove(&(pxTCB->xEventListItem));
    532a:	4e17      	ldr	r6, [pc, #92]	; (5388 <xTaskResumeAll+0x104>)
					prvAddTaskToReadyList(pxTCB);
    532c:	f104 0940 	add.w	r9, r4, #64	; 0x40
    5330:	f8df 805c 	ldr.w	r8, [pc, #92]	; 5390 <xTaskResumeAll+0x10c>
    5334:	e7e5      	b.n	5302 <xTaskResumeAll+0x7e>
						--uxPendedTicks;
    5336:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
    533a:	3b01      	subs	r3, #1
    533c:	f8c4 310c 	str.w	r3, [r4, #268]	; 0x10c
					while (uxPendedTicks > (UBaseType_t)0U) {
    5340:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
    5344:	b12b      	cbz	r3, 5352 <xTaskResumeAll+0xce>
						if (xTaskIncrementTick() != pdFALSE) {
    5346:	47b0      	blx	r6
    5348:	2800      	cmp	r0, #0
    534a:	d0f4      	beq.n	5336 <xTaskResumeAll+0xb2>
							xYieldPending = pdTRUE;
    534c:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
    5350:	e7f1      	b.n	5336 <xTaskResumeAll+0xb2>
				if (xYieldPending == pdTRUE) {
    5352:	4b09      	ldr	r3, [pc, #36]	; (5378 <xTaskResumeAll+0xf4>)
    5354:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
    5358:	2b01      	cmp	r3, #1
    535a:	d10b      	bne.n	5374 <xTaskResumeAll+0xf0>
					taskYIELD_IF_USING_PREEMPTION();
    535c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    5360:	4b0a      	ldr	r3, [pc, #40]	; (538c <xTaskResumeAll+0x108>)
    5362:	601a      	str	r2, [r3, #0]
    5364:	f3bf 8f4f 	dsb	sy
    5368:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
    536c:	2401      	movs	r4, #1
    536e:	e7a9      	b.n	52c4 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
    5370:	2400      	movs	r4, #0
    5372:	e7a7      	b.n	52c4 <xTaskResumeAll+0x40>
    5374:	2400      	movs	r4, #0
    5376:	e7a5      	b.n	52c4 <xTaskResumeAll+0x40>
    5378:	2000e3ac 	.word	0x2000e3ac
    537c:	00004181 	.word	0x00004181
    5380:	000041c5 	.word	0x000041c5
    5384:	00005179 	.word	0x00005179
    5388:	000040ad 	.word	0x000040ad
    538c:	e000ed04 	.word	0xe000ed04
    5390:	00004061 	.word	0x00004061

00005394 <vTaskDelay>:
{
    5394:	b510      	push	{r4, lr}
	if (xTicksToDelay > (TickType_t)0U) {
    5396:	b1e0      	cbz	r0, 53d2 <vTaskDelay+0x3e>
    5398:	4604      	mov	r4, r0
		configASSERT(uxSchedulerSuspended == 0);
    539a:	4b12      	ldr	r3, [pc, #72]	; (53e4 <vTaskDelay+0x50>)
    539c:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    53a0:	b143      	cbz	r3, 53b4 <vTaskDelay+0x20>
    53a2:	f04f 0380 	mov.w	r3, #128	; 0x80
    53a6:	f383 8811 	msr	BASEPRI, r3
    53aa:	f3bf 8f6f 	isb	sy
    53ae:	f3bf 8f4f 	dsb	sy
    53b2:	e7fe      	b.n	53b2 <vTaskDelay+0x1e>
		vTaskSuspendAll();
    53b4:	4b0c      	ldr	r3, [pc, #48]	; (53e8 <vTaskDelay+0x54>)
    53b6:	4798      	blx	r3
			xTimeToWake = xTickCount + xTicksToDelay;
    53b8:	4b0a      	ldr	r3, [pc, #40]	; (53e4 <vTaskDelay+0x50>)
    53ba:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    53bc:	4414      	add	r4, r2
			if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    53be:	6b18      	ldr	r0, [r3, #48]	; 0x30
    53c0:	3004      	adds	r0, #4
    53c2:	4b0a      	ldr	r3, [pc, #40]	; (53ec <vTaskDelay+0x58>)
    53c4:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    53c6:	4620      	mov	r0, r4
    53c8:	4b09      	ldr	r3, [pc, #36]	; (53f0 <vTaskDelay+0x5c>)
    53ca:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    53cc:	4b09      	ldr	r3, [pc, #36]	; (53f4 <vTaskDelay+0x60>)
    53ce:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    53d0:	b938      	cbnz	r0, 53e2 <vTaskDelay+0x4e>
		portYIELD_WITHIN_API();
    53d2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    53d6:	4b08      	ldr	r3, [pc, #32]	; (53f8 <vTaskDelay+0x64>)
    53d8:	601a      	str	r2, [r3, #0]
    53da:	f3bf 8f4f 	dsb	sy
    53de:	f3bf 8f6f 	isb	sy
    53e2:	bd10      	pop	{r4, pc}
    53e4:	2000e3ac 	.word	0x2000e3ac
    53e8:	00005159 	.word	0x00005159
    53ec:	000040ad 	.word	0x000040ad
    53f0:	00004e99 	.word	0x00004e99
    53f4:	00005285 	.word	0x00005285
    53f8:	e000ed04 	.word	0xe000ed04

000053fc <prvIdleTask>:
{
    53fc:	b580      	push	{r7, lr}
		while (uxTasksDeleted > (UBaseType_t)0U) {
    53fe:	4c1b      	ldr	r4, [pc, #108]	; (546c <prvIdleTask+0x70>)
			vTaskSuspendAll();
    5400:	4f1b      	ldr	r7, [pc, #108]	; (5470 <prvIdleTask+0x74>)
			(void)xTaskResumeAll();
    5402:	4e1c      	ldr	r6, [pc, #112]	; (5474 <prvIdleTask+0x78>)
				taskYIELD();
    5404:	f8df 9078 	ldr.w	r9, [pc, #120]	; 5480 <prvIdleTask+0x84>
    5408:	e02c      	b.n	5464 <prvIdleTask+0x68>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    540a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    540c:	2b01      	cmp	r3, #1
    540e:	d821      	bhi.n	5454 <prvIdleTask+0x58>
		while (uxTasksDeleted > (UBaseType_t)0U) {
    5410:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    5414:	2b00      	cmp	r3, #0
    5416:	d0f8      	beq.n	540a <prvIdleTask+0xe>
			vTaskSuspendAll();
    5418:	47b8      	blx	r7
				xListIsEmpty = listLIST_IS_EMPTY(&xTasksWaitingTermination);
    541a:	f8d4 50e0 	ldr.w	r5, [r4, #224]	; 0xe0
			(void)xTaskResumeAll();
    541e:	47b0      	blx	r6
			if (xListIsEmpty == pdFALSE) {
    5420:	2d00      	cmp	r5, #0
    5422:	d0f5      	beq.n	5410 <prvIdleTask+0x14>
				taskENTER_CRITICAL();
    5424:	47c0      	blx	r8
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xTasksWaitingTermination));
    5426:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    542a:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    542c:	1d28      	adds	r0, r5, #4
    542e:	4b12      	ldr	r3, [pc, #72]	; (5478 <prvIdleTask+0x7c>)
    5430:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
    5432:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    5434:	3b01      	subs	r3, #1
    5436:	63e3      	str	r3, [r4, #60]	; 0x3c
					--uxTasksDeleted;
    5438:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    543c:	3b01      	subs	r3, #1
    543e:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
				taskEXIT_CRITICAL();
    5442:	4b0e      	ldr	r3, [pc, #56]	; (547c <prvIdleTask+0x80>)
    5444:	4798      	blx	r3
		vPortFreeAligned(pxTCB->pxStack);
    5446:	6b28      	ldr	r0, [r5, #48]	; 0x30
    5448:	f8df a038 	ldr.w	sl, [pc, #56]	; 5484 <prvIdleTask+0x88>
    544c:	47d0      	blx	sl
	vPortFree(pxTCB);
    544e:	4628      	mov	r0, r5
    5450:	47d0      	blx	sl
    5452:	e7dd      	b.n	5410 <prvIdleTask+0x14>
				taskYIELD();
    5454:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    5458:	f8c9 3000 	str.w	r3, [r9]
    545c:	f3bf 8f4f 	dsb	sy
    5460:	f3bf 8f6f 	isb	sy
				taskENTER_CRITICAL();
    5464:	f8df 8020 	ldr.w	r8, [pc, #32]	; 5488 <prvIdleTask+0x8c>
    5468:	e7d2      	b.n	5410 <prvIdleTask+0x14>
    546a:	bf00      	nop
    546c:	2000e3ac 	.word	0x2000e3ac
    5470:	00005159 	.word	0x00005159
    5474:	00005285 	.word	0x00005285
    5478:	000040ad 	.word	0x000040ad
    547c:	000041c5 	.word	0x000041c5
    5480:	e000ed04 	.word	0xe000ed04
    5484:	000044cd 	.word	0x000044cd
    5488:	00004181 	.word	0x00004181

0000548c <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    548c:	4b2a      	ldr	r3, [pc, #168]	; (5538 <vTaskSwitchContext+0xac>)
    548e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    5492:	bb53      	cbnz	r3, 54ea <vTaskSwitchContext+0x5e>
		xYieldPending = pdFALSE;
    5494:	4b28      	ldr	r3, [pc, #160]	; (5538 <vTaskSwitchContext+0xac>)
    5496:	2200      	movs	r2, #0
    5498:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
		taskSELECT_HIGHEST_PRIORITY_TASK();
    549c:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
    54a0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    54a4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    54a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    54aa:	bb1b      	cbnz	r3, 54f4 <vTaskSwitchContext+0x68>
    54ac:	4b22      	ldr	r3, [pc, #136]	; (5538 <vTaskSwitchContext+0xac>)
    54ae:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
    54b2:	b18b      	cbz	r3, 54d8 <vTaskSwitchContext+0x4c>
    54b4:	4a20      	ldr	r2, [pc, #128]	; (5538 <vTaskSwitchContext+0xac>)
    54b6:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
    54ba:	3b01      	subs	r3, #1
    54bc:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
    54c0:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
    54c4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    54c8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    54cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    54ce:	b98b      	cbnz	r3, 54f4 <vTaskSwitchContext+0x68>
    54d0:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
    54d4:	2b00      	cmp	r3, #0
    54d6:	d1ee      	bne.n	54b6 <vTaskSwitchContext+0x2a>
    54d8:	f04f 0380 	mov.w	r3, #128	; 0x80
    54dc:	f383 8811 	msr	BASEPRI, r3
    54e0:	f3bf 8f6f 	isb	sy
    54e4:	f3bf 8f4f 	dsb	sy
    54e8:	e7fe      	b.n	54e8 <vTaskSwitchContext+0x5c>
		xYieldPending = pdTRUE;
    54ea:	2201      	movs	r2, #1
    54ec:	4b12      	ldr	r3, [pc, #72]	; (5538 <vTaskSwitchContext+0xac>)
    54ee:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    54f2:	4770      	bx	lr
{
    54f4:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    54f6:	4a10      	ldr	r2, [pc, #64]	; (5538 <vTaskSwitchContext+0xac>)
    54f8:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
    54fc:	0099      	lsls	r1, r3, #2
    54fe:	18c8      	adds	r0, r1, r3
    5500:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    5504:	6c44      	ldr	r4, [r0, #68]	; 0x44
    5506:	6864      	ldr	r4, [r4, #4]
    5508:	6444      	str	r4, [r0, #68]	; 0x44
    550a:	4419      	add	r1, r3
    550c:	4602      	mov	r2, r0
    550e:	3248      	adds	r2, #72	; 0x48
    5510:	4294      	cmp	r4, r2
    5512:	d00a      	beq.n	552a <vTaskSwitchContext+0x9e>
    5514:	4a08      	ldr	r2, [pc, #32]	; (5538 <vTaskSwitchContext+0xac>)
    5516:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    551a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    551e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    5520:	68db      	ldr	r3, [r3, #12]
    5522:	6313      	str	r3, [r2, #48]	; 0x30
}
    5524:	f85d 4b04 	ldr.w	r4, [sp], #4
    5528:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
    552a:	6860      	ldr	r0, [r4, #4]
    552c:	4a02      	ldr	r2, [pc, #8]	; (5538 <vTaskSwitchContext+0xac>)
    552e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    5532:	6450      	str	r0, [r2, #68]	; 0x44
    5534:	e7ee      	b.n	5514 <vTaskSwitchContext+0x88>
    5536:	bf00      	nop
    5538:	2000e3ac 	.word	0x2000e3ac

0000553c <vTaskPlaceOnEventList>:
{
    553c:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxEventList);
    553e:	b190      	cbz	r0, 5566 <vTaskPlaceOnEventList+0x2a>
    5540:	460c      	mov	r4, r1
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    5542:	4d10      	ldr	r5, [pc, #64]	; (5584 <vTaskPlaceOnEventList+0x48>)
    5544:	6b29      	ldr	r1, [r5, #48]	; 0x30
    5546:	3118      	adds	r1, #24
    5548:	4b0f      	ldr	r3, [pc, #60]	; (5588 <vTaskPlaceOnEventList+0x4c>)
    554a:	4798      	blx	r3
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    554c:	6b28      	ldr	r0, [r5, #48]	; 0x30
    554e:	3004      	adds	r0, #4
    5550:	4b0e      	ldr	r3, [pc, #56]	; (558c <vTaskPlaceOnEventList+0x50>)
    5552:	4798      	blx	r3
		if (xTicksToWait == portMAX_DELAY) {
    5554:	f1b4 3fff 	cmp.w	r4, #4294967295
    5558:	d00e      	beq.n	5578 <vTaskPlaceOnEventList+0x3c>
			xTimeToWake = xTickCount + xTicksToWait;
    555a:	4b0a      	ldr	r3, [pc, #40]	; (5584 <vTaskPlaceOnEventList+0x48>)
    555c:	6b58      	ldr	r0, [r3, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    555e:	4420      	add	r0, r4
    5560:	4b0b      	ldr	r3, [pc, #44]	; (5590 <vTaskPlaceOnEventList+0x54>)
    5562:	4798      	blx	r3
    5564:	bd38      	pop	{r3, r4, r5, pc}
    5566:	f04f 0380 	mov.w	r3, #128	; 0x80
    556a:	f383 8811 	msr	BASEPRI, r3
    556e:	f3bf 8f6f 	isb	sy
    5572:	f3bf 8f4f 	dsb	sy
    5576:	e7fe      	b.n	5576 <vTaskPlaceOnEventList+0x3a>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    5578:	4628      	mov	r0, r5
    557a:	6b29      	ldr	r1, [r5, #48]	; 0x30
    557c:	3104      	adds	r1, #4
    557e:	4b05      	ldr	r3, [pc, #20]	; (5594 <vTaskPlaceOnEventList+0x58>)
    5580:	4798      	blx	r3
    5582:	bd38      	pop	{r3, r4, r5, pc}
    5584:	2000e3ac 	.word	0x2000e3ac
    5588:	00004079 	.word	0x00004079
    558c:	000040ad 	.word	0x000040ad
    5590:	00004e99 	.word	0x00004e99
    5594:	00004061 	.word	0x00004061

00005598 <vTaskPlaceOnEventListRestricted>:
	configASSERT(pxEventList);
    5598:	b198      	cbz	r0, 55c2 <vTaskPlaceOnEventListRestricted+0x2a>
{
    559a:	b570      	push	{r4, r5, r6, lr}
    559c:	4615      	mov	r5, r2
    559e:	460c      	mov	r4, r1
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    55a0:	4e0f      	ldr	r6, [pc, #60]	; (55e0 <vTaskPlaceOnEventListRestricted+0x48>)
    55a2:	6b31      	ldr	r1, [r6, #48]	; 0x30
    55a4:	3118      	adds	r1, #24
    55a6:	4b0f      	ldr	r3, [pc, #60]	; (55e4 <vTaskPlaceOnEventListRestricted+0x4c>)
    55a8:	4798      	blx	r3
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    55aa:	6b30      	ldr	r0, [r6, #48]	; 0x30
    55ac:	3004      	adds	r0, #4
    55ae:	4b0e      	ldr	r3, [pc, #56]	; (55e8 <vTaskPlaceOnEventListRestricted+0x50>)
    55b0:	4798      	blx	r3
		if (xWaitIndefinitely == pdTRUE) {
    55b2:	2d01      	cmp	r5, #1
    55b4:	d00e      	beq.n	55d4 <vTaskPlaceOnEventListRestricted+0x3c>
			xTimeToWake = xTickCount + xTicksToWait;
    55b6:	4b0a      	ldr	r3, [pc, #40]	; (55e0 <vTaskPlaceOnEventListRestricted+0x48>)
    55b8:	6b58      	ldr	r0, [r3, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    55ba:	4420      	add	r0, r4
    55bc:	4b0b      	ldr	r3, [pc, #44]	; (55ec <vTaskPlaceOnEventListRestricted+0x54>)
    55be:	4798      	blx	r3
    55c0:	bd70      	pop	{r4, r5, r6, pc}
    55c2:	f04f 0380 	mov.w	r3, #128	; 0x80
    55c6:	f383 8811 	msr	BASEPRI, r3
    55ca:	f3bf 8f6f 	isb	sy
    55ce:	f3bf 8f4f 	dsb	sy
    55d2:	e7fe      	b.n	55d2 <vTaskPlaceOnEventListRestricted+0x3a>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    55d4:	4630      	mov	r0, r6
    55d6:	6b31      	ldr	r1, [r6, #48]	; 0x30
    55d8:	3104      	adds	r1, #4
    55da:	4b02      	ldr	r3, [pc, #8]	; (55e4 <vTaskPlaceOnEventListRestricted+0x4c>)
    55dc:	4798      	blx	r3
    55de:	bd70      	pop	{r4, r5, r6, pc}
    55e0:	2000e3ac 	.word	0x2000e3ac
    55e4:	00004061 	.word	0x00004061
    55e8:	000040ad 	.word	0x000040ad
    55ec:	00004e99 	.word	0x00004e99

000055f0 <xTaskRemoveFromEventList>:
{
    55f0:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    55f2:	68c3      	ldr	r3, [r0, #12]
    55f4:	68dc      	ldr	r4, [r3, #12]
	configASSERT(pxUnblockedTCB);
    55f6:	2c00      	cmp	r4, #0
    55f8:	d029      	beq.n	564e <xTaskRemoveFromEventList+0x5e>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    55fa:	f104 0518 	add.w	r5, r4, #24
    55fe:	4628      	mov	r0, r5
    5600:	4b1a      	ldr	r3, [pc, #104]	; (566c <xTaskRemoveFromEventList+0x7c>)
    5602:	4798      	blx	r3
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    5604:	4b1a      	ldr	r3, [pc, #104]	; (5670 <xTaskRemoveFromEventList+0x80>)
    5606:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    560a:	bb4b      	cbnz	r3, 5660 <xTaskRemoveFromEventList+0x70>
		(void)uxListRemove(&(pxUnblockedTCB->xGenericListItem));
    560c:	1d25      	adds	r5, r4, #4
    560e:	4628      	mov	r0, r5
    5610:	4b16      	ldr	r3, [pc, #88]	; (566c <xTaskRemoveFromEventList+0x7c>)
    5612:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
    5614:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    5616:	4b16      	ldr	r3, [pc, #88]	; (5670 <xTaskRemoveFromEventList+0x80>)
    5618:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
    561c:	4298      	cmp	r0, r3
    561e:	bf84      	itt	hi
    5620:	4b13      	ldrhi	r3, [pc, #76]	; (5670 <xTaskRemoveFromEventList+0x80>)
    5622:	f8c3 00fc 	strhi.w	r0, [r3, #252]	; 0xfc
    5626:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    562a:	4629      	mov	r1, r5
    562c:	4b11      	ldr	r3, [pc, #68]	; (5674 <xTaskRemoveFromEventList+0x84>)
    562e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    5632:	4b11      	ldr	r3, [pc, #68]	; (5678 <xTaskRemoveFromEventList+0x88>)
    5634:	4798      	blx	r3
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    5636:	4b0e      	ldr	r3, [pc, #56]	; (5670 <xTaskRemoveFromEventList+0x80>)
    5638:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    563a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    563c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    563e:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    5640:	bf83      	ittte	hi
    5642:	2001      	movhi	r0, #1
    5644:	4b0a      	ldrhi	r3, [pc, #40]	; (5670 <xTaskRemoveFromEventList+0x80>)
    5646:	f8c3 0110 	strhi.w	r0, [r3, #272]	; 0x110
		xReturn = pdFALSE;
    564a:	2000      	movls	r0, #0
}
    564c:	bd38      	pop	{r3, r4, r5, pc}
    564e:	f04f 0380 	mov.w	r3, #128	; 0x80
    5652:	f383 8811 	msr	BASEPRI, r3
    5656:	f3bf 8f6f 	isb	sy
    565a:	f3bf 8f4f 	dsb	sy
    565e:	e7fe      	b.n	565e <xTaskRemoveFromEventList+0x6e>
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    5660:	4629      	mov	r1, r5
    5662:	4806      	ldr	r0, [pc, #24]	; (567c <xTaskRemoveFromEventList+0x8c>)
    5664:	4b04      	ldr	r3, [pc, #16]	; (5678 <xTaskRemoveFromEventList+0x88>)
    5666:	4798      	blx	r3
    5668:	e7e5      	b.n	5636 <xTaskRemoveFromEventList+0x46>
    566a:	bf00      	nop
    566c:	000040ad 	.word	0x000040ad
    5670:	2000e3ac 	.word	0x2000e3ac
    5674:	2000e3ec 	.word	0x2000e3ec
    5678:	00004061 	.word	0x00004061
    567c:	2000e3c0 	.word	0x2000e3c0

00005680 <vTaskSetTimeOutState>:
	configASSERT(pxTimeOut);
    5680:	b130      	cbz	r0, 5690 <vTaskSetTimeOutState+0x10>
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    5682:	4a08      	ldr	r2, [pc, #32]	; (56a4 <vTaskSetTimeOutState+0x24>)
    5684:	f8d2 1108 	ldr.w	r1, [r2, #264]	; 0x108
    5688:	6001      	str	r1, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    568a:	6b52      	ldr	r2, [r2, #52]	; 0x34
    568c:	6042      	str	r2, [r0, #4]
    568e:	4770      	bx	lr
    5690:	f04f 0380 	mov.w	r3, #128	; 0x80
    5694:	f383 8811 	msr	BASEPRI, r3
    5698:	f3bf 8f6f 	isb	sy
    569c:	f3bf 8f4f 	dsb	sy
    56a0:	e7fe      	b.n	56a0 <vTaskSetTimeOutState+0x20>
    56a2:	bf00      	nop
    56a4:	2000e3ac 	.word	0x2000e3ac

000056a8 <xTaskCheckForTimeOut>:
{
    56a8:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxTimeOut);
    56aa:	b1c8      	cbz	r0, 56e0 <xTaskCheckForTimeOut+0x38>
    56ac:	4604      	mov	r4, r0
	configASSERT(pxTicksToWait);
    56ae:	b301      	cbz	r1, 56f2 <xTaskCheckForTimeOut+0x4a>
    56b0:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
    56b2:	4b1c      	ldr	r3, [pc, #112]	; (5724 <xTaskCheckForTimeOut+0x7c>)
    56b4:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    56b6:	4b1c      	ldr	r3, [pc, #112]	; (5728 <xTaskCheckForTimeOut+0x80>)
    56b8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
		if (*pxTicksToWait == portMAX_DELAY) {
    56ba:	682b      	ldr	r3, [r5, #0]
    56bc:	f1b3 3fff 	cmp.w	r3, #4294967295
    56c0:	d02b      	beq.n	571a <xTaskCheckForTimeOut+0x72>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    56c2:	4919      	ldr	r1, [pc, #100]	; (5728 <xTaskCheckForTimeOut+0x80>)
    56c4:	f8d1 1108 	ldr.w	r1, [r1, #264]	; 0x108
    56c8:	6820      	ldr	r0, [r4, #0]
    56ca:	4288      	cmp	r0, r1
    56cc:	d002      	beq.n	56d4 <xTaskCheckForTimeOut+0x2c>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    56ce:	6861      	ldr	r1, [r4, #4]
    56d0:	428a      	cmp	r2, r1
    56d2:	d224      	bcs.n	571e <xTaskCheckForTimeOut+0x76>
		} else if ((xConstTickCount - pxTimeOut->xTimeOnEntering) < *pxTicksToWait) {
    56d4:	6861      	ldr	r1, [r4, #4]
    56d6:	1a50      	subs	r0, r2, r1
    56d8:	4283      	cmp	r3, r0
    56da:	d813      	bhi.n	5704 <xTaskCheckForTimeOut+0x5c>
			xReturn = pdTRUE;
    56dc:	2401      	movs	r4, #1
    56de:	e018      	b.n	5712 <xTaskCheckForTimeOut+0x6a>
    56e0:	f04f 0380 	mov.w	r3, #128	; 0x80
    56e4:	f383 8811 	msr	BASEPRI, r3
    56e8:	f3bf 8f6f 	isb	sy
    56ec:	f3bf 8f4f 	dsb	sy
    56f0:	e7fe      	b.n	56f0 <xTaskCheckForTimeOut+0x48>
    56f2:	f04f 0380 	mov.w	r3, #128	; 0x80
    56f6:	f383 8811 	msr	BASEPRI, r3
    56fa:	f3bf 8f6f 	isb	sy
    56fe:	f3bf 8f4f 	dsb	sy
    5702:	e7fe      	b.n	5702 <xTaskCheckForTimeOut+0x5a>
			*pxTicksToWait -= (xConstTickCount - pxTimeOut->xTimeOnEntering);
    5704:	1a9b      	subs	r3, r3, r2
    5706:	440b      	add	r3, r1
    5708:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState(pxTimeOut);
    570a:	4620      	mov	r0, r4
    570c:	4b07      	ldr	r3, [pc, #28]	; (572c <xTaskCheckForTimeOut+0x84>)
    570e:	4798      	blx	r3
			xReturn = pdFALSE;
    5710:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    5712:	4b07      	ldr	r3, [pc, #28]	; (5730 <xTaskCheckForTimeOut+0x88>)
    5714:	4798      	blx	r3
}
    5716:	4620      	mov	r0, r4
    5718:	bd38      	pop	{r3, r4, r5, pc}
			xReturn = pdFALSE;
    571a:	2400      	movs	r4, #0
    571c:	e7f9      	b.n	5712 <xTaskCheckForTimeOut+0x6a>
			xReturn = pdTRUE;
    571e:	2401      	movs	r4, #1
    5720:	e7f7      	b.n	5712 <xTaskCheckForTimeOut+0x6a>
    5722:	bf00      	nop
    5724:	00004181 	.word	0x00004181
    5728:	2000e3ac 	.word	0x2000e3ac
    572c:	00005681 	.word	0x00005681
    5730:	000041c5 	.word	0x000041c5

00005734 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    5734:	2201      	movs	r2, #1
    5736:	4b02      	ldr	r3, [pc, #8]	; (5740 <vTaskMissedYield+0xc>)
    5738:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    573c:	4770      	bx	lr
    573e:	bf00      	nop
    5740:	2000e3ac 	.word	0x2000e3ac

00005744 <xTaskGetSchedulerState>:

BaseType_t xTaskGetSchedulerState(void)
{
	BaseType_t xReturn;

	if (xSchedulerRunning == pdFALSE) {
    5744:	4b06      	ldr	r3, [pc, #24]	; (5760 <xTaskGetSchedulerState+0x1c>)
    5746:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
    574a:	b13b      	cbz	r3, 575c <xTaskGetSchedulerState+0x18>
		xReturn = taskSCHEDULER_NOT_STARTED;
	} else {
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    574c:	4b04      	ldr	r3, [pc, #16]	; (5760 <xTaskGetSchedulerState+0x1c>)
    574e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
			xReturn = taskSCHEDULER_RUNNING;
		} else {
			xReturn = taskSCHEDULER_SUSPENDED;
    5752:	2b00      	cmp	r3, #0
    5754:	bf0c      	ite	eq
    5756:	2002      	moveq	r0, #2
    5758:	2000      	movne	r0, #0
    575a:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
    575c:	2001      	movs	r0, #1
		}
	}

	return xReturn;
}
    575e:	4770      	bx	lr
    5760:	2000e3ac 	.word	0x2000e3ac

00005764 <vTaskPriorityInherit>:
{
	TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;

	/* If the mutex was given back by an interrupt while the queue was
	locked then the mutex holder might now be NULL. */
	if (pxMutexHolder != NULL) {
    5764:	2800      	cmp	r0, #0
    5766:	d035      	beq.n	57d4 <vTaskPriorityInherit+0x70>
{
    5768:	b538      	push	{r3, r4, r5, lr}
    576a:	4605      	mov	r5, r0
		/* If the holder of the mutex has a priority below the priority of
		the task attempting to obtain the mutex then it will temporarily
		inherit the priority of the task attempting to obtain the mutex. */
		if (pxTCB->uxPriority < pxCurrentTCB->uxPriority) {
    576c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    576e:	491a      	ldr	r1, [pc, #104]	; (57d8 <vTaskPriorityInherit+0x74>)
    5770:	6b09      	ldr	r1, [r1, #48]	; 0x30
    5772:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    5774:	428a      	cmp	r2, r1
    5776:	d214      	bcs.n	57a2 <vTaskPriorityInherit+0x3e>
			/* Adjust the mutex holder state to account for its new
			priority.  Only reset the event list item value if the value is
			not	being used for anything else. */
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    5778:	6981      	ldr	r1, [r0, #24]
    577a:	2900      	cmp	r1, #0
    577c:	db05      	blt.n	578a <vTaskPriorityInherit+0x26>
				listSET_LIST_ITEM_VALUE(
    577e:	4916      	ldr	r1, [pc, #88]	; (57d8 <vTaskPriorityInherit+0x74>)
    5780:	6b09      	ldr	r1, [r1, #48]	; 0x30
    5782:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    5784:	f1c1 0106 	rsb	r1, r1, #6
    5788:	6181      	str	r1, [r0, #24]
				mtCOVERAGE_TEST_MARKER();
			}

			/* If the task being modified is in the ready state it will need
			to be moved into a new list. */
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xGenericListItem))
    578a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    578e:	4913      	ldr	r1, [pc, #76]	; (57dc <vTaskPriorityInherit+0x78>)
    5790:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    5794:	6969      	ldr	r1, [r5, #20]
    5796:	4291      	cmp	r1, r2
    5798:	d004      	beq.n	57a4 <vTaskPriorityInherit+0x40>
				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
				prvAddTaskToReadyList(pxTCB);
			} else {
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    579a:	4a0f      	ldr	r2, [pc, #60]	; (57d8 <vTaskPriorityInherit+0x74>)
    579c:	6b12      	ldr	r2, [r2, #48]	; 0x30
    579e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    57a0:	62ea      	str	r2, [r5, #44]	; 0x2c
    57a2:	bd38      	pop	{r3, r4, r5, pc}
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    57a4:	1d2c      	adds	r4, r5, #4
    57a6:	4620      	mov	r0, r4
    57a8:	4b0d      	ldr	r3, [pc, #52]	; (57e0 <vTaskPriorityInherit+0x7c>)
    57aa:	4798      	blx	r3
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    57ac:	4b0a      	ldr	r3, [pc, #40]	; (57d8 <vTaskPriorityInherit+0x74>)
    57ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    57b0:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
    57b2:	62e8      	str	r0, [r5, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
    57b4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
    57b8:	4298      	cmp	r0, r3
    57ba:	bf84      	itt	hi
    57bc:	4b06      	ldrhi	r3, [pc, #24]	; (57d8 <vTaskPriorityInherit+0x74>)
    57be:	f8c3 00fc 	strhi.w	r0, [r3, #252]	; 0xfc
    57c2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    57c6:	4621      	mov	r1, r4
    57c8:	4b04      	ldr	r3, [pc, #16]	; (57dc <vTaskPriorityInherit+0x78>)
    57ca:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    57ce:	4b05      	ldr	r3, [pc, #20]	; (57e4 <vTaskPriorityInherit+0x80>)
    57d0:	4798      	blx	r3
    57d2:	bd38      	pop	{r3, r4, r5, pc}
    57d4:	4770      	bx	lr
    57d6:	bf00      	nop
    57d8:	2000e3ac 	.word	0x2000e3ac
    57dc:	2000e3ec 	.word	0x2000e3ec
    57e0:	000040ad 	.word	0x000040ad
    57e4:	00004061 	.word	0x00004061

000057e8 <xTaskPriorityDisinherit>:
BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
	TCB_t *const pxTCB   = (TCB_t *)pxMutexHolder;
	BaseType_t   xReturn = pdFALSE;

	if (pxMutexHolder != NULL) {
    57e8:	2800      	cmp	r0, #0
    57ea:	d03b      	beq.n	5864 <xTaskPriorityDisinherit+0x7c>
{
    57ec:	b538      	push	{r3, r4, r5, lr}
    57ee:	4604      	mov	r4, r0
		/* A task can only have an inherited priority if it holds the mutex.
		If the mutex is held by a task then it cannot be given from an
		interrupt, and if a mutex is given by the holding task then it must
		be the running state task. */
		configASSERT(pxTCB == pxCurrentTCB);
    57f0:	4a1f      	ldr	r2, [pc, #124]	; (5870 <xTaskPriorityDisinherit+0x88>)
    57f2:	6b12      	ldr	r2, [r2, #48]	; 0x30
    57f4:	4290      	cmp	r0, r2
    57f6:	d008      	beq.n	580a <xTaskPriorityDisinherit+0x22>
    57f8:	f04f 0380 	mov.w	r3, #128	; 0x80
    57fc:	f383 8811 	msr	BASEPRI, r3
    5800:	f3bf 8f6f 	isb	sy
    5804:	f3bf 8f4f 	dsb	sy
    5808:	e7fe      	b.n	5808 <xTaskPriorityDisinherit+0x20>

		configASSERT(pxTCB->uxMutexesHeld);
    580a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    580c:	b942      	cbnz	r2, 5820 <xTaskPriorityDisinherit+0x38>
    580e:	f04f 0380 	mov.w	r3, #128	; 0x80
    5812:	f383 8811 	msr	BASEPRI, r3
    5816:	f3bf 8f6f 	isb	sy
    581a:	f3bf 8f4f 	dsb	sy
    581e:	e7fe      	b.n	581e <xTaskPriorityDisinherit+0x36>
		(pxTCB->uxMutexesHeld)--;
    5820:	3a01      	subs	r2, #1
    5822:	6482      	str	r2, [r0, #72]	; 0x48

		/* Has the holder of the mutex inherited the priority of another
		task? */
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    5824:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    5826:	6c61      	ldr	r1, [r4, #68]	; 0x44
    5828:	4288      	cmp	r0, r1
    582a:	d01d      	beq.n	5868 <xTaskPriorityDisinherit+0x80>
			/* Only disinherit if no other mutexes are held. */
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    582c:	b9f2      	cbnz	r2, 586c <xTaskPriorityDisinherit+0x84>
				/* A task can only have an inherited priority if it holds
				the mutex.  If the mutex is held by a task then it cannot be
				given from an interrupt, and if a mutex is given by the
				holding	task then it must be the running state task.  Remove
				the	holding task from the ready	list. */
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    582e:	1d25      	adds	r5, r4, #4
    5830:	4628      	mov	r0, r5
    5832:	4b10      	ldr	r3, [pc, #64]	; (5874 <xTaskPriorityDisinherit+0x8c>)
    5834:	4798      	blx	r3
				}

				/* Disinherit the priority before adding the task into the
				new	ready list. */
				traceTASK_PRIORITY_DISINHERIT(pxTCB, pxTCB->uxBasePriority);
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    5836:	6c60      	ldr	r0, [r4, #68]	; 0x44
    5838:	62e0      	str	r0, [r4, #44]	; 0x2c

				/* Reset the event list item value.  It cannot be in use for
				any other purpose if this task is running, and it must be
				running to give back the mutex. */
				listSET_LIST_ITEM_VALUE(
    583a:	f1c0 0306 	rsb	r3, r0, #6
    583e:	61a3      	str	r3, [r4, #24]
				    &(pxTCB->xEventListItem),
				    (TickType_t)configMAX_PRIORITIES - (TickType_t)pxTCB->uxPriority); /*lint !e961 MISRA exception as
				                                                                          the casts are only redundant
				                                                                          for some ports. */
				prvAddTaskToReadyList(pxTCB);
    5840:	4b0b      	ldr	r3, [pc, #44]	; (5870 <xTaskPriorityDisinherit+0x88>)
    5842:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
    5846:	4298      	cmp	r0, r3
    5848:	bf84      	itt	hi
    584a:	4b09      	ldrhi	r3, [pc, #36]	; (5870 <xTaskPriorityDisinherit+0x88>)
    584c:	f8c3 00fc 	strhi.w	r0, [r3, #252]	; 0xfc
    5850:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    5854:	4629      	mov	r1, r5
    5856:	4b08      	ldr	r3, [pc, #32]	; (5878 <xTaskPriorityDisinherit+0x90>)
    5858:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    585c:	4b07      	ldr	r3, [pc, #28]	; (587c <xTaskPriorityDisinherit+0x94>)
    585e:	4798      	blx	r3
				in an order different to that in which they were taken.
				If a context switch did not occur when the first mutex was
				returned, even if a task was waiting on it, then a context
				switch should occur when the last mutex is returned whether
				a task is waiting on it or not. */
				xReturn = pdTRUE;
    5860:	2001      	movs	r0, #1
    5862:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t   xReturn = pdFALSE;
    5864:	2000      	movs	r0, #0
    5866:	4770      	bx	lr
    5868:	2000      	movs	r0, #0
    586a:	bd38      	pop	{r3, r4, r5, pc}
    586c:	2000      	movs	r0, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    586e:	bd38      	pop	{r3, r4, r5, pc}
    5870:	2000e3ac 	.word	0x2000e3ac
    5874:	000040ad 	.word	0x000040ad
    5878:	2000e3ec 	.word	0x2000e3ec
    587c:	00004061 	.word	0x00004061

00005880 <pvTaskIncrementMutexHeldCount>:

void *pvTaskIncrementMutexHeldCount(void)
{
	/* If xSemaphoreCreateMutex() is called before any tasks have been created
	then pxCurrentTCB will be NULL. */
	if (pxCurrentTCB != NULL) {
    5880:	4b05      	ldr	r3, [pc, #20]	; (5898 <pvTaskIncrementMutexHeldCount+0x18>)
    5882:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    5884:	b123      	cbz	r3, 5890 <pvTaskIncrementMutexHeldCount+0x10>
		(pxCurrentTCB->uxMutexesHeld)++;
    5886:	4b04      	ldr	r3, [pc, #16]	; (5898 <pvTaskIncrementMutexHeldCount+0x18>)
    5888:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    588a:	6c93      	ldr	r3, [r2, #72]	; 0x48
    588c:	3301      	adds	r3, #1
    588e:	6493      	str	r3, [r2, #72]	; 0x48
	}

	return pxCurrentTCB;
    5890:	4b01      	ldr	r3, [pc, #4]	; (5898 <pvTaskIncrementMutexHeldCount+0x18>)
    5892:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
    5894:	4770      	bx	lr
    5896:	bf00      	nop
    5898:	2000e3ac 	.word	0x2000e3ac

0000589c <prvInsertTimerInActiveList>:
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
    589c:	b508      	push	{r3, lr}
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    589e:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    58a0:	6100      	str	r0, [r0, #16]

	if (xNextExpiryTime <= xTimeNow) {
    58a2:	4291      	cmp	r1, r2
    58a4:	d80c      	bhi.n	58c0 <prvInsertTimerInActiveList+0x24>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if ((xTimeNow - xCommandTime) >= pxTimer->xTimerPeriodInTicks) {
    58a6:	1ad2      	subs	r2, r2, r3
    58a8:	6983      	ldr	r3, [r0, #24]
    58aa:	429a      	cmp	r2, r3
    58ac:	d301      	bcc.n	58b2 <prvInsertTimerInActiveList+0x16>
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    58ae:	2001      	movs	r0, #1
    58b0:	bd08      	pop	{r3, pc}
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    58b2:	1d01      	adds	r1, r0, #4
    58b4:	4b09      	ldr	r3, [pc, #36]	; (58dc <prvInsertTimerInActiveList+0x40>)
    58b6:	6818      	ldr	r0, [r3, #0]
    58b8:	4b09      	ldr	r3, [pc, #36]	; (58e0 <prvInsertTimerInActiveList+0x44>)
    58ba:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    58bc:	2000      	movs	r0, #0
    58be:	bd08      	pop	{r3, pc}
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    58c0:	429a      	cmp	r2, r3
    58c2:	d201      	bcs.n	58c8 <prvInsertTimerInActiveList+0x2c>
    58c4:	4299      	cmp	r1, r3
    58c6:	d206      	bcs.n	58d6 <prvInsertTimerInActiveList+0x3a>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    58c8:	1d01      	adds	r1, r0, #4
    58ca:	4b04      	ldr	r3, [pc, #16]	; (58dc <prvInsertTimerInActiveList+0x40>)
    58cc:	6858      	ldr	r0, [r3, #4]
    58ce:	4b04      	ldr	r3, [pc, #16]	; (58e0 <prvInsertTimerInActiveList+0x44>)
    58d0:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    58d2:	2000      	movs	r0, #0
    58d4:	bd08      	pop	{r3, pc}
			xProcessTimerNow = pdTRUE;
    58d6:	2001      	movs	r0, #1
		}
	}

	return xProcessTimerNow;
}
    58d8:	bd08      	pop	{r3, pc}
    58da:	bf00      	nop
    58dc:	2000e4c0 	.word	0x2000e4c0
    58e0:	00004079 	.word	0x00004079

000058e4 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    58e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    58e6:	4b13      	ldr	r3, [pc, #76]	; (5934 <prvCheckForValidListAndQueue+0x50>)
    58e8:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
    58ea:	4b13      	ldr	r3, [pc, #76]	; (5938 <prvCheckForValidListAndQueue+0x54>)
    58ec:	689b      	ldr	r3, [r3, #8]
    58ee:	b113      	cbz	r3, 58f6 <prvCheckForValidListAndQueue+0x12>
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    58f0:	4b12      	ldr	r3, [pc, #72]	; (593c <prvCheckForValidListAndQueue+0x58>)
    58f2:	4798      	blx	r3
    58f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise(&xActiveTimerList1);
    58f6:	4c10      	ldr	r4, [pc, #64]	; (5938 <prvCheckForValidListAndQueue+0x54>)
    58f8:	f104 060c 	add.w	r6, r4, #12
    58fc:	4630      	mov	r0, r6
    58fe:	4f10      	ldr	r7, [pc, #64]	; (5940 <prvCheckForValidListAndQueue+0x5c>)
    5900:	47b8      	blx	r7
			vListInitialise(&xActiveTimerList2);
    5902:	f104 0520 	add.w	r5, r4, #32
    5906:	4628      	mov	r0, r5
    5908:	47b8      	blx	r7
			pxCurrentTimerList  = &xActiveTimerList1;
    590a:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    590c:	6025      	str	r5, [r4, #0]
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    590e:	2200      	movs	r2, #0
    5910:	210c      	movs	r1, #12
    5912:	2002      	movs	r0, #2
    5914:	4b0b      	ldr	r3, [pc, #44]	; (5944 <prvCheckForValidListAndQueue+0x60>)
    5916:	4798      	blx	r3
			configASSERT(xTimerQueue);
    5918:	b110      	cbz	r0, 5920 <prvCheckForValidListAndQueue+0x3c>
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    591a:	4623      	mov	r3, r4
    591c:	6098      	str	r0, [r3, #8]
    591e:	e7e7      	b.n	58f0 <prvCheckForValidListAndQueue+0xc>
    5920:	f04f 0380 	mov.w	r3, #128	; 0x80
    5924:	f383 8811 	msr	BASEPRI, r3
    5928:	f3bf 8f6f 	isb	sy
    592c:	f3bf 8f4f 	dsb	sy
    5930:	e7fe      	b.n	5930 <prvCheckForValidListAndQueue+0x4c>
    5932:	bf00      	nop
    5934:	00004181 	.word	0x00004181
    5938:	2000e4c0 	.word	0x2000e4c0
    593c:	000041c5 	.word	0x000041c5
    5940:	00004045 	.word	0x00004045
    5944:	0000477d 	.word	0x0000477d

00005948 <xTimerCreateTimerTask>:
{
    5948:	b510      	push	{r4, lr}
    594a:	b084      	sub	sp, #16
	prvCheckForValidListAndQueue();
    594c:	4b0d      	ldr	r3, [pc, #52]	; (5984 <xTimerCreateTimerTask+0x3c>)
    594e:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    5950:	4b0d      	ldr	r3, [pc, #52]	; (5988 <xTimerCreateTimerTask+0x40>)
    5952:	689b      	ldr	r3, [r3, #8]
    5954:	b16b      	cbz	r3, 5972 <xTimerCreateTimerTask+0x2a>
			xReturn = xTaskCreate(prvTimerTask,
    5956:	2300      	movs	r3, #0
    5958:	9303      	str	r3, [sp, #12]
    595a:	9302      	str	r3, [sp, #8]
    595c:	9301      	str	r3, [sp, #4]
    595e:	2202      	movs	r2, #2
    5960:	9200      	str	r2, [sp, #0]
    5962:	2240      	movs	r2, #64	; 0x40
    5964:	4909      	ldr	r1, [pc, #36]	; (598c <xTimerCreateTimerTask+0x44>)
    5966:	480a      	ldr	r0, [pc, #40]	; (5990 <xTimerCreateTimerTask+0x48>)
    5968:	4c0a      	ldr	r4, [pc, #40]	; (5994 <xTimerCreateTimerTask+0x4c>)
    596a:	47a0      	blx	r4
	configASSERT(xReturn);
    596c:	b108      	cbz	r0, 5972 <xTimerCreateTimerTask+0x2a>
}
    596e:	b004      	add	sp, #16
    5970:	bd10      	pop	{r4, pc}
    5972:	f04f 0380 	mov.w	r3, #128	; 0x80
    5976:	f383 8811 	msr	BASEPRI, r3
    597a:	f3bf 8f6f 	isb	sy
    597e:	f3bf 8f4f 	dsb	sy
    5982:	e7fe      	b.n	5982 <xTimerCreateTimerTask+0x3a>
    5984:	000058e5 	.word	0x000058e5
    5988:	2000e4c0 	.word	0x2000e4c0
    598c:	00007198 	.word	0x00007198
    5990:	00005ab1 	.word	0x00005ab1
    5994:	00004ed9 	.word	0x00004ed9

00005998 <xTimerGenericCommand>:
	configASSERT(xTimer);
    5998:	b1d8      	cbz	r0, 59d2 <xTimerGenericCommand+0x3a>
{
    599a:	b530      	push	{r4, r5, lr}
    599c:	b085      	sub	sp, #20
    599e:	4615      	mov	r5, r2
    59a0:	4604      	mov	r4, r0
	if (xTimerQueue != NULL) {
    59a2:	4a14      	ldr	r2, [pc, #80]	; (59f4 <xTimerGenericCommand+0x5c>)
    59a4:	6890      	ldr	r0, [r2, #8]
    59a6:	b310      	cbz	r0, 59ee <xTimerGenericCommand+0x56>
    59a8:	461a      	mov	r2, r3
		xMessage.xMessageID                       = xCommandID;
    59aa:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    59ac:	9502      	str	r5, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    59ae:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    59b0:	2905      	cmp	r1, #5
    59b2:	dc17      	bgt.n	59e4 <xTimerGenericCommand+0x4c>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    59b4:	4b10      	ldr	r3, [pc, #64]	; (59f8 <xTimerGenericCommand+0x60>)
    59b6:	4798      	blx	r3
    59b8:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    59ba:	f04f 0300 	mov.w	r3, #0
    59be:	bf0c      	ite	eq
    59c0:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    59c2:	461a      	movne	r2, r3
    59c4:	a901      	add	r1, sp, #4
    59c6:	480b      	ldr	r0, [pc, #44]	; (59f4 <xTimerGenericCommand+0x5c>)
    59c8:	6880      	ldr	r0, [r0, #8]
    59ca:	4c0c      	ldr	r4, [pc, #48]	; (59fc <xTimerGenericCommand+0x64>)
    59cc:	47a0      	blx	r4
}
    59ce:	b005      	add	sp, #20
    59d0:	bd30      	pop	{r4, r5, pc}
    59d2:	f04f 0380 	mov.w	r3, #128	; 0x80
    59d6:	f383 8811 	msr	BASEPRI, r3
    59da:	f3bf 8f6f 	isb	sy
    59de:	f3bf 8f4f 	dsb	sy
    59e2:	e7fe      	b.n	59e2 <xTimerGenericCommand+0x4a>
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    59e4:	2300      	movs	r3, #0
    59e6:	a901      	add	r1, sp, #4
    59e8:	4c05      	ldr	r4, [pc, #20]	; (5a00 <xTimerGenericCommand+0x68>)
    59ea:	47a0      	blx	r4
    59ec:	e7ef      	b.n	59ce <xTimerGenericCommand+0x36>
	BaseType_t          xReturn = pdFAIL;
    59ee:	2000      	movs	r0, #0
	return xReturn;
    59f0:	e7ed      	b.n	59ce <xTimerGenericCommand+0x36>
    59f2:	bf00      	nop
    59f4:	2000e4c0 	.word	0x2000e4c0
    59f8:	00005745 	.word	0x00005745
    59fc:	00004845 	.word	0x00004845
    5a00:	00004a6d 	.word	0x00004a6d

00005a04 <prvSampleTimeNow>:
{
    5a04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5a08:	b082      	sub	sp, #8
    5a0a:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
    5a0c:	4b23      	ldr	r3, [pc, #140]	; (5a9c <prvSampleTimeNow+0x98>)
    5a0e:	4798      	blx	r3
    5a10:	4607      	mov	r7, r0
	if (xTimeNow < xLastTime) {
    5a12:	4b23      	ldr	r3, [pc, #140]	; (5aa0 <prvSampleTimeNow+0x9c>)
    5a14:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    5a16:	4298      	cmp	r0, r3
    5a18:	d319      	bcc.n	5a4e <prvSampleTimeNow+0x4a>
		*pxTimerListsWereSwitched = pdFALSE;
    5a1a:	2300      	movs	r3, #0
    5a1c:	f8c8 3000 	str.w	r3, [r8]
	xLastTime = xTimeNow;
    5a20:	4b1f      	ldr	r3, [pc, #124]	; (5aa0 <prvSampleTimeNow+0x9c>)
    5a22:	635f      	str	r7, [r3, #52]	; 0x34
}
    5a24:	4638      	mov	r0, r7
    5a26:	b002      	add	sp, #8
    5a28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    5a2c:	2100      	movs	r1, #0
    5a2e:	9100      	str	r1, [sp, #0]
    5a30:	460b      	mov	r3, r1
    5a32:	4652      	mov	r2, sl
    5a34:	4620      	mov	r0, r4
    5a36:	4c1b      	ldr	r4, [pc, #108]	; (5aa4 <prvSampleTimeNow+0xa0>)
    5a38:	47a0      	blx	r4
				configASSERT(xResult);
    5a3a:	b950      	cbnz	r0, 5a52 <prvSampleTimeNow+0x4e>
    5a3c:	f04f 0380 	mov.w	r3, #128	; 0x80
    5a40:	f383 8811 	msr	BASEPRI, r3
    5a44:	f3bf 8f6f 	isb	sy
    5a48:	f3bf 8f4f 	dsb	sy
    5a4c:	e7fe      	b.n	5a4c <prvSampleTimeNow+0x48>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    5a4e:	4d14      	ldr	r5, [pc, #80]	; (5aa0 <prvSampleTimeNow+0x9c>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    5a50:	4e15      	ldr	r6, [pc, #84]	; (5aa8 <prvSampleTimeNow+0xa4>)
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    5a52:	686b      	ldr	r3, [r5, #4]
    5a54:	681a      	ldr	r2, [r3, #0]
    5a56:	b1c2      	cbz	r2, 5a8a <prvSampleTimeNow+0x86>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    5a58:	68db      	ldr	r3, [r3, #12]
    5a5a:	f8d3 a000 	ldr.w	sl, [r3]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    5a5e:	68dc      	ldr	r4, [r3, #12]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    5a60:	f104 0904 	add.w	r9, r4, #4
    5a64:	4648      	mov	r0, r9
    5a66:	47b0      	blx	r6
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    5a68:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5a6a:	4620      	mov	r0, r4
    5a6c:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    5a6e:	69e3      	ldr	r3, [r4, #28]
    5a70:	2b01      	cmp	r3, #1
    5a72:	d1ee      	bne.n	5a52 <prvSampleTimeNow+0x4e>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    5a74:	69a3      	ldr	r3, [r4, #24]
    5a76:	4453      	add	r3, sl
			if (xReloadTime > xNextExpireTime) {
    5a78:	459a      	cmp	sl, r3
    5a7a:	d2d7      	bcs.n	5a2c <prvSampleTimeNow+0x28>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    5a7c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    5a7e:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    5a80:	4649      	mov	r1, r9
    5a82:	6868      	ldr	r0, [r5, #4]
    5a84:	4b09      	ldr	r3, [pc, #36]	; (5aac <prvSampleTimeNow+0xa8>)
    5a86:	4798      	blx	r3
    5a88:	e7e3      	b.n	5a52 <prvSampleTimeNow+0x4e>
	pxCurrentTimerList  = pxOverflowTimerList;
    5a8a:	4a05      	ldr	r2, [pc, #20]	; (5aa0 <prvSampleTimeNow+0x9c>)
    5a8c:	6811      	ldr	r1, [r2, #0]
    5a8e:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    5a90:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    5a92:	2301      	movs	r3, #1
    5a94:	f8c8 3000 	str.w	r3, [r8]
    5a98:	e7c2      	b.n	5a20 <prvSampleTimeNow+0x1c>
    5a9a:	bf00      	nop
    5a9c:	0000516d 	.word	0x0000516d
    5aa0:	2000e4c0 	.word	0x2000e4c0
    5aa4:	00005999 	.word	0x00005999
    5aa8:	000040ad 	.word	0x000040ad
    5aac:	00004079 	.word	0x00004079

00005ab0 <prvTimerTask>:
{
    5ab0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5ab4:	b086      	sub	sp, #24
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    5ab6:	4c66      	ldr	r4, [pc, #408]	; (5c50 <prvTimerTask+0x1a0>)
			(void)xTaskResumeAll();
    5ab8:	4f66      	ldr	r7, [pc, #408]	; (5c54 <prvTimerTask+0x1a4>)
					portYIELD_WITHIN_API();
    5aba:	f8df 91b8 	ldr.w	r9, [pc, #440]	; 5c74 <prvTimerTask+0x1c4>
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    5abe:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 5c78 <prvTimerTask+0x1c8>
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    5ac2:	6863      	ldr	r3, [r4, #4]
	if (*pxListWasEmpty == pdFALSE) {
    5ac4:	681a      	ldr	r2, [r3, #0]
    5ac6:	b172      	cbz	r2, 5ae6 <prvTimerTask+0x36>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    5ac8:	68db      	ldr	r3, [r3, #12]
    5aca:	681d      	ldr	r5, [r3, #0]
	vTaskSuspendAll();
    5acc:	4b62      	ldr	r3, [pc, #392]	; (5c58 <prvTimerTask+0x1a8>)
    5ace:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    5ad0:	a803      	add	r0, sp, #12
    5ad2:	4b62      	ldr	r3, [pc, #392]	; (5c5c <prvTimerTask+0x1ac>)
    5ad4:	4798      	blx	r3
    5ad6:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    5ad8:	9b03      	ldr	r3, [sp, #12]
    5ada:	2b00      	cmp	r3, #0
    5adc:	d17b      	bne.n	5bd6 <prvTimerTask+0x126>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    5ade:	42a8      	cmp	r0, r5
    5ae0:	d24c      	bcs.n	5b7c <prvTimerTask+0xcc>
    5ae2:	2200      	movs	r2, #0
    5ae4:	e00e      	b.n	5b04 <prvTimerTask+0x54>
	vTaskSuspendAll();
    5ae6:	4b5c      	ldr	r3, [pc, #368]	; (5c58 <prvTimerTask+0x1a8>)
    5ae8:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    5aea:	a803      	add	r0, sp, #12
    5aec:	4b5b      	ldr	r3, [pc, #364]	; (5c5c <prvTimerTask+0x1ac>)
    5aee:	4798      	blx	r3
    5af0:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    5af2:	9b03      	ldr	r3, [sp, #12]
    5af4:	2b00      	cmp	r3, #0
    5af6:	d16e      	bne.n	5bd6 <prvTimerTask+0x126>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    5af8:	6823      	ldr	r3, [r4, #0]
    5afa:	681a      	ldr	r2, [r3, #0]
    5afc:	fab2 f282 	clz	r2, r2
    5b00:	0952      	lsrs	r2, r2, #5
    5b02:	2500      	movs	r5, #0
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    5b04:	1ba9      	subs	r1, r5, r6
    5b06:	68a0      	ldr	r0, [r4, #8]
    5b08:	4b55      	ldr	r3, [pc, #340]	; (5c60 <prvTimerTask+0x1b0>)
    5b0a:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    5b0c:	47b8      	blx	r7
    5b0e:	b938      	cbnz	r0, 5b20 <prvTimerTask+0x70>
					portYIELD_WITHIN_API();
    5b10:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    5b14:	f8c9 3000 	str.w	r3, [r9]
    5b18:	f3bf 8f4f 	dsb	sy
    5b1c:	f3bf 8f6f 	isb	sy
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    5b20:	4d50      	ldr	r5, [pc, #320]	; (5c64 <prvTimerTask+0x1b4>)
    5b22:	2300      	movs	r3, #0
    5b24:	461a      	mov	r2, r3
    5b26:	a903      	add	r1, sp, #12
    5b28:	68a0      	ldr	r0, [r4, #8]
    5b2a:	47a8      	blx	r5
    5b2c:	2800      	cmp	r0, #0
    5b2e:	d0c8      	beq.n	5ac2 <prvTimerTask+0x12>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    5b30:	9b03      	ldr	r3, [sp, #12]
    5b32:	2b00      	cmp	r3, #0
    5b34:	dbf5      	blt.n	5b22 <prvTimerTask+0x72>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    5b36:	9e05      	ldr	r6, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem)) == pdFALSE) {
    5b38:	6973      	ldr	r3, [r6, #20]
    5b3a:	b10b      	cbz	r3, 5b40 <prvTimerTask+0x90>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    5b3c:	1d30      	adds	r0, r6, #4
    5b3e:	47c0      	blx	r8
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    5b40:	a802      	add	r0, sp, #8
    5b42:	4b46      	ldr	r3, [pc, #280]	; (5c5c <prvTimerTask+0x1ac>)
    5b44:	4798      	blx	r3
			switch (xMessage.xMessageID) {
    5b46:	9b03      	ldr	r3, [sp, #12]
    5b48:	2b09      	cmp	r3, #9
    5b4a:	d8ea      	bhi.n	5b22 <prvTimerTask+0x72>
    5b4c:	a201      	add	r2, pc, #4	; (adr r2, 5b54 <prvTimerTask+0xa4>)
    5b4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5b52:	bf00      	nop
    5b54:	00005bdb 	.word	0x00005bdb
    5b58:	00005bdb 	.word	0x00005bdb
    5b5c:	00005bdb 	.word	0x00005bdb
    5b60:	00005b23 	.word	0x00005b23
    5b64:	00005c23 	.word	0x00005c23
    5b68:	00005c49 	.word	0x00005c49
    5b6c:	00005bdb 	.word	0x00005bdb
    5b70:	00005bdb 	.word	0x00005bdb
    5b74:	00005b23 	.word	0x00005b23
    5b78:	00005c23 	.word	0x00005c23
				(void)xTaskResumeAll();
    5b7c:	47b8      	blx	r7
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    5b7e:	6863      	ldr	r3, [r4, #4]
    5b80:	68db      	ldr	r3, [r3, #12]
    5b82:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    5b86:	f10a 0004 	add.w	r0, sl, #4
    5b8a:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    5b8c:	f8da 301c 	ldr.w	r3, [sl, #28]
    5b90:	2b01      	cmp	r3, #1
    5b92:	d004      	beq.n	5b9e <prvTimerTask+0xee>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    5b94:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
    5b98:	4650      	mov	r0, sl
    5b9a:	4798      	blx	r3
    5b9c:	e7c0      	b.n	5b20 <prvTimerTask+0x70>
		if (prvInsertTimerInActiveList(
    5b9e:	f8da 1018 	ldr.w	r1, [sl, #24]
    5ba2:	462b      	mov	r3, r5
    5ba4:	4632      	mov	r2, r6
    5ba6:	4429      	add	r1, r5
    5ba8:	4650      	mov	r0, sl
    5baa:	4e2f      	ldr	r6, [pc, #188]	; (5c68 <prvTimerTask+0x1b8>)
    5bac:	47b0      	blx	r6
    5bae:	2801      	cmp	r0, #1
    5bb0:	d1f0      	bne.n	5b94 <prvTimerTask+0xe4>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    5bb2:	2100      	movs	r1, #0
    5bb4:	9100      	str	r1, [sp, #0]
    5bb6:	460b      	mov	r3, r1
    5bb8:	462a      	mov	r2, r5
    5bba:	4650      	mov	r0, sl
    5bbc:	4d2b      	ldr	r5, [pc, #172]	; (5c6c <prvTimerTask+0x1bc>)
    5bbe:	47a8      	blx	r5
			configASSERT(xResult);
    5bc0:	2800      	cmp	r0, #0
    5bc2:	d1e7      	bne.n	5b94 <prvTimerTask+0xe4>
    5bc4:	f04f 0380 	mov.w	r3, #128	; 0x80
    5bc8:	f383 8811 	msr	BASEPRI, r3
    5bcc:	f3bf 8f6f 	isb	sy
    5bd0:	f3bf 8f4f 	dsb	sy
    5bd4:	e7fe      	b.n	5bd4 <prvTimerTask+0x124>
			(void)xTaskResumeAll();
    5bd6:	47b8      	blx	r7
    5bd8:	e7a2      	b.n	5b20 <prvTimerTask+0x70>
				                               xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks,
    5bda:	9d04      	ldr	r5, [sp, #16]
				if (prvInsertTimerInActiveList(pxTimer,
    5bdc:	69b1      	ldr	r1, [r6, #24]
    5bde:	462b      	mov	r3, r5
    5be0:	4602      	mov	r2, r0
    5be2:	4429      	add	r1, r5
    5be4:	4630      	mov	r0, r6
    5be6:	4d20      	ldr	r5, [pc, #128]	; (5c68 <prvTimerTask+0x1b8>)
    5be8:	47a8      	blx	r5
    5bea:	2801      	cmp	r0, #1
    5bec:	d198      	bne.n	5b20 <prvTimerTask+0x70>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    5bee:	6a73      	ldr	r3, [r6, #36]	; 0x24
    5bf0:	4630      	mov	r0, r6
    5bf2:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    5bf4:	69f3      	ldr	r3, [r6, #28]
    5bf6:	2b01      	cmp	r3, #1
    5bf8:	d192      	bne.n	5b20 <prvTimerTask+0x70>
						xResult = xTimerGenericCommand(pxTimer,
    5bfa:	69b2      	ldr	r2, [r6, #24]
    5bfc:	2100      	movs	r1, #0
    5bfe:	9100      	str	r1, [sp, #0]
    5c00:	460b      	mov	r3, r1
    5c02:	9804      	ldr	r0, [sp, #16]
    5c04:	4402      	add	r2, r0
    5c06:	4630      	mov	r0, r6
    5c08:	4d18      	ldr	r5, [pc, #96]	; (5c6c <prvTimerTask+0x1bc>)
    5c0a:	47a8      	blx	r5
						configASSERT(xResult);
    5c0c:	2800      	cmp	r0, #0
    5c0e:	d187      	bne.n	5b20 <prvTimerTask+0x70>
    5c10:	f04f 0380 	mov.w	r3, #128	; 0x80
    5c14:	f383 8811 	msr	BASEPRI, r3
    5c18:	f3bf 8f6f 	isb	sy
    5c1c:	f3bf 8f4f 	dsb	sy
    5c20:	e7fe      	b.n	5c20 <prvTimerTask+0x170>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    5c22:	9904      	ldr	r1, [sp, #16]
    5c24:	61b1      	str	r1, [r6, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    5c26:	b131      	cbz	r1, 5c36 <prvTimerTask+0x186>
				(void)prvInsertTimerInActiveList(
    5c28:	4603      	mov	r3, r0
    5c2a:	4602      	mov	r2, r0
    5c2c:	4401      	add	r1, r0
    5c2e:	4630      	mov	r0, r6
    5c30:	4d0d      	ldr	r5, [pc, #52]	; (5c68 <prvTimerTask+0x1b8>)
    5c32:	47a8      	blx	r5
    5c34:	e774      	b.n	5b20 <prvTimerTask+0x70>
    5c36:	f04f 0380 	mov.w	r3, #128	; 0x80
    5c3a:	f383 8811 	msr	BASEPRI, r3
    5c3e:	f3bf 8f6f 	isb	sy
    5c42:	f3bf 8f4f 	dsb	sy
    5c46:	e7fe      	b.n	5c46 <prvTimerTask+0x196>
				vPortFree(pxTimer);
    5c48:	4630      	mov	r0, r6
    5c4a:	4b09      	ldr	r3, [pc, #36]	; (5c70 <prvTimerTask+0x1c0>)
    5c4c:	4798      	blx	r3
    5c4e:	e767      	b.n	5b20 <prvTimerTask+0x70>
    5c50:	2000e4c0 	.word	0x2000e4c0
    5c54:	00005285 	.word	0x00005285
    5c58:	00005159 	.word	0x00005159
    5c5c:	00005a05 	.word	0x00005a05
    5c60:	00004e21 	.word	0x00004e21
    5c64:	00004c3d 	.word	0x00004c3d
    5c68:	0000589d 	.word	0x0000589d
    5c6c:	00005999 	.word	0x00005999
    5c70:	000044cd 	.word	0x000044cd
    5c74:	e000ed04 	.word	0xe000ed04
    5c78:	000040ad 	.word	0x000040ad

00005c7c <__libc_init_array>:
    5c7c:	b570      	push	{r4, r5, r6, lr}
    5c7e:	4e0d      	ldr	r6, [pc, #52]	; (5cb4 <__libc_init_array+0x38>)
    5c80:	4c0d      	ldr	r4, [pc, #52]	; (5cb8 <__libc_init_array+0x3c>)
    5c82:	1ba4      	subs	r4, r4, r6
    5c84:	10a4      	asrs	r4, r4, #2
    5c86:	2500      	movs	r5, #0
    5c88:	42a5      	cmp	r5, r4
    5c8a:	d109      	bne.n	5ca0 <__libc_init_array+0x24>
    5c8c:	4e0b      	ldr	r6, [pc, #44]	; (5cbc <__libc_init_array+0x40>)
    5c8e:	4c0c      	ldr	r4, [pc, #48]	; (5cc0 <__libc_init_array+0x44>)
    5c90:	f001 fad2 	bl	7238 <_init>
    5c94:	1ba4      	subs	r4, r4, r6
    5c96:	10a4      	asrs	r4, r4, #2
    5c98:	2500      	movs	r5, #0
    5c9a:	42a5      	cmp	r5, r4
    5c9c:	d105      	bne.n	5caa <__libc_init_array+0x2e>
    5c9e:	bd70      	pop	{r4, r5, r6, pc}
    5ca0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    5ca4:	4798      	blx	r3
    5ca6:	3501      	adds	r5, #1
    5ca8:	e7ee      	b.n	5c88 <__libc_init_array+0xc>
    5caa:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    5cae:	4798      	blx	r3
    5cb0:	3501      	adds	r5, #1
    5cb2:	e7f2      	b.n	5c9a <__libc_init_array+0x1e>
    5cb4:	00007244 	.word	0x00007244
    5cb8:	00007244 	.word	0x00007244
    5cbc:	00007244 	.word	0x00007244
    5cc0:	00007248 	.word	0x00007248

00005cc4 <memcpy>:
    5cc4:	b510      	push	{r4, lr}
    5cc6:	1e43      	subs	r3, r0, #1
    5cc8:	440a      	add	r2, r1
    5cca:	4291      	cmp	r1, r2
    5ccc:	d100      	bne.n	5cd0 <memcpy+0xc>
    5cce:	bd10      	pop	{r4, pc}
    5cd0:	f811 4b01 	ldrb.w	r4, [r1], #1
    5cd4:	f803 4f01 	strb.w	r4, [r3, #1]!
    5cd8:	e7f7      	b.n	5cca <memcpy+0x6>

00005cda <memset>:
    5cda:	4402      	add	r2, r0
    5cdc:	4603      	mov	r3, r0
    5cde:	4293      	cmp	r3, r2
    5ce0:	d100      	bne.n	5ce4 <memset+0xa>
    5ce2:	4770      	bx	lr
    5ce4:	f803 1b01 	strb.w	r1, [r3], #1
    5ce8:	e7f9      	b.n	5cde <memset+0x4>
	...

00005cec <iprintf>:
    5cec:	b40f      	push	{r0, r1, r2, r3}
    5cee:	4b0a      	ldr	r3, [pc, #40]	; (5d18 <iprintf+0x2c>)
    5cf0:	b513      	push	{r0, r1, r4, lr}
    5cf2:	681c      	ldr	r4, [r3, #0]
    5cf4:	b124      	cbz	r4, 5d00 <iprintf+0x14>
    5cf6:	69a3      	ldr	r3, [r4, #24]
    5cf8:	b913      	cbnz	r3, 5d00 <iprintf+0x14>
    5cfa:	4620      	mov	r0, r4
    5cfc:	f000 fa76 	bl	61ec <__sinit>
    5d00:	ab05      	add	r3, sp, #20
    5d02:	9a04      	ldr	r2, [sp, #16]
    5d04:	68a1      	ldr	r1, [r4, #8]
    5d06:	9301      	str	r3, [sp, #4]
    5d08:	4620      	mov	r0, r4
    5d0a:	f000 fc39 	bl	6580 <_vfiprintf_r>
    5d0e:	b002      	add	sp, #8
    5d10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    5d14:	b004      	add	sp, #16
    5d16:	4770      	bx	lr
    5d18:	2000000c 	.word	0x2000000c

00005d1c <setbuf>:
    5d1c:	2900      	cmp	r1, #0
    5d1e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    5d22:	bf0c      	ite	eq
    5d24:	2202      	moveq	r2, #2
    5d26:	2200      	movne	r2, #0
    5d28:	f000 b800 	b.w	5d2c <setvbuf>

00005d2c <setvbuf>:
    5d2c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    5d30:	461d      	mov	r5, r3
    5d32:	4b51      	ldr	r3, [pc, #324]	; (5e78 <setvbuf+0x14c>)
    5d34:	681e      	ldr	r6, [r3, #0]
    5d36:	4604      	mov	r4, r0
    5d38:	460f      	mov	r7, r1
    5d3a:	4690      	mov	r8, r2
    5d3c:	b126      	cbz	r6, 5d48 <setvbuf+0x1c>
    5d3e:	69b3      	ldr	r3, [r6, #24]
    5d40:	b913      	cbnz	r3, 5d48 <setvbuf+0x1c>
    5d42:	4630      	mov	r0, r6
    5d44:	f000 fa52 	bl	61ec <__sinit>
    5d48:	4b4c      	ldr	r3, [pc, #304]	; (5e7c <setvbuf+0x150>)
    5d4a:	429c      	cmp	r4, r3
    5d4c:	d152      	bne.n	5df4 <setvbuf+0xc8>
    5d4e:	6874      	ldr	r4, [r6, #4]
    5d50:	f1b8 0f02 	cmp.w	r8, #2
    5d54:	d006      	beq.n	5d64 <setvbuf+0x38>
    5d56:	f1b8 0f01 	cmp.w	r8, #1
    5d5a:	f200 8089 	bhi.w	5e70 <setvbuf+0x144>
    5d5e:	2d00      	cmp	r5, #0
    5d60:	f2c0 8086 	blt.w	5e70 <setvbuf+0x144>
    5d64:	4621      	mov	r1, r4
    5d66:	4630      	mov	r0, r6
    5d68:	f000 f9d6 	bl	6118 <_fflush_r>
    5d6c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    5d6e:	b141      	cbz	r1, 5d82 <setvbuf+0x56>
    5d70:	f104 0344 	add.w	r3, r4, #68	; 0x44
    5d74:	4299      	cmp	r1, r3
    5d76:	d002      	beq.n	5d7e <setvbuf+0x52>
    5d78:	4630      	mov	r0, r6
    5d7a:	f000 fb2d 	bl	63d8 <_free_r>
    5d7e:	2300      	movs	r3, #0
    5d80:	6363      	str	r3, [r4, #52]	; 0x34
    5d82:	2300      	movs	r3, #0
    5d84:	61a3      	str	r3, [r4, #24]
    5d86:	6063      	str	r3, [r4, #4]
    5d88:	89a3      	ldrh	r3, [r4, #12]
    5d8a:	061b      	lsls	r3, r3, #24
    5d8c:	d503      	bpl.n	5d96 <setvbuf+0x6a>
    5d8e:	6921      	ldr	r1, [r4, #16]
    5d90:	4630      	mov	r0, r6
    5d92:	f000 fb21 	bl	63d8 <_free_r>
    5d96:	89a3      	ldrh	r3, [r4, #12]
    5d98:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    5d9c:	f023 0303 	bic.w	r3, r3, #3
    5da0:	f1b8 0f02 	cmp.w	r8, #2
    5da4:	81a3      	strh	r3, [r4, #12]
    5da6:	d05d      	beq.n	5e64 <setvbuf+0x138>
    5da8:	ab01      	add	r3, sp, #4
    5daa:	466a      	mov	r2, sp
    5dac:	4621      	mov	r1, r4
    5dae:	4630      	mov	r0, r6
    5db0:	f000 faa6 	bl	6300 <__swhatbuf_r>
    5db4:	89a3      	ldrh	r3, [r4, #12]
    5db6:	4318      	orrs	r0, r3
    5db8:	81a0      	strh	r0, [r4, #12]
    5dba:	bb2d      	cbnz	r5, 5e08 <setvbuf+0xdc>
    5dbc:	9d00      	ldr	r5, [sp, #0]
    5dbe:	4628      	mov	r0, r5
    5dc0:	f000 fb02 	bl	63c8 <malloc>
    5dc4:	4607      	mov	r7, r0
    5dc6:	2800      	cmp	r0, #0
    5dc8:	d14e      	bne.n	5e68 <setvbuf+0x13c>
    5dca:	f8dd 9000 	ldr.w	r9, [sp]
    5dce:	45a9      	cmp	r9, r5
    5dd0:	d13c      	bne.n	5e4c <setvbuf+0x120>
    5dd2:	f04f 30ff 	mov.w	r0, #4294967295
    5dd6:	89a3      	ldrh	r3, [r4, #12]
    5dd8:	f043 0302 	orr.w	r3, r3, #2
    5ddc:	81a3      	strh	r3, [r4, #12]
    5dde:	2300      	movs	r3, #0
    5de0:	60a3      	str	r3, [r4, #8]
    5de2:	f104 0347 	add.w	r3, r4, #71	; 0x47
    5de6:	6023      	str	r3, [r4, #0]
    5de8:	6123      	str	r3, [r4, #16]
    5dea:	2301      	movs	r3, #1
    5dec:	6163      	str	r3, [r4, #20]
    5dee:	b003      	add	sp, #12
    5df0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5df4:	4b22      	ldr	r3, [pc, #136]	; (5e80 <setvbuf+0x154>)
    5df6:	429c      	cmp	r4, r3
    5df8:	d101      	bne.n	5dfe <setvbuf+0xd2>
    5dfa:	68b4      	ldr	r4, [r6, #8]
    5dfc:	e7a8      	b.n	5d50 <setvbuf+0x24>
    5dfe:	4b21      	ldr	r3, [pc, #132]	; (5e84 <setvbuf+0x158>)
    5e00:	429c      	cmp	r4, r3
    5e02:	bf08      	it	eq
    5e04:	68f4      	ldreq	r4, [r6, #12]
    5e06:	e7a3      	b.n	5d50 <setvbuf+0x24>
    5e08:	2f00      	cmp	r7, #0
    5e0a:	d0d8      	beq.n	5dbe <setvbuf+0x92>
    5e0c:	69b3      	ldr	r3, [r6, #24]
    5e0e:	b913      	cbnz	r3, 5e16 <setvbuf+0xea>
    5e10:	4630      	mov	r0, r6
    5e12:	f000 f9eb 	bl	61ec <__sinit>
    5e16:	f1b8 0f01 	cmp.w	r8, #1
    5e1a:	bf08      	it	eq
    5e1c:	89a3      	ldrheq	r3, [r4, #12]
    5e1e:	6027      	str	r7, [r4, #0]
    5e20:	bf04      	itt	eq
    5e22:	f043 0301 	orreq.w	r3, r3, #1
    5e26:	81a3      	strheq	r3, [r4, #12]
    5e28:	89a3      	ldrh	r3, [r4, #12]
    5e2a:	6127      	str	r7, [r4, #16]
    5e2c:	f013 0008 	ands.w	r0, r3, #8
    5e30:	6165      	str	r5, [r4, #20]
    5e32:	d01b      	beq.n	5e6c <setvbuf+0x140>
    5e34:	f013 0001 	ands.w	r0, r3, #1
    5e38:	bf18      	it	ne
    5e3a:	426d      	negne	r5, r5
    5e3c:	f04f 0300 	mov.w	r3, #0
    5e40:	bf1d      	ittte	ne
    5e42:	60a3      	strne	r3, [r4, #8]
    5e44:	61a5      	strne	r5, [r4, #24]
    5e46:	4618      	movne	r0, r3
    5e48:	60a5      	streq	r5, [r4, #8]
    5e4a:	e7d0      	b.n	5dee <setvbuf+0xc2>
    5e4c:	4648      	mov	r0, r9
    5e4e:	f000 fabb 	bl	63c8 <malloc>
    5e52:	4607      	mov	r7, r0
    5e54:	2800      	cmp	r0, #0
    5e56:	d0bc      	beq.n	5dd2 <setvbuf+0xa6>
    5e58:	89a3      	ldrh	r3, [r4, #12]
    5e5a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    5e5e:	81a3      	strh	r3, [r4, #12]
    5e60:	464d      	mov	r5, r9
    5e62:	e7d3      	b.n	5e0c <setvbuf+0xe0>
    5e64:	2000      	movs	r0, #0
    5e66:	e7b6      	b.n	5dd6 <setvbuf+0xaa>
    5e68:	46a9      	mov	r9, r5
    5e6a:	e7f5      	b.n	5e58 <setvbuf+0x12c>
    5e6c:	60a0      	str	r0, [r4, #8]
    5e6e:	e7be      	b.n	5dee <setvbuf+0xc2>
    5e70:	f04f 30ff 	mov.w	r0, #4294967295
    5e74:	e7bb      	b.n	5dee <setvbuf+0xc2>
    5e76:	bf00      	nop
    5e78:	2000000c 	.word	0x2000000c
    5e7c:	000071c4 	.word	0x000071c4
    5e80:	000071e4 	.word	0x000071e4
    5e84:	000071a4 	.word	0x000071a4

00005e88 <__swbuf_r>:
    5e88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5e8a:	460e      	mov	r6, r1
    5e8c:	4614      	mov	r4, r2
    5e8e:	4605      	mov	r5, r0
    5e90:	b118      	cbz	r0, 5e9a <__swbuf_r+0x12>
    5e92:	6983      	ldr	r3, [r0, #24]
    5e94:	b90b      	cbnz	r3, 5e9a <__swbuf_r+0x12>
    5e96:	f000 f9a9 	bl	61ec <__sinit>
    5e9a:	4b21      	ldr	r3, [pc, #132]	; (5f20 <__swbuf_r+0x98>)
    5e9c:	429c      	cmp	r4, r3
    5e9e:	d12a      	bne.n	5ef6 <__swbuf_r+0x6e>
    5ea0:	686c      	ldr	r4, [r5, #4]
    5ea2:	69a3      	ldr	r3, [r4, #24]
    5ea4:	60a3      	str	r3, [r4, #8]
    5ea6:	89a3      	ldrh	r3, [r4, #12]
    5ea8:	071a      	lsls	r2, r3, #28
    5eaa:	d52e      	bpl.n	5f0a <__swbuf_r+0x82>
    5eac:	6923      	ldr	r3, [r4, #16]
    5eae:	b363      	cbz	r3, 5f0a <__swbuf_r+0x82>
    5eb0:	6923      	ldr	r3, [r4, #16]
    5eb2:	6820      	ldr	r0, [r4, #0]
    5eb4:	1ac0      	subs	r0, r0, r3
    5eb6:	6963      	ldr	r3, [r4, #20]
    5eb8:	b2f6      	uxtb	r6, r6
    5eba:	4298      	cmp	r0, r3
    5ebc:	4637      	mov	r7, r6
    5ebe:	db04      	blt.n	5eca <__swbuf_r+0x42>
    5ec0:	4621      	mov	r1, r4
    5ec2:	4628      	mov	r0, r5
    5ec4:	f000 f928 	bl	6118 <_fflush_r>
    5ec8:	bb28      	cbnz	r0, 5f16 <__swbuf_r+0x8e>
    5eca:	68a3      	ldr	r3, [r4, #8]
    5ecc:	3b01      	subs	r3, #1
    5ece:	60a3      	str	r3, [r4, #8]
    5ed0:	6823      	ldr	r3, [r4, #0]
    5ed2:	1c5a      	adds	r2, r3, #1
    5ed4:	6022      	str	r2, [r4, #0]
    5ed6:	701e      	strb	r6, [r3, #0]
    5ed8:	6963      	ldr	r3, [r4, #20]
    5eda:	3001      	adds	r0, #1
    5edc:	4298      	cmp	r0, r3
    5ede:	d004      	beq.n	5eea <__swbuf_r+0x62>
    5ee0:	89a3      	ldrh	r3, [r4, #12]
    5ee2:	07db      	lsls	r3, r3, #31
    5ee4:	d519      	bpl.n	5f1a <__swbuf_r+0x92>
    5ee6:	2e0a      	cmp	r6, #10
    5ee8:	d117      	bne.n	5f1a <__swbuf_r+0x92>
    5eea:	4621      	mov	r1, r4
    5eec:	4628      	mov	r0, r5
    5eee:	f000 f913 	bl	6118 <_fflush_r>
    5ef2:	b190      	cbz	r0, 5f1a <__swbuf_r+0x92>
    5ef4:	e00f      	b.n	5f16 <__swbuf_r+0x8e>
    5ef6:	4b0b      	ldr	r3, [pc, #44]	; (5f24 <__swbuf_r+0x9c>)
    5ef8:	429c      	cmp	r4, r3
    5efa:	d101      	bne.n	5f00 <__swbuf_r+0x78>
    5efc:	68ac      	ldr	r4, [r5, #8]
    5efe:	e7d0      	b.n	5ea2 <__swbuf_r+0x1a>
    5f00:	4b09      	ldr	r3, [pc, #36]	; (5f28 <__swbuf_r+0xa0>)
    5f02:	429c      	cmp	r4, r3
    5f04:	bf08      	it	eq
    5f06:	68ec      	ldreq	r4, [r5, #12]
    5f08:	e7cb      	b.n	5ea2 <__swbuf_r+0x1a>
    5f0a:	4621      	mov	r1, r4
    5f0c:	4628      	mov	r0, r5
    5f0e:	f000 f80d 	bl	5f2c <__swsetup_r>
    5f12:	2800      	cmp	r0, #0
    5f14:	d0cc      	beq.n	5eb0 <__swbuf_r+0x28>
    5f16:	f04f 37ff 	mov.w	r7, #4294967295
    5f1a:	4638      	mov	r0, r7
    5f1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5f1e:	bf00      	nop
    5f20:	000071c4 	.word	0x000071c4
    5f24:	000071e4 	.word	0x000071e4
    5f28:	000071a4 	.word	0x000071a4

00005f2c <__swsetup_r>:
    5f2c:	4b32      	ldr	r3, [pc, #200]	; (5ff8 <__swsetup_r+0xcc>)
    5f2e:	b570      	push	{r4, r5, r6, lr}
    5f30:	681d      	ldr	r5, [r3, #0]
    5f32:	4606      	mov	r6, r0
    5f34:	460c      	mov	r4, r1
    5f36:	b125      	cbz	r5, 5f42 <__swsetup_r+0x16>
    5f38:	69ab      	ldr	r3, [r5, #24]
    5f3a:	b913      	cbnz	r3, 5f42 <__swsetup_r+0x16>
    5f3c:	4628      	mov	r0, r5
    5f3e:	f000 f955 	bl	61ec <__sinit>
    5f42:	4b2e      	ldr	r3, [pc, #184]	; (5ffc <__swsetup_r+0xd0>)
    5f44:	429c      	cmp	r4, r3
    5f46:	d10f      	bne.n	5f68 <__swsetup_r+0x3c>
    5f48:	686c      	ldr	r4, [r5, #4]
    5f4a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    5f4e:	b29a      	uxth	r2, r3
    5f50:	0715      	lsls	r5, r2, #28
    5f52:	d42c      	bmi.n	5fae <__swsetup_r+0x82>
    5f54:	06d0      	lsls	r0, r2, #27
    5f56:	d411      	bmi.n	5f7c <__swsetup_r+0x50>
    5f58:	2209      	movs	r2, #9
    5f5a:	6032      	str	r2, [r6, #0]
    5f5c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    5f60:	81a3      	strh	r3, [r4, #12]
    5f62:	f04f 30ff 	mov.w	r0, #4294967295
    5f66:	bd70      	pop	{r4, r5, r6, pc}
    5f68:	4b25      	ldr	r3, [pc, #148]	; (6000 <__swsetup_r+0xd4>)
    5f6a:	429c      	cmp	r4, r3
    5f6c:	d101      	bne.n	5f72 <__swsetup_r+0x46>
    5f6e:	68ac      	ldr	r4, [r5, #8]
    5f70:	e7eb      	b.n	5f4a <__swsetup_r+0x1e>
    5f72:	4b24      	ldr	r3, [pc, #144]	; (6004 <__swsetup_r+0xd8>)
    5f74:	429c      	cmp	r4, r3
    5f76:	bf08      	it	eq
    5f78:	68ec      	ldreq	r4, [r5, #12]
    5f7a:	e7e6      	b.n	5f4a <__swsetup_r+0x1e>
    5f7c:	0751      	lsls	r1, r2, #29
    5f7e:	d512      	bpl.n	5fa6 <__swsetup_r+0x7a>
    5f80:	6b61      	ldr	r1, [r4, #52]	; 0x34
    5f82:	b141      	cbz	r1, 5f96 <__swsetup_r+0x6a>
    5f84:	f104 0344 	add.w	r3, r4, #68	; 0x44
    5f88:	4299      	cmp	r1, r3
    5f8a:	d002      	beq.n	5f92 <__swsetup_r+0x66>
    5f8c:	4630      	mov	r0, r6
    5f8e:	f000 fa23 	bl	63d8 <_free_r>
    5f92:	2300      	movs	r3, #0
    5f94:	6363      	str	r3, [r4, #52]	; 0x34
    5f96:	89a3      	ldrh	r3, [r4, #12]
    5f98:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    5f9c:	81a3      	strh	r3, [r4, #12]
    5f9e:	2300      	movs	r3, #0
    5fa0:	6063      	str	r3, [r4, #4]
    5fa2:	6923      	ldr	r3, [r4, #16]
    5fa4:	6023      	str	r3, [r4, #0]
    5fa6:	89a3      	ldrh	r3, [r4, #12]
    5fa8:	f043 0308 	orr.w	r3, r3, #8
    5fac:	81a3      	strh	r3, [r4, #12]
    5fae:	6923      	ldr	r3, [r4, #16]
    5fb0:	b94b      	cbnz	r3, 5fc6 <__swsetup_r+0x9a>
    5fb2:	89a3      	ldrh	r3, [r4, #12]
    5fb4:	f403 7320 	and.w	r3, r3, #640	; 0x280
    5fb8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    5fbc:	d003      	beq.n	5fc6 <__swsetup_r+0x9a>
    5fbe:	4621      	mov	r1, r4
    5fc0:	4630      	mov	r0, r6
    5fc2:	f000 f9c1 	bl	6348 <__smakebuf_r>
    5fc6:	89a2      	ldrh	r2, [r4, #12]
    5fc8:	f012 0301 	ands.w	r3, r2, #1
    5fcc:	d00c      	beq.n	5fe8 <__swsetup_r+0xbc>
    5fce:	2300      	movs	r3, #0
    5fd0:	60a3      	str	r3, [r4, #8]
    5fd2:	6963      	ldr	r3, [r4, #20]
    5fd4:	425b      	negs	r3, r3
    5fd6:	61a3      	str	r3, [r4, #24]
    5fd8:	6923      	ldr	r3, [r4, #16]
    5fda:	b953      	cbnz	r3, 5ff2 <__swsetup_r+0xc6>
    5fdc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    5fe0:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    5fe4:	d1ba      	bne.n	5f5c <__swsetup_r+0x30>
    5fe6:	bd70      	pop	{r4, r5, r6, pc}
    5fe8:	0792      	lsls	r2, r2, #30
    5fea:	bf58      	it	pl
    5fec:	6963      	ldrpl	r3, [r4, #20]
    5fee:	60a3      	str	r3, [r4, #8]
    5ff0:	e7f2      	b.n	5fd8 <__swsetup_r+0xac>
    5ff2:	2000      	movs	r0, #0
    5ff4:	e7f7      	b.n	5fe6 <__swsetup_r+0xba>
    5ff6:	bf00      	nop
    5ff8:	2000000c 	.word	0x2000000c
    5ffc:	000071c4 	.word	0x000071c4
    6000:	000071e4 	.word	0x000071e4
    6004:	000071a4 	.word	0x000071a4

00006008 <__sflush_r>:
    6008:	898a      	ldrh	r2, [r1, #12]
    600a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    600e:	4605      	mov	r5, r0
    6010:	0710      	lsls	r0, r2, #28
    6012:	460c      	mov	r4, r1
    6014:	d45a      	bmi.n	60cc <__sflush_r+0xc4>
    6016:	684b      	ldr	r3, [r1, #4]
    6018:	2b00      	cmp	r3, #0
    601a:	dc05      	bgt.n	6028 <__sflush_r+0x20>
    601c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    601e:	2b00      	cmp	r3, #0
    6020:	dc02      	bgt.n	6028 <__sflush_r+0x20>
    6022:	2000      	movs	r0, #0
    6024:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6028:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    602a:	2e00      	cmp	r6, #0
    602c:	d0f9      	beq.n	6022 <__sflush_r+0x1a>
    602e:	2300      	movs	r3, #0
    6030:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    6034:	682f      	ldr	r7, [r5, #0]
    6036:	602b      	str	r3, [r5, #0]
    6038:	d033      	beq.n	60a2 <__sflush_r+0x9a>
    603a:	6d60      	ldr	r0, [r4, #84]	; 0x54
    603c:	89a3      	ldrh	r3, [r4, #12]
    603e:	075a      	lsls	r2, r3, #29
    6040:	d505      	bpl.n	604e <__sflush_r+0x46>
    6042:	6863      	ldr	r3, [r4, #4]
    6044:	1ac0      	subs	r0, r0, r3
    6046:	6b63      	ldr	r3, [r4, #52]	; 0x34
    6048:	b10b      	cbz	r3, 604e <__sflush_r+0x46>
    604a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    604c:	1ac0      	subs	r0, r0, r3
    604e:	2300      	movs	r3, #0
    6050:	4602      	mov	r2, r0
    6052:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    6054:	6a21      	ldr	r1, [r4, #32]
    6056:	4628      	mov	r0, r5
    6058:	47b0      	blx	r6
    605a:	1c43      	adds	r3, r0, #1
    605c:	89a3      	ldrh	r3, [r4, #12]
    605e:	d106      	bne.n	606e <__sflush_r+0x66>
    6060:	6829      	ldr	r1, [r5, #0]
    6062:	291d      	cmp	r1, #29
    6064:	d84b      	bhi.n	60fe <__sflush_r+0xf6>
    6066:	4a2b      	ldr	r2, [pc, #172]	; (6114 <__sflush_r+0x10c>)
    6068:	40ca      	lsrs	r2, r1
    606a:	07d6      	lsls	r6, r2, #31
    606c:	d547      	bpl.n	60fe <__sflush_r+0xf6>
    606e:	2200      	movs	r2, #0
    6070:	6062      	str	r2, [r4, #4]
    6072:	04d9      	lsls	r1, r3, #19
    6074:	6922      	ldr	r2, [r4, #16]
    6076:	6022      	str	r2, [r4, #0]
    6078:	d504      	bpl.n	6084 <__sflush_r+0x7c>
    607a:	1c42      	adds	r2, r0, #1
    607c:	d101      	bne.n	6082 <__sflush_r+0x7a>
    607e:	682b      	ldr	r3, [r5, #0]
    6080:	b903      	cbnz	r3, 6084 <__sflush_r+0x7c>
    6082:	6560      	str	r0, [r4, #84]	; 0x54
    6084:	6b61      	ldr	r1, [r4, #52]	; 0x34
    6086:	602f      	str	r7, [r5, #0]
    6088:	2900      	cmp	r1, #0
    608a:	d0ca      	beq.n	6022 <__sflush_r+0x1a>
    608c:	f104 0344 	add.w	r3, r4, #68	; 0x44
    6090:	4299      	cmp	r1, r3
    6092:	d002      	beq.n	609a <__sflush_r+0x92>
    6094:	4628      	mov	r0, r5
    6096:	f000 f99f 	bl	63d8 <_free_r>
    609a:	2000      	movs	r0, #0
    609c:	6360      	str	r0, [r4, #52]	; 0x34
    609e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    60a2:	6a21      	ldr	r1, [r4, #32]
    60a4:	2301      	movs	r3, #1
    60a6:	4628      	mov	r0, r5
    60a8:	47b0      	blx	r6
    60aa:	1c41      	adds	r1, r0, #1
    60ac:	d1c6      	bne.n	603c <__sflush_r+0x34>
    60ae:	682b      	ldr	r3, [r5, #0]
    60b0:	2b00      	cmp	r3, #0
    60b2:	d0c3      	beq.n	603c <__sflush_r+0x34>
    60b4:	2b1d      	cmp	r3, #29
    60b6:	d001      	beq.n	60bc <__sflush_r+0xb4>
    60b8:	2b16      	cmp	r3, #22
    60ba:	d101      	bne.n	60c0 <__sflush_r+0xb8>
    60bc:	602f      	str	r7, [r5, #0]
    60be:	e7b0      	b.n	6022 <__sflush_r+0x1a>
    60c0:	89a3      	ldrh	r3, [r4, #12]
    60c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    60c6:	81a3      	strh	r3, [r4, #12]
    60c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    60cc:	690f      	ldr	r7, [r1, #16]
    60ce:	2f00      	cmp	r7, #0
    60d0:	d0a7      	beq.n	6022 <__sflush_r+0x1a>
    60d2:	0793      	lsls	r3, r2, #30
    60d4:	680e      	ldr	r6, [r1, #0]
    60d6:	bf08      	it	eq
    60d8:	694b      	ldreq	r3, [r1, #20]
    60da:	600f      	str	r7, [r1, #0]
    60dc:	bf18      	it	ne
    60de:	2300      	movne	r3, #0
    60e0:	eba6 0807 	sub.w	r8, r6, r7
    60e4:	608b      	str	r3, [r1, #8]
    60e6:	f1b8 0f00 	cmp.w	r8, #0
    60ea:	dd9a      	ble.n	6022 <__sflush_r+0x1a>
    60ec:	4643      	mov	r3, r8
    60ee:	463a      	mov	r2, r7
    60f0:	6a21      	ldr	r1, [r4, #32]
    60f2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    60f4:	4628      	mov	r0, r5
    60f6:	47b0      	blx	r6
    60f8:	2800      	cmp	r0, #0
    60fa:	dc07      	bgt.n	610c <__sflush_r+0x104>
    60fc:	89a3      	ldrh	r3, [r4, #12]
    60fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6102:	81a3      	strh	r3, [r4, #12]
    6104:	f04f 30ff 	mov.w	r0, #4294967295
    6108:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    610c:	4407      	add	r7, r0
    610e:	eba8 0800 	sub.w	r8, r8, r0
    6112:	e7e8      	b.n	60e6 <__sflush_r+0xde>
    6114:	20400001 	.word	0x20400001

00006118 <_fflush_r>:
    6118:	b538      	push	{r3, r4, r5, lr}
    611a:	690b      	ldr	r3, [r1, #16]
    611c:	4605      	mov	r5, r0
    611e:	460c      	mov	r4, r1
    6120:	b1db      	cbz	r3, 615a <_fflush_r+0x42>
    6122:	b118      	cbz	r0, 612c <_fflush_r+0x14>
    6124:	6983      	ldr	r3, [r0, #24]
    6126:	b90b      	cbnz	r3, 612c <_fflush_r+0x14>
    6128:	f000 f860 	bl	61ec <__sinit>
    612c:	4b0c      	ldr	r3, [pc, #48]	; (6160 <_fflush_r+0x48>)
    612e:	429c      	cmp	r4, r3
    6130:	d109      	bne.n	6146 <_fflush_r+0x2e>
    6132:	686c      	ldr	r4, [r5, #4]
    6134:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    6138:	b17b      	cbz	r3, 615a <_fflush_r+0x42>
    613a:	4621      	mov	r1, r4
    613c:	4628      	mov	r0, r5
    613e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6142:	f7ff bf61 	b.w	6008 <__sflush_r>
    6146:	4b07      	ldr	r3, [pc, #28]	; (6164 <_fflush_r+0x4c>)
    6148:	429c      	cmp	r4, r3
    614a:	d101      	bne.n	6150 <_fflush_r+0x38>
    614c:	68ac      	ldr	r4, [r5, #8]
    614e:	e7f1      	b.n	6134 <_fflush_r+0x1c>
    6150:	4b05      	ldr	r3, [pc, #20]	; (6168 <_fflush_r+0x50>)
    6152:	429c      	cmp	r4, r3
    6154:	bf08      	it	eq
    6156:	68ec      	ldreq	r4, [r5, #12]
    6158:	e7ec      	b.n	6134 <_fflush_r+0x1c>
    615a:	2000      	movs	r0, #0
    615c:	bd38      	pop	{r3, r4, r5, pc}
    615e:	bf00      	nop
    6160:	000071c4 	.word	0x000071c4
    6164:	000071e4 	.word	0x000071e4
    6168:	000071a4 	.word	0x000071a4

0000616c <_cleanup_r>:
    616c:	4901      	ldr	r1, [pc, #4]	; (6174 <_cleanup_r+0x8>)
    616e:	f000 b8a9 	b.w	62c4 <_fwalk_reent>
    6172:	bf00      	nop
    6174:	00006119 	.word	0x00006119

00006178 <std.isra.0>:
    6178:	2300      	movs	r3, #0
    617a:	b510      	push	{r4, lr}
    617c:	4604      	mov	r4, r0
    617e:	6003      	str	r3, [r0, #0]
    6180:	6043      	str	r3, [r0, #4]
    6182:	6083      	str	r3, [r0, #8]
    6184:	8181      	strh	r1, [r0, #12]
    6186:	6643      	str	r3, [r0, #100]	; 0x64
    6188:	81c2      	strh	r2, [r0, #14]
    618a:	6103      	str	r3, [r0, #16]
    618c:	6143      	str	r3, [r0, #20]
    618e:	6183      	str	r3, [r0, #24]
    6190:	4619      	mov	r1, r3
    6192:	2208      	movs	r2, #8
    6194:	305c      	adds	r0, #92	; 0x5c
    6196:	f7ff fda0 	bl	5cda <memset>
    619a:	4b05      	ldr	r3, [pc, #20]	; (61b0 <std.isra.0+0x38>)
    619c:	6263      	str	r3, [r4, #36]	; 0x24
    619e:	4b05      	ldr	r3, [pc, #20]	; (61b4 <std.isra.0+0x3c>)
    61a0:	62a3      	str	r3, [r4, #40]	; 0x28
    61a2:	4b05      	ldr	r3, [pc, #20]	; (61b8 <std.isra.0+0x40>)
    61a4:	62e3      	str	r3, [r4, #44]	; 0x2c
    61a6:	4b05      	ldr	r3, [pc, #20]	; (61bc <std.isra.0+0x44>)
    61a8:	6224      	str	r4, [r4, #32]
    61aa:	6323      	str	r3, [r4, #48]	; 0x30
    61ac:	bd10      	pop	{r4, pc}
    61ae:	bf00      	nop
    61b0:	00006af9 	.word	0x00006af9
    61b4:	00006b1b 	.word	0x00006b1b
    61b8:	00006b53 	.word	0x00006b53
    61bc:	00006b77 	.word	0x00006b77

000061c0 <__sfmoreglue>:
    61c0:	b570      	push	{r4, r5, r6, lr}
    61c2:	1e4a      	subs	r2, r1, #1
    61c4:	2568      	movs	r5, #104	; 0x68
    61c6:	4355      	muls	r5, r2
    61c8:	460e      	mov	r6, r1
    61ca:	f105 0174 	add.w	r1, r5, #116	; 0x74
    61ce:	f000 f951 	bl	6474 <_malloc_r>
    61d2:	4604      	mov	r4, r0
    61d4:	b140      	cbz	r0, 61e8 <__sfmoreglue+0x28>
    61d6:	2100      	movs	r1, #0
    61d8:	e880 0042 	stmia.w	r0, {r1, r6}
    61dc:	300c      	adds	r0, #12
    61de:	60a0      	str	r0, [r4, #8]
    61e0:	f105 0268 	add.w	r2, r5, #104	; 0x68
    61e4:	f7ff fd79 	bl	5cda <memset>
    61e8:	4620      	mov	r0, r4
    61ea:	bd70      	pop	{r4, r5, r6, pc}

000061ec <__sinit>:
    61ec:	6983      	ldr	r3, [r0, #24]
    61ee:	b510      	push	{r4, lr}
    61f0:	4604      	mov	r4, r0
    61f2:	bb33      	cbnz	r3, 6242 <__sinit+0x56>
    61f4:	6483      	str	r3, [r0, #72]	; 0x48
    61f6:	64c3      	str	r3, [r0, #76]	; 0x4c
    61f8:	6503      	str	r3, [r0, #80]	; 0x50
    61fa:	4b12      	ldr	r3, [pc, #72]	; (6244 <__sinit+0x58>)
    61fc:	4a12      	ldr	r2, [pc, #72]	; (6248 <__sinit+0x5c>)
    61fe:	681b      	ldr	r3, [r3, #0]
    6200:	6282      	str	r2, [r0, #40]	; 0x28
    6202:	4298      	cmp	r0, r3
    6204:	bf04      	itt	eq
    6206:	2301      	moveq	r3, #1
    6208:	6183      	streq	r3, [r0, #24]
    620a:	f000 f81f 	bl	624c <__sfp>
    620e:	6060      	str	r0, [r4, #4]
    6210:	4620      	mov	r0, r4
    6212:	f000 f81b 	bl	624c <__sfp>
    6216:	60a0      	str	r0, [r4, #8]
    6218:	4620      	mov	r0, r4
    621a:	f000 f817 	bl	624c <__sfp>
    621e:	2200      	movs	r2, #0
    6220:	60e0      	str	r0, [r4, #12]
    6222:	2104      	movs	r1, #4
    6224:	6860      	ldr	r0, [r4, #4]
    6226:	f7ff ffa7 	bl	6178 <std.isra.0>
    622a:	2201      	movs	r2, #1
    622c:	2109      	movs	r1, #9
    622e:	68a0      	ldr	r0, [r4, #8]
    6230:	f7ff ffa2 	bl	6178 <std.isra.0>
    6234:	2202      	movs	r2, #2
    6236:	2112      	movs	r1, #18
    6238:	68e0      	ldr	r0, [r4, #12]
    623a:	f7ff ff9d 	bl	6178 <std.isra.0>
    623e:	2301      	movs	r3, #1
    6240:	61a3      	str	r3, [r4, #24]
    6242:	bd10      	pop	{r4, pc}
    6244:	000071a0 	.word	0x000071a0
    6248:	0000616d 	.word	0x0000616d

0000624c <__sfp>:
    624c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    624e:	4b1c      	ldr	r3, [pc, #112]	; (62c0 <__sfp+0x74>)
    6250:	681e      	ldr	r6, [r3, #0]
    6252:	69b3      	ldr	r3, [r6, #24]
    6254:	4607      	mov	r7, r0
    6256:	b913      	cbnz	r3, 625e <__sfp+0x12>
    6258:	4630      	mov	r0, r6
    625a:	f7ff ffc7 	bl	61ec <__sinit>
    625e:	3648      	adds	r6, #72	; 0x48
    6260:	68b4      	ldr	r4, [r6, #8]
    6262:	6873      	ldr	r3, [r6, #4]
    6264:	3b01      	subs	r3, #1
    6266:	d503      	bpl.n	6270 <__sfp+0x24>
    6268:	6833      	ldr	r3, [r6, #0]
    626a:	b133      	cbz	r3, 627a <__sfp+0x2e>
    626c:	6836      	ldr	r6, [r6, #0]
    626e:	e7f7      	b.n	6260 <__sfp+0x14>
    6270:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    6274:	b16d      	cbz	r5, 6292 <__sfp+0x46>
    6276:	3468      	adds	r4, #104	; 0x68
    6278:	e7f4      	b.n	6264 <__sfp+0x18>
    627a:	2104      	movs	r1, #4
    627c:	4638      	mov	r0, r7
    627e:	f7ff ff9f 	bl	61c0 <__sfmoreglue>
    6282:	6030      	str	r0, [r6, #0]
    6284:	2800      	cmp	r0, #0
    6286:	d1f1      	bne.n	626c <__sfp+0x20>
    6288:	230c      	movs	r3, #12
    628a:	603b      	str	r3, [r7, #0]
    628c:	4604      	mov	r4, r0
    628e:	4620      	mov	r0, r4
    6290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6292:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6296:	81e3      	strh	r3, [r4, #14]
    6298:	2301      	movs	r3, #1
    629a:	81a3      	strh	r3, [r4, #12]
    629c:	6665      	str	r5, [r4, #100]	; 0x64
    629e:	6025      	str	r5, [r4, #0]
    62a0:	60a5      	str	r5, [r4, #8]
    62a2:	6065      	str	r5, [r4, #4]
    62a4:	6125      	str	r5, [r4, #16]
    62a6:	6165      	str	r5, [r4, #20]
    62a8:	61a5      	str	r5, [r4, #24]
    62aa:	2208      	movs	r2, #8
    62ac:	4629      	mov	r1, r5
    62ae:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    62b2:	f7ff fd12 	bl	5cda <memset>
    62b6:	6365      	str	r5, [r4, #52]	; 0x34
    62b8:	63a5      	str	r5, [r4, #56]	; 0x38
    62ba:	64a5      	str	r5, [r4, #72]	; 0x48
    62bc:	64e5      	str	r5, [r4, #76]	; 0x4c
    62be:	e7e6      	b.n	628e <__sfp+0x42>
    62c0:	000071a0 	.word	0x000071a0

000062c4 <_fwalk_reent>:
    62c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    62c8:	4680      	mov	r8, r0
    62ca:	4689      	mov	r9, r1
    62cc:	f100 0448 	add.w	r4, r0, #72	; 0x48
    62d0:	2600      	movs	r6, #0
    62d2:	b914      	cbnz	r4, 62da <_fwalk_reent+0x16>
    62d4:	4630      	mov	r0, r6
    62d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    62da:	68a5      	ldr	r5, [r4, #8]
    62dc:	6867      	ldr	r7, [r4, #4]
    62de:	3f01      	subs	r7, #1
    62e0:	d501      	bpl.n	62e6 <_fwalk_reent+0x22>
    62e2:	6824      	ldr	r4, [r4, #0]
    62e4:	e7f5      	b.n	62d2 <_fwalk_reent+0xe>
    62e6:	89ab      	ldrh	r3, [r5, #12]
    62e8:	2b01      	cmp	r3, #1
    62ea:	d907      	bls.n	62fc <_fwalk_reent+0x38>
    62ec:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    62f0:	3301      	adds	r3, #1
    62f2:	d003      	beq.n	62fc <_fwalk_reent+0x38>
    62f4:	4629      	mov	r1, r5
    62f6:	4640      	mov	r0, r8
    62f8:	47c8      	blx	r9
    62fa:	4306      	orrs	r6, r0
    62fc:	3568      	adds	r5, #104	; 0x68
    62fe:	e7ee      	b.n	62de <_fwalk_reent+0x1a>

00006300 <__swhatbuf_r>:
    6300:	b570      	push	{r4, r5, r6, lr}
    6302:	460e      	mov	r6, r1
    6304:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    6308:	2900      	cmp	r1, #0
    630a:	b090      	sub	sp, #64	; 0x40
    630c:	4614      	mov	r4, r2
    630e:	461d      	mov	r5, r3
    6310:	da07      	bge.n	6322 <__swhatbuf_r+0x22>
    6312:	2300      	movs	r3, #0
    6314:	602b      	str	r3, [r5, #0]
    6316:	89b3      	ldrh	r3, [r6, #12]
    6318:	061a      	lsls	r2, r3, #24
    631a:	d410      	bmi.n	633e <__swhatbuf_r+0x3e>
    631c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    6320:	e00e      	b.n	6340 <__swhatbuf_r+0x40>
    6322:	aa01      	add	r2, sp, #4
    6324:	f000 fc4e 	bl	6bc4 <_fstat_r>
    6328:	2800      	cmp	r0, #0
    632a:	dbf2      	blt.n	6312 <__swhatbuf_r+0x12>
    632c:	9a02      	ldr	r2, [sp, #8]
    632e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    6332:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    6336:	425a      	negs	r2, r3
    6338:	415a      	adcs	r2, r3
    633a:	602a      	str	r2, [r5, #0]
    633c:	e7ee      	b.n	631c <__swhatbuf_r+0x1c>
    633e:	2340      	movs	r3, #64	; 0x40
    6340:	2000      	movs	r0, #0
    6342:	6023      	str	r3, [r4, #0]
    6344:	b010      	add	sp, #64	; 0x40
    6346:	bd70      	pop	{r4, r5, r6, pc}

00006348 <__smakebuf_r>:
    6348:	898b      	ldrh	r3, [r1, #12]
    634a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    634c:	079d      	lsls	r5, r3, #30
    634e:	4606      	mov	r6, r0
    6350:	460c      	mov	r4, r1
    6352:	d507      	bpl.n	6364 <__smakebuf_r+0x1c>
    6354:	f104 0347 	add.w	r3, r4, #71	; 0x47
    6358:	6023      	str	r3, [r4, #0]
    635a:	6123      	str	r3, [r4, #16]
    635c:	2301      	movs	r3, #1
    635e:	6163      	str	r3, [r4, #20]
    6360:	b002      	add	sp, #8
    6362:	bd70      	pop	{r4, r5, r6, pc}
    6364:	ab01      	add	r3, sp, #4
    6366:	466a      	mov	r2, sp
    6368:	f7ff ffca 	bl	6300 <__swhatbuf_r>
    636c:	9900      	ldr	r1, [sp, #0]
    636e:	4605      	mov	r5, r0
    6370:	4630      	mov	r0, r6
    6372:	f000 f87f 	bl	6474 <_malloc_r>
    6376:	b948      	cbnz	r0, 638c <__smakebuf_r+0x44>
    6378:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    637c:	059a      	lsls	r2, r3, #22
    637e:	d4ef      	bmi.n	6360 <__smakebuf_r+0x18>
    6380:	f023 0303 	bic.w	r3, r3, #3
    6384:	f043 0302 	orr.w	r3, r3, #2
    6388:	81a3      	strh	r3, [r4, #12]
    638a:	e7e3      	b.n	6354 <__smakebuf_r+0xc>
    638c:	4b0d      	ldr	r3, [pc, #52]	; (63c4 <__smakebuf_r+0x7c>)
    638e:	62b3      	str	r3, [r6, #40]	; 0x28
    6390:	89a3      	ldrh	r3, [r4, #12]
    6392:	6020      	str	r0, [r4, #0]
    6394:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    6398:	81a3      	strh	r3, [r4, #12]
    639a:	9b00      	ldr	r3, [sp, #0]
    639c:	6163      	str	r3, [r4, #20]
    639e:	9b01      	ldr	r3, [sp, #4]
    63a0:	6120      	str	r0, [r4, #16]
    63a2:	b15b      	cbz	r3, 63bc <__smakebuf_r+0x74>
    63a4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    63a8:	4630      	mov	r0, r6
    63aa:	f000 fc1d 	bl	6be8 <_isatty_r>
    63ae:	b128      	cbz	r0, 63bc <__smakebuf_r+0x74>
    63b0:	89a3      	ldrh	r3, [r4, #12]
    63b2:	f023 0303 	bic.w	r3, r3, #3
    63b6:	f043 0301 	orr.w	r3, r3, #1
    63ba:	81a3      	strh	r3, [r4, #12]
    63bc:	89a3      	ldrh	r3, [r4, #12]
    63be:	431d      	orrs	r5, r3
    63c0:	81a5      	strh	r5, [r4, #12]
    63c2:	e7cd      	b.n	6360 <__smakebuf_r+0x18>
    63c4:	0000616d 	.word	0x0000616d

000063c8 <malloc>:
    63c8:	4b02      	ldr	r3, [pc, #8]	; (63d4 <malloc+0xc>)
    63ca:	4601      	mov	r1, r0
    63cc:	6818      	ldr	r0, [r3, #0]
    63ce:	f000 b851 	b.w	6474 <_malloc_r>
    63d2:	bf00      	nop
    63d4:	2000000c 	.word	0x2000000c

000063d8 <_free_r>:
    63d8:	b538      	push	{r3, r4, r5, lr}
    63da:	4605      	mov	r5, r0
    63dc:	2900      	cmp	r1, #0
    63de:	d045      	beq.n	646c <_free_r+0x94>
    63e0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    63e4:	1f0c      	subs	r4, r1, #4
    63e6:	2b00      	cmp	r3, #0
    63e8:	bfb8      	it	lt
    63ea:	18e4      	addlt	r4, r4, r3
    63ec:	f000 fc70 	bl	6cd0 <__malloc_lock>
    63f0:	4a1f      	ldr	r2, [pc, #124]	; (6470 <_free_r+0x98>)
    63f2:	6813      	ldr	r3, [r2, #0]
    63f4:	4610      	mov	r0, r2
    63f6:	b933      	cbnz	r3, 6406 <_free_r+0x2e>
    63f8:	6063      	str	r3, [r4, #4]
    63fa:	6014      	str	r4, [r2, #0]
    63fc:	4628      	mov	r0, r5
    63fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6402:	f000 bc66 	b.w	6cd2 <__malloc_unlock>
    6406:	42a3      	cmp	r3, r4
    6408:	d90c      	bls.n	6424 <_free_r+0x4c>
    640a:	6821      	ldr	r1, [r4, #0]
    640c:	1862      	adds	r2, r4, r1
    640e:	4293      	cmp	r3, r2
    6410:	bf04      	itt	eq
    6412:	681a      	ldreq	r2, [r3, #0]
    6414:	685b      	ldreq	r3, [r3, #4]
    6416:	6063      	str	r3, [r4, #4]
    6418:	bf04      	itt	eq
    641a:	1852      	addeq	r2, r2, r1
    641c:	6022      	streq	r2, [r4, #0]
    641e:	6004      	str	r4, [r0, #0]
    6420:	e7ec      	b.n	63fc <_free_r+0x24>
    6422:	4613      	mov	r3, r2
    6424:	685a      	ldr	r2, [r3, #4]
    6426:	b10a      	cbz	r2, 642c <_free_r+0x54>
    6428:	42a2      	cmp	r2, r4
    642a:	d9fa      	bls.n	6422 <_free_r+0x4a>
    642c:	6819      	ldr	r1, [r3, #0]
    642e:	1858      	adds	r0, r3, r1
    6430:	42a0      	cmp	r0, r4
    6432:	d10b      	bne.n	644c <_free_r+0x74>
    6434:	6820      	ldr	r0, [r4, #0]
    6436:	4401      	add	r1, r0
    6438:	1858      	adds	r0, r3, r1
    643a:	4282      	cmp	r2, r0
    643c:	6019      	str	r1, [r3, #0]
    643e:	d1dd      	bne.n	63fc <_free_r+0x24>
    6440:	6810      	ldr	r0, [r2, #0]
    6442:	6852      	ldr	r2, [r2, #4]
    6444:	605a      	str	r2, [r3, #4]
    6446:	4401      	add	r1, r0
    6448:	6019      	str	r1, [r3, #0]
    644a:	e7d7      	b.n	63fc <_free_r+0x24>
    644c:	d902      	bls.n	6454 <_free_r+0x7c>
    644e:	230c      	movs	r3, #12
    6450:	602b      	str	r3, [r5, #0]
    6452:	e7d3      	b.n	63fc <_free_r+0x24>
    6454:	6820      	ldr	r0, [r4, #0]
    6456:	1821      	adds	r1, r4, r0
    6458:	428a      	cmp	r2, r1
    645a:	bf04      	itt	eq
    645c:	6811      	ldreq	r1, [r2, #0]
    645e:	6852      	ldreq	r2, [r2, #4]
    6460:	6062      	str	r2, [r4, #4]
    6462:	bf04      	itt	eq
    6464:	1809      	addeq	r1, r1, r0
    6466:	6021      	streq	r1, [r4, #0]
    6468:	605c      	str	r4, [r3, #4]
    646a:	e7c7      	b.n	63fc <_free_r+0x24>
    646c:	bd38      	pop	{r3, r4, r5, pc}
    646e:	bf00      	nop
    6470:	2000e4f8 	.word	0x2000e4f8

00006474 <_malloc_r>:
    6474:	b570      	push	{r4, r5, r6, lr}
    6476:	1ccd      	adds	r5, r1, #3
    6478:	f025 0503 	bic.w	r5, r5, #3
    647c:	3508      	adds	r5, #8
    647e:	2d0c      	cmp	r5, #12
    6480:	bf38      	it	cc
    6482:	250c      	movcc	r5, #12
    6484:	2d00      	cmp	r5, #0
    6486:	4606      	mov	r6, r0
    6488:	db01      	blt.n	648e <_malloc_r+0x1a>
    648a:	42a9      	cmp	r1, r5
    648c:	d903      	bls.n	6496 <_malloc_r+0x22>
    648e:	230c      	movs	r3, #12
    6490:	6033      	str	r3, [r6, #0]
    6492:	2000      	movs	r0, #0
    6494:	bd70      	pop	{r4, r5, r6, pc}
    6496:	f000 fc1b 	bl	6cd0 <__malloc_lock>
    649a:	4a23      	ldr	r2, [pc, #140]	; (6528 <_malloc_r+0xb4>)
    649c:	6814      	ldr	r4, [r2, #0]
    649e:	4621      	mov	r1, r4
    64a0:	b991      	cbnz	r1, 64c8 <_malloc_r+0x54>
    64a2:	4c22      	ldr	r4, [pc, #136]	; (652c <_malloc_r+0xb8>)
    64a4:	6823      	ldr	r3, [r4, #0]
    64a6:	b91b      	cbnz	r3, 64b0 <_malloc_r+0x3c>
    64a8:	4630      	mov	r0, r6
    64aa:	f000 fb15 	bl	6ad8 <_sbrk_r>
    64ae:	6020      	str	r0, [r4, #0]
    64b0:	4629      	mov	r1, r5
    64b2:	4630      	mov	r0, r6
    64b4:	f000 fb10 	bl	6ad8 <_sbrk_r>
    64b8:	1c43      	adds	r3, r0, #1
    64ba:	d126      	bne.n	650a <_malloc_r+0x96>
    64bc:	230c      	movs	r3, #12
    64be:	6033      	str	r3, [r6, #0]
    64c0:	4630      	mov	r0, r6
    64c2:	f000 fc06 	bl	6cd2 <__malloc_unlock>
    64c6:	e7e4      	b.n	6492 <_malloc_r+0x1e>
    64c8:	680b      	ldr	r3, [r1, #0]
    64ca:	1b5b      	subs	r3, r3, r5
    64cc:	d41a      	bmi.n	6504 <_malloc_r+0x90>
    64ce:	2b0b      	cmp	r3, #11
    64d0:	d90f      	bls.n	64f2 <_malloc_r+0x7e>
    64d2:	600b      	str	r3, [r1, #0]
    64d4:	50cd      	str	r5, [r1, r3]
    64d6:	18cc      	adds	r4, r1, r3
    64d8:	4630      	mov	r0, r6
    64da:	f000 fbfa 	bl	6cd2 <__malloc_unlock>
    64de:	f104 000b 	add.w	r0, r4, #11
    64e2:	1d23      	adds	r3, r4, #4
    64e4:	f020 0007 	bic.w	r0, r0, #7
    64e8:	1ac3      	subs	r3, r0, r3
    64ea:	d01b      	beq.n	6524 <_malloc_r+0xb0>
    64ec:	425a      	negs	r2, r3
    64ee:	50e2      	str	r2, [r4, r3]
    64f0:	bd70      	pop	{r4, r5, r6, pc}
    64f2:	428c      	cmp	r4, r1
    64f4:	bf0d      	iteet	eq
    64f6:	6863      	ldreq	r3, [r4, #4]
    64f8:	684b      	ldrne	r3, [r1, #4]
    64fa:	6063      	strne	r3, [r4, #4]
    64fc:	6013      	streq	r3, [r2, #0]
    64fe:	bf18      	it	ne
    6500:	460c      	movne	r4, r1
    6502:	e7e9      	b.n	64d8 <_malloc_r+0x64>
    6504:	460c      	mov	r4, r1
    6506:	6849      	ldr	r1, [r1, #4]
    6508:	e7ca      	b.n	64a0 <_malloc_r+0x2c>
    650a:	1cc4      	adds	r4, r0, #3
    650c:	f024 0403 	bic.w	r4, r4, #3
    6510:	42a0      	cmp	r0, r4
    6512:	d005      	beq.n	6520 <_malloc_r+0xac>
    6514:	1a21      	subs	r1, r4, r0
    6516:	4630      	mov	r0, r6
    6518:	f000 fade 	bl	6ad8 <_sbrk_r>
    651c:	3001      	adds	r0, #1
    651e:	d0cd      	beq.n	64bc <_malloc_r+0x48>
    6520:	6025      	str	r5, [r4, #0]
    6522:	e7d9      	b.n	64d8 <_malloc_r+0x64>
    6524:	bd70      	pop	{r4, r5, r6, pc}
    6526:	bf00      	nop
    6528:	2000e4f8 	.word	0x2000e4f8
    652c:	2000e4fc 	.word	0x2000e4fc

00006530 <__sfputc_r>:
    6530:	6893      	ldr	r3, [r2, #8]
    6532:	3b01      	subs	r3, #1
    6534:	2b00      	cmp	r3, #0
    6536:	b410      	push	{r4}
    6538:	6093      	str	r3, [r2, #8]
    653a:	da08      	bge.n	654e <__sfputc_r+0x1e>
    653c:	6994      	ldr	r4, [r2, #24]
    653e:	42a3      	cmp	r3, r4
    6540:	db02      	blt.n	6548 <__sfputc_r+0x18>
    6542:	b2cb      	uxtb	r3, r1
    6544:	2b0a      	cmp	r3, #10
    6546:	d102      	bne.n	654e <__sfputc_r+0x1e>
    6548:	bc10      	pop	{r4}
    654a:	f7ff bc9d 	b.w	5e88 <__swbuf_r>
    654e:	6813      	ldr	r3, [r2, #0]
    6550:	1c58      	adds	r0, r3, #1
    6552:	6010      	str	r0, [r2, #0]
    6554:	7019      	strb	r1, [r3, #0]
    6556:	b2c8      	uxtb	r0, r1
    6558:	bc10      	pop	{r4}
    655a:	4770      	bx	lr

0000655c <__sfputs_r>:
    655c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    655e:	4606      	mov	r6, r0
    6560:	460f      	mov	r7, r1
    6562:	4614      	mov	r4, r2
    6564:	18d5      	adds	r5, r2, r3
    6566:	42ac      	cmp	r4, r5
    6568:	d101      	bne.n	656e <__sfputs_r+0x12>
    656a:	2000      	movs	r0, #0
    656c:	e007      	b.n	657e <__sfputs_r+0x22>
    656e:	463a      	mov	r2, r7
    6570:	f814 1b01 	ldrb.w	r1, [r4], #1
    6574:	4630      	mov	r0, r6
    6576:	f7ff ffdb 	bl	6530 <__sfputc_r>
    657a:	1c43      	adds	r3, r0, #1
    657c:	d1f3      	bne.n	6566 <__sfputs_r+0xa>
    657e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00006580 <_vfiprintf_r>:
    6580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6584:	b09d      	sub	sp, #116	; 0x74
    6586:	460c      	mov	r4, r1
    6588:	4617      	mov	r7, r2
    658a:	9303      	str	r3, [sp, #12]
    658c:	4606      	mov	r6, r0
    658e:	b118      	cbz	r0, 6598 <_vfiprintf_r+0x18>
    6590:	6983      	ldr	r3, [r0, #24]
    6592:	b90b      	cbnz	r3, 6598 <_vfiprintf_r+0x18>
    6594:	f7ff fe2a 	bl	61ec <__sinit>
    6598:	4b7c      	ldr	r3, [pc, #496]	; (678c <_vfiprintf_r+0x20c>)
    659a:	429c      	cmp	r4, r3
    659c:	d157      	bne.n	664e <_vfiprintf_r+0xce>
    659e:	6874      	ldr	r4, [r6, #4]
    65a0:	89a3      	ldrh	r3, [r4, #12]
    65a2:	0718      	lsls	r0, r3, #28
    65a4:	d55d      	bpl.n	6662 <_vfiprintf_r+0xe2>
    65a6:	6923      	ldr	r3, [r4, #16]
    65a8:	2b00      	cmp	r3, #0
    65aa:	d05a      	beq.n	6662 <_vfiprintf_r+0xe2>
    65ac:	2300      	movs	r3, #0
    65ae:	9309      	str	r3, [sp, #36]	; 0x24
    65b0:	2320      	movs	r3, #32
    65b2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    65b6:	2330      	movs	r3, #48	; 0x30
    65b8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    65bc:	f04f 0b01 	mov.w	fp, #1
    65c0:	46b8      	mov	r8, r7
    65c2:	4645      	mov	r5, r8
    65c4:	f815 3b01 	ldrb.w	r3, [r5], #1
    65c8:	2b00      	cmp	r3, #0
    65ca:	d155      	bne.n	6678 <_vfiprintf_r+0xf8>
    65cc:	ebb8 0a07 	subs.w	sl, r8, r7
    65d0:	d00b      	beq.n	65ea <_vfiprintf_r+0x6a>
    65d2:	4653      	mov	r3, sl
    65d4:	463a      	mov	r2, r7
    65d6:	4621      	mov	r1, r4
    65d8:	4630      	mov	r0, r6
    65da:	f7ff ffbf 	bl	655c <__sfputs_r>
    65de:	3001      	adds	r0, #1
    65e0:	f000 80c4 	beq.w	676c <_vfiprintf_r+0x1ec>
    65e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    65e6:	4453      	add	r3, sl
    65e8:	9309      	str	r3, [sp, #36]	; 0x24
    65ea:	f898 3000 	ldrb.w	r3, [r8]
    65ee:	2b00      	cmp	r3, #0
    65f0:	f000 80bc 	beq.w	676c <_vfiprintf_r+0x1ec>
    65f4:	2300      	movs	r3, #0
    65f6:	f04f 32ff 	mov.w	r2, #4294967295
    65fa:	9304      	str	r3, [sp, #16]
    65fc:	9307      	str	r3, [sp, #28]
    65fe:	9205      	str	r2, [sp, #20]
    6600:	9306      	str	r3, [sp, #24]
    6602:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    6606:	931a      	str	r3, [sp, #104]	; 0x68
    6608:	2205      	movs	r2, #5
    660a:	7829      	ldrb	r1, [r5, #0]
    660c:	4860      	ldr	r0, [pc, #384]	; (6790 <_vfiprintf_r+0x210>)
    660e:	f000 fb0f 	bl	6c30 <memchr>
    6612:	f105 0801 	add.w	r8, r5, #1
    6616:	9b04      	ldr	r3, [sp, #16]
    6618:	2800      	cmp	r0, #0
    661a:	d131      	bne.n	6680 <_vfiprintf_r+0x100>
    661c:	06d9      	lsls	r1, r3, #27
    661e:	bf44      	itt	mi
    6620:	2220      	movmi	r2, #32
    6622:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    6626:	071a      	lsls	r2, r3, #28
    6628:	bf44      	itt	mi
    662a:	222b      	movmi	r2, #43	; 0x2b
    662c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    6630:	782a      	ldrb	r2, [r5, #0]
    6632:	2a2a      	cmp	r2, #42	; 0x2a
    6634:	d02c      	beq.n	6690 <_vfiprintf_r+0x110>
    6636:	9a07      	ldr	r2, [sp, #28]
    6638:	2100      	movs	r1, #0
    663a:	200a      	movs	r0, #10
    663c:	46a8      	mov	r8, r5
    663e:	3501      	adds	r5, #1
    6640:	f898 3000 	ldrb.w	r3, [r8]
    6644:	3b30      	subs	r3, #48	; 0x30
    6646:	2b09      	cmp	r3, #9
    6648:	d96d      	bls.n	6726 <_vfiprintf_r+0x1a6>
    664a:	b371      	cbz	r1, 66aa <_vfiprintf_r+0x12a>
    664c:	e026      	b.n	669c <_vfiprintf_r+0x11c>
    664e:	4b51      	ldr	r3, [pc, #324]	; (6794 <_vfiprintf_r+0x214>)
    6650:	429c      	cmp	r4, r3
    6652:	d101      	bne.n	6658 <_vfiprintf_r+0xd8>
    6654:	68b4      	ldr	r4, [r6, #8]
    6656:	e7a3      	b.n	65a0 <_vfiprintf_r+0x20>
    6658:	4b4f      	ldr	r3, [pc, #316]	; (6798 <_vfiprintf_r+0x218>)
    665a:	429c      	cmp	r4, r3
    665c:	bf08      	it	eq
    665e:	68f4      	ldreq	r4, [r6, #12]
    6660:	e79e      	b.n	65a0 <_vfiprintf_r+0x20>
    6662:	4621      	mov	r1, r4
    6664:	4630      	mov	r0, r6
    6666:	f7ff fc61 	bl	5f2c <__swsetup_r>
    666a:	2800      	cmp	r0, #0
    666c:	d09e      	beq.n	65ac <_vfiprintf_r+0x2c>
    666e:	f04f 30ff 	mov.w	r0, #4294967295
    6672:	b01d      	add	sp, #116	; 0x74
    6674:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6678:	2b25      	cmp	r3, #37	; 0x25
    667a:	d0a7      	beq.n	65cc <_vfiprintf_r+0x4c>
    667c:	46a8      	mov	r8, r5
    667e:	e7a0      	b.n	65c2 <_vfiprintf_r+0x42>
    6680:	4a43      	ldr	r2, [pc, #268]	; (6790 <_vfiprintf_r+0x210>)
    6682:	1a80      	subs	r0, r0, r2
    6684:	fa0b f000 	lsl.w	r0, fp, r0
    6688:	4318      	orrs	r0, r3
    668a:	9004      	str	r0, [sp, #16]
    668c:	4645      	mov	r5, r8
    668e:	e7bb      	b.n	6608 <_vfiprintf_r+0x88>
    6690:	9a03      	ldr	r2, [sp, #12]
    6692:	1d11      	adds	r1, r2, #4
    6694:	6812      	ldr	r2, [r2, #0]
    6696:	9103      	str	r1, [sp, #12]
    6698:	2a00      	cmp	r2, #0
    669a:	db01      	blt.n	66a0 <_vfiprintf_r+0x120>
    669c:	9207      	str	r2, [sp, #28]
    669e:	e004      	b.n	66aa <_vfiprintf_r+0x12a>
    66a0:	4252      	negs	r2, r2
    66a2:	f043 0302 	orr.w	r3, r3, #2
    66a6:	9207      	str	r2, [sp, #28]
    66a8:	9304      	str	r3, [sp, #16]
    66aa:	f898 3000 	ldrb.w	r3, [r8]
    66ae:	2b2e      	cmp	r3, #46	; 0x2e
    66b0:	d110      	bne.n	66d4 <_vfiprintf_r+0x154>
    66b2:	f898 3001 	ldrb.w	r3, [r8, #1]
    66b6:	2b2a      	cmp	r3, #42	; 0x2a
    66b8:	f108 0101 	add.w	r1, r8, #1
    66bc:	d137      	bne.n	672e <_vfiprintf_r+0x1ae>
    66be:	9b03      	ldr	r3, [sp, #12]
    66c0:	1d1a      	adds	r2, r3, #4
    66c2:	681b      	ldr	r3, [r3, #0]
    66c4:	9203      	str	r2, [sp, #12]
    66c6:	2b00      	cmp	r3, #0
    66c8:	bfb8      	it	lt
    66ca:	f04f 33ff 	movlt.w	r3, #4294967295
    66ce:	f108 0802 	add.w	r8, r8, #2
    66d2:	9305      	str	r3, [sp, #20]
    66d4:	4d31      	ldr	r5, [pc, #196]	; (679c <_vfiprintf_r+0x21c>)
    66d6:	f898 1000 	ldrb.w	r1, [r8]
    66da:	2203      	movs	r2, #3
    66dc:	4628      	mov	r0, r5
    66de:	f000 faa7 	bl	6c30 <memchr>
    66e2:	b140      	cbz	r0, 66f6 <_vfiprintf_r+0x176>
    66e4:	2340      	movs	r3, #64	; 0x40
    66e6:	1b40      	subs	r0, r0, r5
    66e8:	fa03 f000 	lsl.w	r0, r3, r0
    66ec:	9b04      	ldr	r3, [sp, #16]
    66ee:	4303      	orrs	r3, r0
    66f0:	9304      	str	r3, [sp, #16]
    66f2:	f108 0801 	add.w	r8, r8, #1
    66f6:	f898 1000 	ldrb.w	r1, [r8]
    66fa:	4829      	ldr	r0, [pc, #164]	; (67a0 <_vfiprintf_r+0x220>)
    66fc:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    6700:	2206      	movs	r2, #6
    6702:	f108 0701 	add.w	r7, r8, #1
    6706:	f000 fa93 	bl	6c30 <memchr>
    670a:	2800      	cmp	r0, #0
    670c:	d034      	beq.n	6778 <_vfiprintf_r+0x1f8>
    670e:	4b25      	ldr	r3, [pc, #148]	; (67a4 <_vfiprintf_r+0x224>)
    6710:	bb03      	cbnz	r3, 6754 <_vfiprintf_r+0x1d4>
    6712:	9b03      	ldr	r3, [sp, #12]
    6714:	3307      	adds	r3, #7
    6716:	f023 0307 	bic.w	r3, r3, #7
    671a:	3308      	adds	r3, #8
    671c:	9303      	str	r3, [sp, #12]
    671e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6720:	444b      	add	r3, r9
    6722:	9309      	str	r3, [sp, #36]	; 0x24
    6724:	e74c      	b.n	65c0 <_vfiprintf_r+0x40>
    6726:	fb00 3202 	mla	r2, r0, r2, r3
    672a:	2101      	movs	r1, #1
    672c:	e786      	b.n	663c <_vfiprintf_r+0xbc>
    672e:	2300      	movs	r3, #0
    6730:	9305      	str	r3, [sp, #20]
    6732:	4618      	mov	r0, r3
    6734:	250a      	movs	r5, #10
    6736:	4688      	mov	r8, r1
    6738:	3101      	adds	r1, #1
    673a:	f898 2000 	ldrb.w	r2, [r8]
    673e:	3a30      	subs	r2, #48	; 0x30
    6740:	2a09      	cmp	r2, #9
    6742:	d903      	bls.n	674c <_vfiprintf_r+0x1cc>
    6744:	2b00      	cmp	r3, #0
    6746:	d0c5      	beq.n	66d4 <_vfiprintf_r+0x154>
    6748:	9005      	str	r0, [sp, #20]
    674a:	e7c3      	b.n	66d4 <_vfiprintf_r+0x154>
    674c:	fb05 2000 	mla	r0, r5, r0, r2
    6750:	2301      	movs	r3, #1
    6752:	e7f0      	b.n	6736 <_vfiprintf_r+0x1b6>
    6754:	ab03      	add	r3, sp, #12
    6756:	9300      	str	r3, [sp, #0]
    6758:	4622      	mov	r2, r4
    675a:	4b13      	ldr	r3, [pc, #76]	; (67a8 <_vfiprintf_r+0x228>)
    675c:	a904      	add	r1, sp, #16
    675e:	4630      	mov	r0, r6
    6760:	f3af 8000 	nop.w
    6764:	f1b0 3fff 	cmp.w	r0, #4294967295
    6768:	4681      	mov	r9, r0
    676a:	d1d8      	bne.n	671e <_vfiprintf_r+0x19e>
    676c:	89a3      	ldrh	r3, [r4, #12]
    676e:	065b      	lsls	r3, r3, #25
    6770:	f53f af7d 	bmi.w	666e <_vfiprintf_r+0xee>
    6774:	9809      	ldr	r0, [sp, #36]	; 0x24
    6776:	e77c      	b.n	6672 <_vfiprintf_r+0xf2>
    6778:	ab03      	add	r3, sp, #12
    677a:	9300      	str	r3, [sp, #0]
    677c:	4622      	mov	r2, r4
    677e:	4b0a      	ldr	r3, [pc, #40]	; (67a8 <_vfiprintf_r+0x228>)
    6780:	a904      	add	r1, sp, #16
    6782:	4630      	mov	r0, r6
    6784:	f000 f888 	bl	6898 <_printf_i>
    6788:	e7ec      	b.n	6764 <_vfiprintf_r+0x1e4>
    678a:	bf00      	nop
    678c:	000071c4 	.word	0x000071c4
    6790:	00007204 	.word	0x00007204
    6794:	000071e4 	.word	0x000071e4
    6798:	000071a4 	.word	0x000071a4
    679c:	0000720a 	.word	0x0000720a
    67a0:	0000720e 	.word	0x0000720e
    67a4:	00000000 	.word	0x00000000
    67a8:	0000655d 	.word	0x0000655d

000067ac <_printf_common>:
    67ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    67b0:	4691      	mov	r9, r2
    67b2:	461f      	mov	r7, r3
    67b4:	688a      	ldr	r2, [r1, #8]
    67b6:	690b      	ldr	r3, [r1, #16]
    67b8:	f8dd 8020 	ldr.w	r8, [sp, #32]
    67bc:	4293      	cmp	r3, r2
    67be:	bfb8      	it	lt
    67c0:	4613      	movlt	r3, r2
    67c2:	f8c9 3000 	str.w	r3, [r9]
    67c6:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    67ca:	4606      	mov	r6, r0
    67cc:	460c      	mov	r4, r1
    67ce:	b112      	cbz	r2, 67d6 <_printf_common+0x2a>
    67d0:	3301      	adds	r3, #1
    67d2:	f8c9 3000 	str.w	r3, [r9]
    67d6:	6823      	ldr	r3, [r4, #0]
    67d8:	0699      	lsls	r1, r3, #26
    67da:	bf42      	ittt	mi
    67dc:	f8d9 3000 	ldrmi.w	r3, [r9]
    67e0:	3302      	addmi	r3, #2
    67e2:	f8c9 3000 	strmi.w	r3, [r9]
    67e6:	6825      	ldr	r5, [r4, #0]
    67e8:	f015 0506 	ands.w	r5, r5, #6
    67ec:	d107      	bne.n	67fe <_printf_common+0x52>
    67ee:	f104 0a19 	add.w	sl, r4, #25
    67f2:	68e3      	ldr	r3, [r4, #12]
    67f4:	f8d9 2000 	ldr.w	r2, [r9]
    67f8:	1a9b      	subs	r3, r3, r2
    67fa:	429d      	cmp	r5, r3
    67fc:	db29      	blt.n	6852 <_printf_common+0xa6>
    67fe:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    6802:	6822      	ldr	r2, [r4, #0]
    6804:	3300      	adds	r3, #0
    6806:	bf18      	it	ne
    6808:	2301      	movne	r3, #1
    680a:	0692      	lsls	r2, r2, #26
    680c:	d42e      	bmi.n	686c <_printf_common+0xc0>
    680e:	f104 0243 	add.w	r2, r4, #67	; 0x43
    6812:	4639      	mov	r1, r7
    6814:	4630      	mov	r0, r6
    6816:	47c0      	blx	r8
    6818:	3001      	adds	r0, #1
    681a:	d021      	beq.n	6860 <_printf_common+0xb4>
    681c:	6823      	ldr	r3, [r4, #0]
    681e:	68e5      	ldr	r5, [r4, #12]
    6820:	f8d9 2000 	ldr.w	r2, [r9]
    6824:	f003 0306 	and.w	r3, r3, #6
    6828:	2b04      	cmp	r3, #4
    682a:	bf08      	it	eq
    682c:	1aad      	subeq	r5, r5, r2
    682e:	68a3      	ldr	r3, [r4, #8]
    6830:	6922      	ldr	r2, [r4, #16]
    6832:	bf0c      	ite	eq
    6834:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    6838:	2500      	movne	r5, #0
    683a:	4293      	cmp	r3, r2
    683c:	bfc4      	itt	gt
    683e:	1a9b      	subgt	r3, r3, r2
    6840:	18ed      	addgt	r5, r5, r3
    6842:	f04f 0900 	mov.w	r9, #0
    6846:	341a      	adds	r4, #26
    6848:	454d      	cmp	r5, r9
    684a:	d11b      	bne.n	6884 <_printf_common+0xd8>
    684c:	2000      	movs	r0, #0
    684e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6852:	2301      	movs	r3, #1
    6854:	4652      	mov	r2, sl
    6856:	4639      	mov	r1, r7
    6858:	4630      	mov	r0, r6
    685a:	47c0      	blx	r8
    685c:	3001      	adds	r0, #1
    685e:	d103      	bne.n	6868 <_printf_common+0xbc>
    6860:	f04f 30ff 	mov.w	r0, #4294967295
    6864:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6868:	3501      	adds	r5, #1
    686a:	e7c2      	b.n	67f2 <_printf_common+0x46>
    686c:	18e1      	adds	r1, r4, r3
    686e:	1c5a      	adds	r2, r3, #1
    6870:	2030      	movs	r0, #48	; 0x30
    6872:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    6876:	4422      	add	r2, r4
    6878:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    687c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    6880:	3302      	adds	r3, #2
    6882:	e7c4      	b.n	680e <_printf_common+0x62>
    6884:	2301      	movs	r3, #1
    6886:	4622      	mov	r2, r4
    6888:	4639      	mov	r1, r7
    688a:	4630      	mov	r0, r6
    688c:	47c0      	blx	r8
    688e:	3001      	adds	r0, #1
    6890:	d0e6      	beq.n	6860 <_printf_common+0xb4>
    6892:	f109 0901 	add.w	r9, r9, #1
    6896:	e7d7      	b.n	6848 <_printf_common+0x9c>

00006898 <_printf_i>:
    6898:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    689c:	4617      	mov	r7, r2
    689e:	7e0a      	ldrb	r2, [r1, #24]
    68a0:	b085      	sub	sp, #20
    68a2:	2a6e      	cmp	r2, #110	; 0x6e
    68a4:	4698      	mov	r8, r3
    68a6:	4606      	mov	r6, r0
    68a8:	460c      	mov	r4, r1
    68aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    68ac:	f101 0e43 	add.w	lr, r1, #67	; 0x43
    68b0:	f000 80bc 	beq.w	6a2c <_printf_i+0x194>
    68b4:	d81a      	bhi.n	68ec <_printf_i+0x54>
    68b6:	2a63      	cmp	r2, #99	; 0x63
    68b8:	d02e      	beq.n	6918 <_printf_i+0x80>
    68ba:	d80a      	bhi.n	68d2 <_printf_i+0x3a>
    68bc:	2a00      	cmp	r2, #0
    68be:	f000 80c8 	beq.w	6a52 <_printf_i+0x1ba>
    68c2:	2a58      	cmp	r2, #88	; 0x58
    68c4:	f000 808a 	beq.w	69dc <_printf_i+0x144>
    68c8:	f104 0542 	add.w	r5, r4, #66	; 0x42
    68cc:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
    68d0:	e02a      	b.n	6928 <_printf_i+0x90>
    68d2:	2a64      	cmp	r2, #100	; 0x64
    68d4:	d001      	beq.n	68da <_printf_i+0x42>
    68d6:	2a69      	cmp	r2, #105	; 0x69
    68d8:	d1f6      	bne.n	68c8 <_printf_i+0x30>
    68da:	6821      	ldr	r1, [r4, #0]
    68dc:	681a      	ldr	r2, [r3, #0]
    68de:	f011 0f80 	tst.w	r1, #128	; 0x80
    68e2:	d023      	beq.n	692c <_printf_i+0x94>
    68e4:	1d11      	adds	r1, r2, #4
    68e6:	6019      	str	r1, [r3, #0]
    68e8:	6813      	ldr	r3, [r2, #0]
    68ea:	e027      	b.n	693c <_printf_i+0xa4>
    68ec:	2a73      	cmp	r2, #115	; 0x73
    68ee:	f000 80b4 	beq.w	6a5a <_printf_i+0x1c2>
    68f2:	d808      	bhi.n	6906 <_printf_i+0x6e>
    68f4:	2a6f      	cmp	r2, #111	; 0x6f
    68f6:	d02a      	beq.n	694e <_printf_i+0xb6>
    68f8:	2a70      	cmp	r2, #112	; 0x70
    68fa:	d1e5      	bne.n	68c8 <_printf_i+0x30>
    68fc:	680a      	ldr	r2, [r1, #0]
    68fe:	f042 0220 	orr.w	r2, r2, #32
    6902:	600a      	str	r2, [r1, #0]
    6904:	e003      	b.n	690e <_printf_i+0x76>
    6906:	2a75      	cmp	r2, #117	; 0x75
    6908:	d021      	beq.n	694e <_printf_i+0xb6>
    690a:	2a78      	cmp	r2, #120	; 0x78
    690c:	d1dc      	bne.n	68c8 <_printf_i+0x30>
    690e:	2278      	movs	r2, #120	; 0x78
    6910:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
    6914:	496e      	ldr	r1, [pc, #440]	; (6ad0 <_printf_i+0x238>)
    6916:	e064      	b.n	69e2 <_printf_i+0x14a>
    6918:	681a      	ldr	r2, [r3, #0]
    691a:	f101 0542 	add.w	r5, r1, #66	; 0x42
    691e:	1d11      	adds	r1, r2, #4
    6920:	6019      	str	r1, [r3, #0]
    6922:	6813      	ldr	r3, [r2, #0]
    6924:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    6928:	2301      	movs	r3, #1
    692a:	e0a3      	b.n	6a74 <_printf_i+0x1dc>
    692c:	f011 0f40 	tst.w	r1, #64	; 0x40
    6930:	f102 0104 	add.w	r1, r2, #4
    6934:	6019      	str	r1, [r3, #0]
    6936:	d0d7      	beq.n	68e8 <_printf_i+0x50>
    6938:	f9b2 3000 	ldrsh.w	r3, [r2]
    693c:	2b00      	cmp	r3, #0
    693e:	da03      	bge.n	6948 <_printf_i+0xb0>
    6940:	222d      	movs	r2, #45	; 0x2d
    6942:	425b      	negs	r3, r3
    6944:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
    6948:	4962      	ldr	r1, [pc, #392]	; (6ad4 <_printf_i+0x23c>)
    694a:	220a      	movs	r2, #10
    694c:	e017      	b.n	697e <_printf_i+0xe6>
    694e:	6820      	ldr	r0, [r4, #0]
    6950:	6819      	ldr	r1, [r3, #0]
    6952:	f010 0f80 	tst.w	r0, #128	; 0x80
    6956:	d003      	beq.n	6960 <_printf_i+0xc8>
    6958:	1d08      	adds	r0, r1, #4
    695a:	6018      	str	r0, [r3, #0]
    695c:	680b      	ldr	r3, [r1, #0]
    695e:	e006      	b.n	696e <_printf_i+0xd6>
    6960:	f010 0f40 	tst.w	r0, #64	; 0x40
    6964:	f101 0004 	add.w	r0, r1, #4
    6968:	6018      	str	r0, [r3, #0]
    696a:	d0f7      	beq.n	695c <_printf_i+0xc4>
    696c:	880b      	ldrh	r3, [r1, #0]
    696e:	4959      	ldr	r1, [pc, #356]	; (6ad4 <_printf_i+0x23c>)
    6970:	2a6f      	cmp	r2, #111	; 0x6f
    6972:	bf14      	ite	ne
    6974:	220a      	movne	r2, #10
    6976:	2208      	moveq	r2, #8
    6978:	2000      	movs	r0, #0
    697a:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
    697e:	6865      	ldr	r5, [r4, #4]
    6980:	60a5      	str	r5, [r4, #8]
    6982:	2d00      	cmp	r5, #0
    6984:	f2c0 809c 	blt.w	6ac0 <_printf_i+0x228>
    6988:	6820      	ldr	r0, [r4, #0]
    698a:	f020 0004 	bic.w	r0, r0, #4
    698e:	6020      	str	r0, [r4, #0]
    6990:	2b00      	cmp	r3, #0
    6992:	d13f      	bne.n	6a14 <_printf_i+0x17c>
    6994:	2d00      	cmp	r5, #0
    6996:	f040 8095 	bne.w	6ac4 <_printf_i+0x22c>
    699a:	4675      	mov	r5, lr
    699c:	2a08      	cmp	r2, #8
    699e:	d10b      	bne.n	69b8 <_printf_i+0x120>
    69a0:	6823      	ldr	r3, [r4, #0]
    69a2:	07da      	lsls	r2, r3, #31
    69a4:	d508      	bpl.n	69b8 <_printf_i+0x120>
    69a6:	6923      	ldr	r3, [r4, #16]
    69a8:	6862      	ldr	r2, [r4, #4]
    69aa:	429a      	cmp	r2, r3
    69ac:	bfde      	ittt	le
    69ae:	2330      	movle	r3, #48	; 0x30
    69b0:	f805 3c01 	strble.w	r3, [r5, #-1]
    69b4:	f105 35ff 	addle.w	r5, r5, #4294967295
    69b8:	ebae 0305 	sub.w	r3, lr, r5
    69bc:	6123      	str	r3, [r4, #16]
    69be:	f8cd 8000 	str.w	r8, [sp]
    69c2:	463b      	mov	r3, r7
    69c4:	aa03      	add	r2, sp, #12
    69c6:	4621      	mov	r1, r4
    69c8:	4630      	mov	r0, r6
    69ca:	f7ff feef 	bl	67ac <_printf_common>
    69ce:	3001      	adds	r0, #1
    69d0:	d155      	bne.n	6a7e <_printf_i+0x1e6>
    69d2:	f04f 30ff 	mov.w	r0, #4294967295
    69d6:	b005      	add	sp, #20
    69d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    69dc:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
    69e0:	493c      	ldr	r1, [pc, #240]	; (6ad4 <_printf_i+0x23c>)
    69e2:	6822      	ldr	r2, [r4, #0]
    69e4:	6818      	ldr	r0, [r3, #0]
    69e6:	f012 0f80 	tst.w	r2, #128	; 0x80
    69ea:	f100 0504 	add.w	r5, r0, #4
    69ee:	601d      	str	r5, [r3, #0]
    69f0:	d001      	beq.n	69f6 <_printf_i+0x15e>
    69f2:	6803      	ldr	r3, [r0, #0]
    69f4:	e002      	b.n	69fc <_printf_i+0x164>
    69f6:	0655      	lsls	r5, r2, #25
    69f8:	d5fb      	bpl.n	69f2 <_printf_i+0x15a>
    69fa:	8803      	ldrh	r3, [r0, #0]
    69fc:	07d0      	lsls	r0, r2, #31
    69fe:	bf44      	itt	mi
    6a00:	f042 0220 	orrmi.w	r2, r2, #32
    6a04:	6022      	strmi	r2, [r4, #0]
    6a06:	b91b      	cbnz	r3, 6a10 <_printf_i+0x178>
    6a08:	6822      	ldr	r2, [r4, #0]
    6a0a:	f022 0220 	bic.w	r2, r2, #32
    6a0e:	6022      	str	r2, [r4, #0]
    6a10:	2210      	movs	r2, #16
    6a12:	e7b1      	b.n	6978 <_printf_i+0xe0>
    6a14:	4675      	mov	r5, lr
    6a16:	fbb3 f0f2 	udiv	r0, r3, r2
    6a1a:	fb02 3310 	mls	r3, r2, r0, r3
    6a1e:	5ccb      	ldrb	r3, [r1, r3]
    6a20:	f805 3d01 	strb.w	r3, [r5, #-1]!
    6a24:	4603      	mov	r3, r0
    6a26:	2800      	cmp	r0, #0
    6a28:	d1f5      	bne.n	6a16 <_printf_i+0x17e>
    6a2a:	e7b7      	b.n	699c <_printf_i+0x104>
    6a2c:	6808      	ldr	r0, [r1, #0]
    6a2e:	681a      	ldr	r2, [r3, #0]
    6a30:	6949      	ldr	r1, [r1, #20]
    6a32:	f010 0f80 	tst.w	r0, #128	; 0x80
    6a36:	d004      	beq.n	6a42 <_printf_i+0x1aa>
    6a38:	1d10      	adds	r0, r2, #4
    6a3a:	6018      	str	r0, [r3, #0]
    6a3c:	6813      	ldr	r3, [r2, #0]
    6a3e:	6019      	str	r1, [r3, #0]
    6a40:	e007      	b.n	6a52 <_printf_i+0x1ba>
    6a42:	f010 0f40 	tst.w	r0, #64	; 0x40
    6a46:	f102 0004 	add.w	r0, r2, #4
    6a4a:	6018      	str	r0, [r3, #0]
    6a4c:	6813      	ldr	r3, [r2, #0]
    6a4e:	d0f6      	beq.n	6a3e <_printf_i+0x1a6>
    6a50:	8019      	strh	r1, [r3, #0]
    6a52:	2300      	movs	r3, #0
    6a54:	6123      	str	r3, [r4, #16]
    6a56:	4675      	mov	r5, lr
    6a58:	e7b1      	b.n	69be <_printf_i+0x126>
    6a5a:	681a      	ldr	r2, [r3, #0]
    6a5c:	1d11      	adds	r1, r2, #4
    6a5e:	6019      	str	r1, [r3, #0]
    6a60:	6815      	ldr	r5, [r2, #0]
    6a62:	6862      	ldr	r2, [r4, #4]
    6a64:	2100      	movs	r1, #0
    6a66:	4628      	mov	r0, r5
    6a68:	f000 f8e2 	bl	6c30 <memchr>
    6a6c:	b108      	cbz	r0, 6a72 <_printf_i+0x1da>
    6a6e:	1b40      	subs	r0, r0, r5
    6a70:	6060      	str	r0, [r4, #4]
    6a72:	6863      	ldr	r3, [r4, #4]
    6a74:	6123      	str	r3, [r4, #16]
    6a76:	2300      	movs	r3, #0
    6a78:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    6a7c:	e79f      	b.n	69be <_printf_i+0x126>
    6a7e:	6923      	ldr	r3, [r4, #16]
    6a80:	462a      	mov	r2, r5
    6a82:	4639      	mov	r1, r7
    6a84:	4630      	mov	r0, r6
    6a86:	47c0      	blx	r8
    6a88:	3001      	adds	r0, #1
    6a8a:	d0a2      	beq.n	69d2 <_printf_i+0x13a>
    6a8c:	6823      	ldr	r3, [r4, #0]
    6a8e:	079b      	lsls	r3, r3, #30
    6a90:	d507      	bpl.n	6aa2 <_printf_i+0x20a>
    6a92:	2500      	movs	r5, #0
    6a94:	f104 0919 	add.w	r9, r4, #25
    6a98:	68e3      	ldr	r3, [r4, #12]
    6a9a:	9a03      	ldr	r2, [sp, #12]
    6a9c:	1a9b      	subs	r3, r3, r2
    6a9e:	429d      	cmp	r5, r3
    6aa0:	db05      	blt.n	6aae <_printf_i+0x216>
    6aa2:	68e0      	ldr	r0, [r4, #12]
    6aa4:	9b03      	ldr	r3, [sp, #12]
    6aa6:	4298      	cmp	r0, r3
    6aa8:	bfb8      	it	lt
    6aaa:	4618      	movlt	r0, r3
    6aac:	e793      	b.n	69d6 <_printf_i+0x13e>
    6aae:	2301      	movs	r3, #1
    6ab0:	464a      	mov	r2, r9
    6ab2:	4639      	mov	r1, r7
    6ab4:	4630      	mov	r0, r6
    6ab6:	47c0      	blx	r8
    6ab8:	3001      	adds	r0, #1
    6aba:	d08a      	beq.n	69d2 <_printf_i+0x13a>
    6abc:	3501      	adds	r5, #1
    6abe:	e7eb      	b.n	6a98 <_printf_i+0x200>
    6ac0:	2b00      	cmp	r3, #0
    6ac2:	d1a7      	bne.n	6a14 <_printf_i+0x17c>
    6ac4:	780b      	ldrb	r3, [r1, #0]
    6ac6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    6aca:	f104 0542 	add.w	r5, r4, #66	; 0x42
    6ace:	e765      	b.n	699c <_printf_i+0x104>
    6ad0:	00007226 	.word	0x00007226
    6ad4:	00007215 	.word	0x00007215

00006ad8 <_sbrk_r>:
    6ad8:	b538      	push	{r3, r4, r5, lr}
    6ada:	4c06      	ldr	r4, [pc, #24]	; (6af4 <_sbrk_r+0x1c>)
    6adc:	2300      	movs	r3, #0
    6ade:	4605      	mov	r5, r0
    6ae0:	4608      	mov	r0, r1
    6ae2:	6023      	str	r3, [r4, #0]
    6ae4:	f7fa ffea 	bl	1abc <_sbrk>
    6ae8:	1c43      	adds	r3, r0, #1
    6aea:	d102      	bne.n	6af2 <_sbrk_r+0x1a>
    6aec:	6823      	ldr	r3, [r4, #0]
    6aee:	b103      	cbz	r3, 6af2 <_sbrk_r+0x1a>
    6af0:	602b      	str	r3, [r5, #0]
    6af2:	bd38      	pop	{r3, r4, r5, pc}
    6af4:	2000eb10 	.word	0x2000eb10

00006af8 <__sread>:
    6af8:	b510      	push	{r4, lr}
    6afa:	460c      	mov	r4, r1
    6afc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    6b00:	f000 f8e8 	bl	6cd4 <_read_r>
    6b04:	2800      	cmp	r0, #0
    6b06:	bfab      	itete	ge
    6b08:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    6b0a:	89a3      	ldrhlt	r3, [r4, #12]
    6b0c:	181b      	addge	r3, r3, r0
    6b0e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    6b12:	bfac      	ite	ge
    6b14:	6563      	strge	r3, [r4, #84]	; 0x54
    6b16:	81a3      	strhlt	r3, [r4, #12]
    6b18:	bd10      	pop	{r4, pc}

00006b1a <__swrite>:
    6b1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6b1e:	461f      	mov	r7, r3
    6b20:	898b      	ldrh	r3, [r1, #12]
    6b22:	05db      	lsls	r3, r3, #23
    6b24:	4605      	mov	r5, r0
    6b26:	460c      	mov	r4, r1
    6b28:	4616      	mov	r6, r2
    6b2a:	d505      	bpl.n	6b38 <__swrite+0x1e>
    6b2c:	2302      	movs	r3, #2
    6b2e:	2200      	movs	r2, #0
    6b30:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    6b34:	f000 f868 	bl	6c08 <_lseek_r>
    6b38:	89a3      	ldrh	r3, [r4, #12]
    6b3a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    6b3e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    6b42:	81a3      	strh	r3, [r4, #12]
    6b44:	4632      	mov	r2, r6
    6b46:	463b      	mov	r3, r7
    6b48:	4628      	mov	r0, r5
    6b4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    6b4e:	f000 b817 	b.w	6b80 <_write_r>

00006b52 <__sseek>:
    6b52:	b510      	push	{r4, lr}
    6b54:	460c      	mov	r4, r1
    6b56:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    6b5a:	f000 f855 	bl	6c08 <_lseek_r>
    6b5e:	1c43      	adds	r3, r0, #1
    6b60:	89a3      	ldrh	r3, [r4, #12]
    6b62:	bf15      	itete	ne
    6b64:	6560      	strne	r0, [r4, #84]	; 0x54
    6b66:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    6b6a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    6b6e:	81a3      	strheq	r3, [r4, #12]
    6b70:	bf18      	it	ne
    6b72:	81a3      	strhne	r3, [r4, #12]
    6b74:	bd10      	pop	{r4, pc}

00006b76 <__sclose>:
    6b76:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    6b7a:	f000 b813 	b.w	6ba4 <_close_r>
	...

00006b80 <_write_r>:
    6b80:	b538      	push	{r3, r4, r5, lr}
    6b82:	4c07      	ldr	r4, [pc, #28]	; (6ba0 <_write_r+0x20>)
    6b84:	4605      	mov	r5, r0
    6b86:	4608      	mov	r0, r1
    6b88:	4611      	mov	r1, r2
    6b8a:	2200      	movs	r2, #0
    6b8c:	6022      	str	r2, [r4, #0]
    6b8e:	461a      	mov	r2, r3
    6b90:	f7fd f99e 	bl	3ed0 <_write>
    6b94:	1c43      	adds	r3, r0, #1
    6b96:	d102      	bne.n	6b9e <_write_r+0x1e>
    6b98:	6823      	ldr	r3, [r4, #0]
    6b9a:	b103      	cbz	r3, 6b9e <_write_r+0x1e>
    6b9c:	602b      	str	r3, [r5, #0]
    6b9e:	bd38      	pop	{r3, r4, r5, pc}
    6ba0:	2000eb10 	.word	0x2000eb10

00006ba4 <_close_r>:
    6ba4:	b538      	push	{r3, r4, r5, lr}
    6ba6:	4c06      	ldr	r4, [pc, #24]	; (6bc0 <_close_r+0x1c>)
    6ba8:	2300      	movs	r3, #0
    6baa:	4605      	mov	r5, r0
    6bac:	4608      	mov	r0, r1
    6bae:	6023      	str	r3, [r4, #0]
    6bb0:	f7fa ff96 	bl	1ae0 <_close>
    6bb4:	1c43      	adds	r3, r0, #1
    6bb6:	d102      	bne.n	6bbe <_close_r+0x1a>
    6bb8:	6823      	ldr	r3, [r4, #0]
    6bba:	b103      	cbz	r3, 6bbe <_close_r+0x1a>
    6bbc:	602b      	str	r3, [r5, #0]
    6bbe:	bd38      	pop	{r3, r4, r5, pc}
    6bc0:	2000eb10 	.word	0x2000eb10

00006bc4 <_fstat_r>:
    6bc4:	b538      	push	{r3, r4, r5, lr}
    6bc6:	4c07      	ldr	r4, [pc, #28]	; (6be4 <_fstat_r+0x20>)
    6bc8:	2300      	movs	r3, #0
    6bca:	4605      	mov	r5, r0
    6bcc:	4608      	mov	r0, r1
    6bce:	4611      	mov	r1, r2
    6bd0:	6023      	str	r3, [r4, #0]
    6bd2:	f7fa ff88 	bl	1ae6 <_fstat>
    6bd6:	1c43      	adds	r3, r0, #1
    6bd8:	d102      	bne.n	6be0 <_fstat_r+0x1c>
    6bda:	6823      	ldr	r3, [r4, #0]
    6bdc:	b103      	cbz	r3, 6be0 <_fstat_r+0x1c>
    6bde:	602b      	str	r3, [r5, #0]
    6be0:	bd38      	pop	{r3, r4, r5, pc}
    6be2:	bf00      	nop
    6be4:	2000eb10 	.word	0x2000eb10

00006be8 <_isatty_r>:
    6be8:	b538      	push	{r3, r4, r5, lr}
    6bea:	4c06      	ldr	r4, [pc, #24]	; (6c04 <_isatty_r+0x1c>)
    6bec:	2300      	movs	r3, #0
    6bee:	4605      	mov	r5, r0
    6bf0:	4608      	mov	r0, r1
    6bf2:	6023      	str	r3, [r4, #0]
    6bf4:	f7fa ff7c 	bl	1af0 <_isatty>
    6bf8:	1c43      	adds	r3, r0, #1
    6bfa:	d102      	bne.n	6c02 <_isatty_r+0x1a>
    6bfc:	6823      	ldr	r3, [r4, #0]
    6bfe:	b103      	cbz	r3, 6c02 <_isatty_r+0x1a>
    6c00:	602b      	str	r3, [r5, #0]
    6c02:	bd38      	pop	{r3, r4, r5, pc}
    6c04:	2000eb10 	.word	0x2000eb10

00006c08 <_lseek_r>:
    6c08:	b538      	push	{r3, r4, r5, lr}
    6c0a:	4c07      	ldr	r4, [pc, #28]	; (6c28 <_lseek_r+0x20>)
    6c0c:	4605      	mov	r5, r0
    6c0e:	4608      	mov	r0, r1
    6c10:	4611      	mov	r1, r2
    6c12:	2200      	movs	r2, #0
    6c14:	6022      	str	r2, [r4, #0]
    6c16:	461a      	mov	r2, r3
    6c18:	f7fa ff6c 	bl	1af4 <_lseek>
    6c1c:	1c43      	adds	r3, r0, #1
    6c1e:	d102      	bne.n	6c26 <_lseek_r+0x1e>
    6c20:	6823      	ldr	r3, [r4, #0]
    6c22:	b103      	cbz	r3, 6c26 <_lseek_r+0x1e>
    6c24:	602b      	str	r3, [r5, #0]
    6c26:	bd38      	pop	{r3, r4, r5, pc}
    6c28:	2000eb10 	.word	0x2000eb10
    6c2c:	00000000 	.word	0x00000000

00006c30 <memchr>:
    6c30:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6c34:	2a10      	cmp	r2, #16
    6c36:	db2b      	blt.n	6c90 <memchr+0x60>
    6c38:	f010 0f07 	tst.w	r0, #7
    6c3c:	d008      	beq.n	6c50 <memchr+0x20>
    6c3e:	f810 3b01 	ldrb.w	r3, [r0], #1
    6c42:	3a01      	subs	r2, #1
    6c44:	428b      	cmp	r3, r1
    6c46:	d02d      	beq.n	6ca4 <memchr+0x74>
    6c48:	f010 0f07 	tst.w	r0, #7
    6c4c:	b342      	cbz	r2, 6ca0 <memchr+0x70>
    6c4e:	d1f6      	bne.n	6c3e <memchr+0xe>
    6c50:	b4f0      	push	{r4, r5, r6, r7}
    6c52:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    6c56:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    6c5a:	f022 0407 	bic.w	r4, r2, #7
    6c5e:	f07f 0700 	mvns.w	r7, #0
    6c62:	2300      	movs	r3, #0
    6c64:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    6c68:	3c08      	subs	r4, #8
    6c6a:	ea85 0501 	eor.w	r5, r5, r1
    6c6e:	ea86 0601 	eor.w	r6, r6, r1
    6c72:	fa85 f547 	uadd8	r5, r5, r7
    6c76:	faa3 f587 	sel	r5, r3, r7
    6c7a:	fa86 f647 	uadd8	r6, r6, r7
    6c7e:	faa5 f687 	sel	r6, r5, r7
    6c82:	b98e      	cbnz	r6, 6ca8 <memchr+0x78>
    6c84:	d1ee      	bne.n	6c64 <memchr+0x34>
    6c86:	bcf0      	pop	{r4, r5, r6, r7}
    6c88:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6c8c:	f002 0207 	and.w	r2, r2, #7
    6c90:	b132      	cbz	r2, 6ca0 <memchr+0x70>
    6c92:	f810 3b01 	ldrb.w	r3, [r0], #1
    6c96:	3a01      	subs	r2, #1
    6c98:	ea83 0301 	eor.w	r3, r3, r1
    6c9c:	b113      	cbz	r3, 6ca4 <memchr+0x74>
    6c9e:	d1f8      	bne.n	6c92 <memchr+0x62>
    6ca0:	2000      	movs	r0, #0
    6ca2:	4770      	bx	lr
    6ca4:	3801      	subs	r0, #1
    6ca6:	4770      	bx	lr
    6ca8:	2d00      	cmp	r5, #0
    6caa:	bf06      	itte	eq
    6cac:	4635      	moveq	r5, r6
    6cae:	3803      	subeq	r0, #3
    6cb0:	3807      	subne	r0, #7
    6cb2:	f015 0f01 	tst.w	r5, #1
    6cb6:	d107      	bne.n	6cc8 <memchr+0x98>
    6cb8:	3001      	adds	r0, #1
    6cba:	f415 7f80 	tst.w	r5, #256	; 0x100
    6cbe:	bf02      	ittt	eq
    6cc0:	3001      	addeq	r0, #1
    6cc2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    6cc6:	3001      	addeq	r0, #1
    6cc8:	bcf0      	pop	{r4, r5, r6, r7}
    6cca:	3801      	subs	r0, #1
    6ccc:	4770      	bx	lr
    6cce:	bf00      	nop

00006cd0 <__malloc_lock>:
    6cd0:	4770      	bx	lr

00006cd2 <__malloc_unlock>:
    6cd2:	4770      	bx	lr

00006cd4 <_read_r>:
    6cd4:	b538      	push	{r3, r4, r5, lr}
    6cd6:	4c07      	ldr	r4, [pc, #28]	; (6cf4 <_read_r+0x20>)
    6cd8:	4605      	mov	r5, r0
    6cda:	4608      	mov	r0, r1
    6cdc:	4611      	mov	r1, r2
    6cde:	2200      	movs	r2, #0
    6ce0:	6022      	str	r2, [r4, #0]
    6ce2:	461a      	mov	r2, r3
    6ce4:	f7fd f8e4 	bl	3eb0 <_read>
    6ce8:	1c43      	adds	r3, r0, #1
    6cea:	d102      	bne.n	6cf2 <_read_r+0x1e>
    6cec:	6823      	ldr	r3, [r4, #0]
    6cee:	b103      	cbz	r3, 6cf2 <_read_r+0x1e>
    6cf0:	602b      	str	r3, [r5, #0]
    6cf2:	bd38      	pop	{r3, r4, r5, pc}
    6cf4:	2000eb10 	.word	0x2000eb10
    6cf8:	6c6c6548 	.word	0x6c6c6548
    6cfc:	6f57206f 	.word	0x6f57206f
    6d00:	21646c72 	.word	0x21646c72
    6d04:	00000000 	.word	0x00000000
    6d08:	64616552 	.word	0x64616552
    6d0c:	20676e69 	.word	0x20676e69
    6d10:	6d6f7266 	.word	0x6d6f7266
    6d14:	616c6620 	.word	0x616c6620
    6d18:	2e2e6873 	.word	0x2e2e6873
    6d1c:	0000002e 	.word	0x0000002e
    6d20:	656e6f64 	.word	0x656e6f64
    6d24:	00000d0a 	.word	0x00000d0a
    6d28:	652f2e2e 	.word	0x652f2e2e
    6d2c:	72656874 	.word	0x72656874
    6d30:	5f74656e 	.word	0x5f74656e
    6d34:	2f796870 	.word	0x2f796870
    6d38:	65687465 	.word	0x65687465
    6d3c:	74656e72 	.word	0x74656e72
    6d40:	7968705f 	.word	0x7968705f
    6d44:	0000632e 	.word	0x0000632e
    6d48:	682f2e2e 	.word	0x682f2e2e
    6d4c:	732f6c61 	.word	0x732f6c61
    6d50:	682f6372 	.word	0x682f6372
    6d54:	615f6c61 	.word	0x615f6c61
    6d58:	735f6364 	.word	0x735f6364
    6d5c:	2e636e79 	.word	0x2e636e79
    6d60:	00000063 	.word	0x00000063
    6d64:	682f2e2e 	.word	0x682f2e2e
    6d68:	732f6c61 	.word	0x732f6c61
    6d6c:	682f6372 	.word	0x682f6372
    6d70:	645f6c61 	.word	0x645f6c61
    6d74:	735f6361 	.word	0x735f6361
    6d78:	2e636e79 	.word	0x2e636e79
    6d7c:	00000063 	.word	0x00000063
    6d80:	682f2e2e 	.word	0x682f2e2e
    6d84:	732f6c61 	.word	0x732f6c61
    6d88:	682f6372 	.word	0x682f6372
    6d8c:	665f6c61 	.word	0x665f6c61
    6d90:	6873616c 	.word	0x6873616c
    6d94:	0000632e 	.word	0x0000632e
    6d98:	682f2e2e 	.word	0x682f2e2e
    6d9c:	732f6c61 	.word	0x732f6c61
    6da0:	682f6372 	.word	0x682f6372
    6da4:	695f6c61 	.word	0x695f6c61
    6da8:	00632e6f 	.word	0x00632e6f
    6dac:	682f2e2e 	.word	0x682f2e2e
    6db0:	732f6c61 	.word	0x732f6c61
    6db4:	682f6372 	.word	0x682f6372
    6db8:	6d5f6c61 	.word	0x6d5f6c61
    6dbc:	615f6361 	.word	0x615f6361
    6dc0:	636e7973 	.word	0x636e7973
    6dc4:	0000632e 	.word	0x0000632e
    6dc8:	682f2e2e 	.word	0x682f2e2e
    6dcc:	732f6c61 	.word	0x732f6c61
    6dd0:	682f6372 	.word	0x682f6372
    6dd4:	735f6c61 	.word	0x735f6c61
    6dd8:	6d5f6970 	.word	0x6d5f6970
    6ddc:	6e79735f 	.word	0x6e79735f
    6de0:	00632e63 	.word	0x00632e63
    6de4:	682f2e2e 	.word	0x682f2e2e
    6de8:	732f6c61 	.word	0x732f6c61
    6dec:	682f6372 	.word	0x682f6372
    6df0:	755f6c61 	.word	0x755f6c61
    6df4:	74726173 	.word	0x74726173
    6df8:	2e736f5f 	.word	0x2e736f5f
    6dfc:	00000063 	.word	0x00000063
    6e00:	682f2e2e 	.word	0x682f2e2e
    6e04:	732f6c61 	.word	0x732f6c61
    6e08:	682f6372 	.word	0x682f6372
    6e0c:	755f6c61 	.word	0x755f6c61
    6e10:	74726173 	.word	0x74726173
    6e14:	6e79735f 	.word	0x6e79735f
    6e18:	00632e63 	.word	0x00632e63
    6e1c:	682f2e2e 	.word	0x682f2e2e
    6e20:	752f6c61 	.word	0x752f6c61
    6e24:	736c6974 	.word	0x736c6974
    6e28:	6372732f 	.word	0x6372732f
    6e2c:	6974752f 	.word	0x6974752f
    6e30:	725f736c 	.word	0x725f736c
    6e34:	62676e69 	.word	0x62676e69
    6e38:	65666675 	.word	0x65666675
    6e3c:	00632e72 	.word	0x00632e72

00006e40 <_adcs>:
    6e40:	00000001 00000000 00000000 00000000     ................
	...
    6e58:	682f2e2e 612f6c70 682f6364 615f6c70     ../hpl/adc/hpl_a
    6e68:	632e6364 00000000 682f2e2e 642f6c70     dc.c....../hpl/d
    6e78:	682f6361 645f6c70 632e6361 00000000     ac/hpl_dac.c....

00006e88 <_cfgs>:
	...
    6f88:	682f2e2e 6e2f6c70 74636d76 682f6c72     ../hpl/nvmctrl/h
    6f98:	6e5f6c70 74636d76 632e6c72 00000000     pl_nvmctrl.c....
    6fa8:	40003000 40003400 41012000 41014000     .0.@.4.@. .A.@.A
    6fb8:	43000000 43000400 43000800 43000c00     ...C...C...C...C

00006fc8 <_usarts>:
    6fc8:	00000006 40100004 00030000 00700002     .......@......p.
    6fd8:	0000f62b 00000000 00000007 40100004     +..............@
    6fe8:	00030000 00700002 0000fc11 00000000     ......p.........

00006ff8 <_i2cms>:
	...

00007010 <sercomspi_regs>:
    7010:	0020000c 00020000 00000000 01ff00fe     .. .............
    7020:	20000c00 02000000 00000000 ff00fe00     ... ............
    7030:	000c0101 00000020 00000002 00fe0000     .... ...........
    7040:	0c0201ff 00002000 00000200 fe000000     ..... ..........
    7050:	0301ff00 0020000c 00020000 00000000     ...... .........
    7060:	01ff00fe 20000c04 02000000 00000000     ....... ........
    7070:	ff00fe00 00000501 682f2e2e 732f6c70     ........../hpl/s
    7080:	6f637265 70682f6d 65735f6c 6d6f6372     ercom/hpl_sercom
    7090:	0000632e 20636164 6e616863 206c656e     .c..dac channel 
    70a0:	62616e65 0a64656c 0000000d 20434441     enabled.....ADC 
    70b0:	77207369 696b726f 0d0a676e 00000000     is working......
    70c0:	20434144 77207369 696b726f 0d0a676e     DAC is working..
    70d0:	00000000 6f727245 64253d72 00000a0d     ....Error=%d....
    70e0:	65676150 666f2073 616c6620 253d6873     Pages of flash=%
    70f0:	61702064 735f6567 3d657a69 0d0a6425     d page_size=%d..
    7100:	00000000 415f5049 20524444 3a202020     ....IP_ADDR    :
    7110:	0d732520 0000000a 5f54454e 4b53414d      %s.....NET_MASK
    7120:	3a202020 0d732520 0000000a 45544147        : %s.....GATE
    7130:	5f594157 3a205049 0d732520 0000000a     WAY_IP : %s.....
    7140:	00434144 00434441 742f2e2e 64726968     DAC.ADC.../third
    7150:	74726170 54522f79 662f534f 72656572     party/RTOS/freer
    7160:	2f736f74 65657246 534f5452 322e3856     tos/FreeRTOSV8.2
    7170:	722f332e 5f736f74 74726f70 0000632e     .3/rtos_port.c..
    7180:	454c4449 00000000 09632509 25097525     IDLE.....%c.%u.%
    7190:	75250975 00000a0d 20726d54 00637653     u.%u....Tmr Svc.

000071a0 <_global_impure_ptr>:
    71a0:	20000010                                ... 

000071a4 <__sf_fake_stderr>:
	...

000071c4 <__sf_fake_stdin>:
	...

000071e4 <__sf_fake_stdout>:
	...
    7204:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    7214:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    7224:	31300046 35343332 39383736 64636261     F.0123456789abcd
    7234:	00006665                                ef..

00007238 <_init>:
    7238:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    723a:	bf00      	nop
    723c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    723e:	bc08      	pop	{r3}
    7240:	469e      	mov	lr, r3
    7242:	4770      	bx	lr

00007244 <__init_array_start>:
    7244:	00000289 	.word	0x00000289

00007248 <_fini>:
    7248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    724a:	bf00      	nop
    724c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    724e:	bc08      	pop	{r3}
    7250:	469e      	mov	lr, r3
    7252:	4770      	bx	lr

00007254 <__fini_array_start>:
    7254:	00000265 	.word	0x00000265
